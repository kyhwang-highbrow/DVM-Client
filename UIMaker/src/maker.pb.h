// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: maker.proto

#ifndef PROTOBUF_maker_2eproto__INCLUDED
#define PROTOBUF_maker_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace maker {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_maker_2eproto();
void protobuf_AssignDesc_maker_2eproto();
void protobuf_ShutdownFile_maker_2eproto();

class COLOR;
class FILE;
class FILE_IMAGE;
class FILE_SOUND;
class FILE_BMFONT;
class FILE_TTF;
class FILE_VISUAL;
class FILE_PLIST;
class NAME_VISUAL_GROUP;
class NAME_VISUAL;
class Node;
class ClippingNode;
class LayerColor;
class LayerGradient;
class LabelSystemFont;
class LabelTTF;
class LabelBMFont;
class TextFieldTTF;
class EditBox;
class Button;
class Sprite;
class Scale9Sprite;
class TableView;
class ProgressTimer;
class Visual;
class SocketNode;
class Particle;
class RotatePlate;
class Properties;
class Entity;
class CMD;

enum DOCK_POINT {
  DOCK__BOTTOM_LEFT = 0,
  DOCK__BOTTOM_CENTER = 1,
  DOCK__BOTTOM_RIGHT = 2,
  DOCK__MIDDLE_LEFT = 3,
  DOCK__MIDDLE_CENTER = 4,
  DOCK__MIDDLE_RIGHT = 5,
  DOCK__TOP_LEFT = 6,
  DOCK__TOP_CENTER = 7,
  DOCK__TOP_RIGHT = 8
};
bool DOCK_POINT_IsValid(int value);
const DOCK_POINT DOCK_POINT_MIN = DOCK__BOTTOM_LEFT;
const DOCK_POINT DOCK_POINT_MAX = DOCK__TOP_RIGHT;
const int DOCK_POINT_ARRAYSIZE = DOCK_POINT_MAX + 1;

const ::google::protobuf::EnumDescriptor* DOCK_POINT_descriptor();
inline const ::std::string& DOCK_POINT_Name(DOCK_POINT value) {
  return ::google::protobuf::internal::NameOfEnum(
    DOCK_POINT_descriptor(), value);
}
inline bool DOCK_POINT_Parse(
    const ::std::string& name, DOCK_POINT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DOCK_POINT>(
    DOCK_POINT_descriptor(), name, value);
}
enum ANCHOR_POINT {
  ANCHOR__BOTTOM_LEFT = 0,
  ANCHOR__BOTTOM_CENTER = 1,
  ANCHOR__BOTTOM_RIGHT = 2,
  ANCHOR__MIDDLE_LEFT = 3,
  ANCHOR__MIDDLE_CENTER = 4,
  ANCHOR__MIDDLE_RIGHT = 5,
  ANCHOR__TOP_LEFT = 6,
  ANCHOR__TOP_CENTER = 7,
  ANCHOR__TOP_RIGHT = 8
};
bool ANCHOR_POINT_IsValid(int value);
const ANCHOR_POINT ANCHOR_POINT_MIN = ANCHOR__BOTTOM_LEFT;
const ANCHOR_POINT ANCHOR_POINT_MAX = ANCHOR__TOP_RIGHT;
const int ANCHOR_POINT_ARRAYSIZE = ANCHOR_POINT_MAX + 1;

const ::google::protobuf::EnumDescriptor* ANCHOR_POINT_descriptor();
inline const ::std::string& ANCHOR_POINT_Name(ANCHOR_POINT value) {
  return ::google::protobuf::internal::NameOfEnum(
    ANCHOR_POINT_descriptor(), value);
}
inline bool ANCHOR_POINT_Parse(
    const ::std::string& name, ANCHOR_POINT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ANCHOR_POINT>(
    ANCHOR_POINT_descriptor(), name, value);
}
enum BLEND_FUNCTION {
  BLEND__GL_ZERO = 0,
  BLEND__GL_ONE = 1,
  BLEND__GL_SRC_COLOR = 768,
  BLEND__GL_DST_COLOR = 774,
  BLEND__GL_ONE_MINUS_SRC_COLOR = 769,
  BLEND__GL_ONE_MINUS_DST_COLOR = 775,
  BLEND__GL_SRC_ALPHA = 770,
  BLEND__GL_DST_ALPHA = 772,
  BLEND__GL_ONE_MINUS_SRC_ALPHA = 771,
  BLEND__GL_ONE_MINUS_DST_ALPHA = 773,
  BLEND__GL_SRC_ALPHA_SATURATE = 776
};
bool BLEND_FUNCTION_IsValid(int value);
const BLEND_FUNCTION BLEND_FUNCTION_MIN = BLEND__GL_ZERO;
const BLEND_FUNCTION BLEND_FUNCTION_MAX = BLEND__GL_SRC_ALPHA_SATURATE;
const int BLEND_FUNCTION_ARRAYSIZE = BLEND_FUNCTION_MAX + 1;

const ::google::protobuf::EnumDescriptor* BLEND_FUNCTION_descriptor();
inline const ::std::string& BLEND_FUNCTION_Name(BLEND_FUNCTION value) {
  return ::google::protobuf::internal::NameOfEnum(
    BLEND_FUNCTION_descriptor(), value);
}
inline bool BLEND_FUNCTION_Parse(
    const ::std::string& name, BLEND_FUNCTION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BLEND_FUNCTION>(
    BLEND_FUNCTION_descriptor(), name, value);
}
enum TEXT_ALIGNMENT_H {
  TEXT_ALIGN_H__LEFT = 0,
  TEXT_ALIGN_H__CENTER = 1,
  TEXT_ALIGN_H__RIGHT = 2
};
bool TEXT_ALIGNMENT_H_IsValid(int value);
const TEXT_ALIGNMENT_H TEXT_ALIGNMENT_H_MIN = TEXT_ALIGN_H__LEFT;
const TEXT_ALIGNMENT_H TEXT_ALIGNMENT_H_MAX = TEXT_ALIGN_H__RIGHT;
const int TEXT_ALIGNMENT_H_ARRAYSIZE = TEXT_ALIGNMENT_H_MAX + 1;

const ::google::protobuf::EnumDescriptor* TEXT_ALIGNMENT_H_descriptor();
inline const ::std::string& TEXT_ALIGNMENT_H_Name(TEXT_ALIGNMENT_H value) {
  return ::google::protobuf::internal::NameOfEnum(
    TEXT_ALIGNMENT_H_descriptor(), value);
}
inline bool TEXT_ALIGNMENT_H_Parse(
    const ::std::string& name, TEXT_ALIGNMENT_H* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TEXT_ALIGNMENT_H>(
    TEXT_ALIGNMENT_H_descriptor(), name, value);
}
enum TEXT_ALIGNMENT_V {
  TEXT_ALIGN_V__TOP = 0,
  TEXT_ALIGN_V__CENTER = 1,
  TEXT_ALIGN_V__BOTTOM = 2
};
bool TEXT_ALIGNMENT_V_IsValid(int value);
const TEXT_ALIGNMENT_V TEXT_ALIGNMENT_V_MIN = TEXT_ALIGN_V__TOP;
const TEXT_ALIGNMENT_V TEXT_ALIGNMENT_V_MAX = TEXT_ALIGN_V__BOTTOM;
const int TEXT_ALIGNMENT_V_ARRAYSIZE = TEXT_ALIGNMENT_V_MAX + 1;

const ::google::protobuf::EnumDescriptor* TEXT_ALIGNMENT_V_descriptor();
inline const ::std::string& TEXT_ALIGNMENT_V_Name(TEXT_ALIGNMENT_V value) {
  return ::google::protobuf::internal::NameOfEnum(
    TEXT_ALIGNMENT_V_descriptor(), value);
}
inline bool TEXT_ALIGNMENT_V_Parse(
    const ::std::string& name, TEXT_ALIGNMENT_V* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TEXT_ALIGNMENT_V>(
    TEXT_ALIGNMENT_V_descriptor(), name, value);
}
enum FILL_TYPE {
  FILL__STRETCH = 0,
  FILL__REPEAT = 1
};
bool FILL_TYPE_IsValid(int value);
const FILL_TYPE FILL_TYPE_MIN = FILL__STRETCH;
const FILL_TYPE FILL_TYPE_MAX = FILL__REPEAT;
const int FILL_TYPE_ARRAYSIZE = FILL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* FILL_TYPE_descriptor();
inline const ::std::string& FILL_TYPE_Name(FILL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    FILL_TYPE_descriptor(), value);
}
inline bool FILL_TYPE_Parse(
    const ::std::string& name, FILL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FILL_TYPE>(
    FILL_TYPE_descriptor(), name, value);
}
enum PROGRESS_TYPE {
  PROGRESS__RADIAL_CW = 0,
  PROGRESS__RADIAL_CCW = 1,
  PROGRESS__TOP_TO_BOTTOM = 2,
  PROGRESS__BOTTOM_TO_TOP = 3,
  PROGRESS__LEFT_TO_RIGHT = 4,
  PROGRESS__RIGHT_TO_LEFT = 5
};
bool PROGRESS_TYPE_IsValid(int value);
const PROGRESS_TYPE PROGRESS_TYPE_MIN = PROGRESS__RADIAL_CW;
const PROGRESS_TYPE PROGRESS_TYPE_MAX = PROGRESS__RIGHT_TO_LEFT;
const int PROGRESS_TYPE_ARRAYSIZE = PROGRESS_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PROGRESS_TYPE_descriptor();
inline const ::std::string& PROGRESS_TYPE_Name(PROGRESS_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PROGRESS_TYPE_descriptor(), value);
}
inline bool PROGRESS_TYPE_Parse(
    const ::std::string& name, PROGRESS_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PROGRESS_TYPE>(
    PROGRESS_TYPE_descriptor(), name, value);
}
enum SCROLL_TYPE {
  SCROLL__NONE = 0,
  SCROLL__VERTICAL = 1,
  SCROLL__HORIZONTAL = 2,
  SCROLL__BOTH = 3
};
bool SCROLL_TYPE_IsValid(int value);
const SCROLL_TYPE SCROLL_TYPE_MIN = SCROLL__NONE;
const SCROLL_TYPE SCROLL_TYPE_MAX = SCROLL__BOTH;
const int SCROLL_TYPE_ARRAYSIZE = SCROLL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SCROLL_TYPE_descriptor();
inline const ::std::string& SCROLL_TYPE_Name(SCROLL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SCROLL_TYPE_descriptor(), value);
}
inline bool SCROLL_TYPE_Parse(
    const ::std::string& name, SCROLL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SCROLL_TYPE>(
    SCROLL_TYPE_descriptor(), name, value);
}
enum PICK_PART {
  PICK_PART__NONE = 0,
  PICK_PART__CENTER = 1,
  PICK_PART__TOP = 2,
  PICK_PART__BOTTOM = 3,
  PICK_PART__LEFT = 4,
  PICK_PART__RIGHT = 5,
  PICK_PART__LEFT_BOTTOM = 6,
  PICK_PART__LEFT_TOP = 7,
  PICK_PART__RIGHT_BOTTOM = 8,
  PICK_PART__RIGHT_TOP = 9,
  PICK_PART__SELECT_BOX = 10,
  PICK_PART__SCROLL = 11
};
bool PICK_PART_IsValid(int value);
const PICK_PART PICK_PART_MIN = PICK_PART__NONE;
const PICK_PART PICK_PART_MAX = PICK_PART__SCROLL;
const int PICK_PART_ARRAYSIZE = PICK_PART_MAX + 1;

const ::google::protobuf::EnumDescriptor* PICK_PART_descriptor();
inline const ::std::string& PICK_PART_Name(PICK_PART value) {
  return ::google::protobuf::internal::NameOfEnum(
    PICK_PART_descriptor(), value);
}
inline bool PICK_PART_Parse(
    const ::std::string& name, PICK_PART* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PICK_PART>(
    PICK_PART_descriptor(), name, value);
}
enum STROKE_TYPE {
  STROKE_TYPE__NORMAL = 0,
  STROKE_TYPE__CUSTOM = 1
};
bool STROKE_TYPE_IsValid(int value);
const STROKE_TYPE STROKE_TYPE_MIN = STROKE_TYPE__NORMAL;
const STROKE_TYPE STROKE_TYPE_MAX = STROKE_TYPE__CUSTOM;
const int STROKE_TYPE_ARRAYSIZE = STROKE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* STROKE_TYPE_descriptor();
inline const ::std::string& STROKE_TYPE_Name(STROKE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    STROKE_TYPE_descriptor(), value);
}
inline bool STROKE_TYPE_Parse(
    const ::std::string& name, STROKE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<STROKE_TYPE>(
    STROKE_TYPE_descriptor(), name, value);
}
enum SHADOW_DIRECTION {
  SHADOW_DIR_90 = 0,
  SHADOW_DIR_135 = 1,
  SHADOW_DIR_45 = 2,
  SHADOW_DIR_MINUS_90 = 3
};
bool SHADOW_DIRECTION_IsValid(int value);
const SHADOW_DIRECTION SHADOW_DIRECTION_MIN = SHADOW_DIR_90;
const SHADOW_DIRECTION SHADOW_DIRECTION_MAX = SHADOW_DIR_MINUS_90;
const int SHADOW_DIRECTION_ARRAYSIZE = SHADOW_DIRECTION_MAX + 1;

const ::google::protobuf::EnumDescriptor* SHADOW_DIRECTION_descriptor();
inline const ::std::string& SHADOW_DIRECTION_Name(SHADOW_DIRECTION value) {
  return ::google::protobuf::internal::NameOfEnum(
    SHADOW_DIRECTION_descriptor(), value);
}
inline bool SHADOW_DIRECTION_Parse(
    const ::std::string& name, SHADOW_DIRECTION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SHADOW_DIRECTION>(
    SHADOW_DIRECTION_descriptor(), name, value);
}
enum BUTTON_IMAGE_TYPE {
  BUTTON_IMAGE_TYPE__SPRITE = 0,
  BUTTON_IMAGE_TYPE__SCALE9SPRITE = 1
};
bool BUTTON_IMAGE_TYPE_IsValid(int value);
const BUTTON_IMAGE_TYPE BUTTON_IMAGE_TYPE_MIN = BUTTON_IMAGE_TYPE__SPRITE;
const BUTTON_IMAGE_TYPE BUTTON_IMAGE_TYPE_MAX = BUTTON_IMAGE_TYPE__SCALE9SPRITE;
const int BUTTON_IMAGE_TYPE_ARRAYSIZE = BUTTON_IMAGE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* BUTTON_IMAGE_TYPE_descriptor();
inline const ::std::string& BUTTON_IMAGE_TYPE_Name(BUTTON_IMAGE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    BUTTON_IMAGE_TYPE_descriptor(), value);
}
inline bool BUTTON_IMAGE_TYPE_Parse(
    const ::std::string& name, BUTTON_IMAGE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BUTTON_IMAGE_TYPE>(
    BUTTON_IMAGE_TYPE_descriptor(), name, value);
}
enum EDITBOX_INPUT_MODE {
  EDITBOX_INPUT_MODE__ANY = 0,
  EDITBOX_INPUT_MODE__EMAIL_ADDRESS = 1,
  EDITBOX_INPUT_MODE__NUMERIC = 2,
  EDITBOX_INPUT_MODE__PHONE_NUMBER = 3,
  EDITBOX_INPUT_MODE__URL = 4,
  EDITBOX_INPUT_MODE__DECIMAL = 5,
  EDITBOX_INPUT_MODE__SINGLE_LINE = 6
};
bool EDITBOX_INPUT_MODE_IsValid(int value);
const EDITBOX_INPUT_MODE EDITBOX_INPUT_MODE_MIN = EDITBOX_INPUT_MODE__ANY;
const EDITBOX_INPUT_MODE EDITBOX_INPUT_MODE_MAX = EDITBOX_INPUT_MODE__SINGLE_LINE;
const int EDITBOX_INPUT_MODE_ARRAYSIZE = EDITBOX_INPUT_MODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EDITBOX_INPUT_MODE_descriptor();
inline const ::std::string& EDITBOX_INPUT_MODE_Name(EDITBOX_INPUT_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EDITBOX_INPUT_MODE_descriptor(), value);
}
inline bool EDITBOX_INPUT_MODE_Parse(
    const ::std::string& name, EDITBOX_INPUT_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EDITBOX_INPUT_MODE>(
    EDITBOX_INPUT_MODE_descriptor(), name, value);
}
enum EDITBOX_INPUT_FLAG {
  EDITBOX_INPUT_FLAG__PASSWORD = 0,
  EDITBOX_INPUT_FLAG__SENSITIVE = 1,
  EDITBOX_INPUT_FLAG__INITIAL_CAPS_WORD = 2,
  EDITBOX_INPUT_FLAG__INITIAL_CAPS_SENTENCE = 3,
  EDITBOX_INPUT_FLAG__INTIAL_CAPS_ALL_CHARACTERS = 4
};
bool EDITBOX_INPUT_FLAG_IsValid(int value);
const EDITBOX_INPUT_FLAG EDITBOX_INPUT_FLAG_MIN = EDITBOX_INPUT_FLAG__PASSWORD;
const EDITBOX_INPUT_FLAG EDITBOX_INPUT_FLAG_MAX = EDITBOX_INPUT_FLAG__INTIAL_CAPS_ALL_CHARACTERS;
const int EDITBOX_INPUT_FLAG_ARRAYSIZE = EDITBOX_INPUT_FLAG_MAX + 1;

const ::google::protobuf::EnumDescriptor* EDITBOX_INPUT_FLAG_descriptor();
inline const ::std::string& EDITBOX_INPUT_FLAG_Name(EDITBOX_INPUT_FLAG value) {
  return ::google::protobuf::internal::NameOfEnum(
    EDITBOX_INPUT_FLAG_descriptor(), value);
}
inline bool EDITBOX_INPUT_FLAG_Parse(
    const ::std::string& name, EDITBOX_INPUT_FLAG* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EDITBOX_INPUT_FLAG>(
    EDITBOX_INPUT_FLAG_descriptor(), name, value);
}
enum EDITBOX_RETURN_TYPE {
  EDITBOX_RETURN_TYPE__DEFAULT = 0,
  EDITBOX_RETURN_TYPE__DONE = 1,
  EDITBOX_RETURN_TYPE__SEND = 2,
  EDITBOX_RETURN_TYPE__SEARCH = 3,
  EDITBOX_RETURN_TYPE__GO = 4
};
bool EDITBOX_RETURN_TYPE_IsValid(int value);
const EDITBOX_RETURN_TYPE EDITBOX_RETURN_TYPE_MIN = EDITBOX_RETURN_TYPE__DEFAULT;
const EDITBOX_RETURN_TYPE EDITBOX_RETURN_TYPE_MAX = EDITBOX_RETURN_TYPE__GO;
const int EDITBOX_RETURN_TYPE_ARRAYSIZE = EDITBOX_RETURN_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EDITBOX_RETURN_TYPE_descriptor();
inline const ::std::string& EDITBOX_RETURN_TYPE_Name(EDITBOX_RETURN_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EDITBOX_RETURN_TYPE_descriptor(), value);
}
inline bool EDITBOX_RETURN_TYPE_Parse(
    const ::std::string& name, EDITBOX_RETURN_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EDITBOX_RETURN_TYPE>(
    EDITBOX_RETURN_TYPE_descriptor(), name, value);
}
enum NODE_ACTION_TYPE {
  NODE_ACTION_TYPE__NONE = 0,
  NODE_ACTION_TYPE__LEFT = 1,
  NODE_ACTION_TYPE__RIGHT = 2,
  NODE_ACTION_TYPE__TOP = 3,
  NODE_ACTION_TYPE__BOTTOM = 4,
  NODE_ACTION_TYPE__SCALE = 5,
  NODE_ACTION_TYPE__OPACITY = 6,
  NODE_ACTION_TYPE__OPACITY_R = 7,
  NODE_ACTION_TYPE__CUSTOM_1 = 8,
  NODE_ACTION_TYPE__CUSTOM_2 = 9,
  NODE_ACTION_TYPE__CUSTOM_3 = 10
};
bool NODE_ACTION_TYPE_IsValid(int value);
const NODE_ACTION_TYPE NODE_ACTION_TYPE_MIN = NODE_ACTION_TYPE__NONE;
const NODE_ACTION_TYPE NODE_ACTION_TYPE_MAX = NODE_ACTION_TYPE__CUSTOM_3;
const int NODE_ACTION_TYPE_ARRAYSIZE = NODE_ACTION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* NODE_ACTION_TYPE_descriptor();
inline const ::std::string& NODE_ACTION_TYPE_Name(NODE_ACTION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    NODE_ACTION_TYPE_descriptor(), value);
}
inline bool NODE_ACTION_TYPE_Parse(
    const ::std::string& name, NODE_ACTION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NODE_ACTION_TYPE>(
    NODE_ACTION_TYPE_descriptor(), name, value);
}
enum ROTATE_PLATE_ORIGIN_DIR {
  ROTATE_PLATE_ORIGIN_DIR__DOWN = 0,
  ROTATE_PLATE_ORIGIN_DIR__UP = 1,
  ROTATE_PLATE_ORIGIN_DIR__LEFT = 2,
  ROTATE_PLATE_ORIGIN_DIR__RIGHT = 3
};
bool ROTATE_PLATE_ORIGIN_DIR_IsValid(int value);
const ROTATE_PLATE_ORIGIN_DIR ROTATE_PLATE_ORIGIN_DIR_MIN = ROTATE_PLATE_ORIGIN_DIR__DOWN;
const ROTATE_PLATE_ORIGIN_DIR ROTATE_PLATE_ORIGIN_DIR_MAX = ROTATE_PLATE_ORIGIN_DIR__RIGHT;
const int ROTATE_PLATE_ORIGIN_DIR_ARRAYSIZE = ROTATE_PLATE_ORIGIN_DIR_MAX + 1;

const ::google::protobuf::EnumDescriptor* ROTATE_PLATE_ORIGIN_DIR_descriptor();
inline const ::std::string& ROTATE_PLATE_ORIGIN_DIR_Name(ROTATE_PLATE_ORIGIN_DIR value) {
  return ::google::protobuf::internal::NameOfEnum(
    ROTATE_PLATE_ORIGIN_DIR_descriptor(), value);
}
inline bool ROTATE_PLATE_ORIGIN_DIR_Parse(
    const ::std::string& name, ROTATE_PLATE_ORIGIN_DIR* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ROTATE_PLATE_ORIGIN_DIR>(
    ROTATE_PLATE_ORIGIN_DIR_descriptor(), name, value);
}
enum RELATIVE_SIZE_TYPE {
  RELATIVE_SIZE_TYPE__NONE = 0,
  RELATIVE_SIZE_TYPE__VERTICAL = 1,
  RELATIVE_SIZE_TYPE__HORIZONTAL = 2,
  RELATIVE_SIZE_TYPE__BOTH = 3,
  RELATIVE_SIZE_TYPE__ROOT = 4
};
bool RELATIVE_SIZE_TYPE_IsValid(int value);
const RELATIVE_SIZE_TYPE RELATIVE_SIZE_TYPE_MIN = RELATIVE_SIZE_TYPE__NONE;
const RELATIVE_SIZE_TYPE RELATIVE_SIZE_TYPE_MAX = RELATIVE_SIZE_TYPE__ROOT;
const int RELATIVE_SIZE_TYPE_ARRAYSIZE = RELATIVE_SIZE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* RELATIVE_SIZE_TYPE_descriptor();
inline const ::std::string& RELATIVE_SIZE_TYPE_Name(RELATIVE_SIZE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    RELATIVE_SIZE_TYPE_descriptor(), value);
}
inline bool RELATIVE_SIZE_TYPE_Parse(
    const ::std::string& name, RELATIVE_SIZE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RELATIVE_SIZE_TYPE>(
    RELATIVE_SIZE_TYPE_descriptor(), name, value);
}
enum STENCIL_TYPE {
  SQUARE = 0,
  CUSTOM = 1
};
bool STENCIL_TYPE_IsValid(int value);
const STENCIL_TYPE STENCIL_TYPE_MIN = SQUARE;
const STENCIL_TYPE STENCIL_TYPE_MAX = CUSTOM;
const int STENCIL_TYPE_ARRAYSIZE = STENCIL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* STENCIL_TYPE_descriptor();
inline const ::std::string& STENCIL_TYPE_Name(STENCIL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    STENCIL_TYPE_descriptor(), value);
}
inline bool STENCIL_TYPE_Parse(
    const ::std::string& name, STENCIL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<STENCIL_TYPE>(
    STENCIL_TYPE_descriptor(), name, value);
}
enum SCREEN_UI_TYPE {
  SCREEN_UI_TYPE__NONE = 0,
  SCREEN_UI_TYPE__BOTTOM = 1,
  SCREEN_UI_TYPE__TOP = 2,
  SCREEN_UI_TYPE__BOTH = 3
};
bool SCREEN_UI_TYPE_IsValid(int value);
const SCREEN_UI_TYPE SCREEN_UI_TYPE_MIN = SCREEN_UI_TYPE__NONE;
const SCREEN_UI_TYPE SCREEN_UI_TYPE_MAX = SCREEN_UI_TYPE__BOTH;
const int SCREEN_UI_TYPE_ARRAYSIZE = SCREEN_UI_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SCREEN_UI_TYPE_descriptor();
inline const ::std::string& SCREEN_UI_TYPE_Name(SCREEN_UI_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SCREEN_UI_TYPE_descriptor(), value);
}
inline bool SCREEN_UI_TYPE_Parse(
    const ::std::string& name, SCREEN_UI_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SCREEN_UI_TYPE>(
    SCREEN_UI_TYPE_descriptor(), name, value);
}
enum ENTITY_TYPE {
  ENTITY__Node = 10,
  ENTITY__ClippingNode = 11,
  ENTITY__LayerColor = 13,
  ENTITY__LayerGradient = 14,
  ENTITY__LabelSystemFont = 16,
  ENTITY__LabelTTF = 17,
  ENTITY__TextFieldTTF = 18,
  ENTITY__EditBox = 20,
  ENTITY__TableView = 21,
  ENTITY__RotatePlate = 22,
  ENTITY__Menu = 24,
  ENTITY__Button = 25,
  ENTITY__Sprite = 27,
  ENTITY__Scale9Sprite = 28,
  ENTITY__ProgressTimer = 29,
  ENTITY__Visual = 31,
  ENTITY__Particle = 32,
  ENTITY__NoNeedNode = 200,
  ENTITY__SocketNode = 201
};
bool ENTITY_TYPE_IsValid(int value);
const ENTITY_TYPE ENTITY_TYPE_MIN = ENTITY__Node;
const ENTITY_TYPE ENTITY_TYPE_MAX = ENTITY__SocketNode;
const int ENTITY_TYPE_ARRAYSIZE = ENTITY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ENTITY_TYPE_descriptor();
inline const ::std::string& ENTITY_TYPE_Name(ENTITY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ENTITY_TYPE_descriptor(), value);
}
inline bool ENTITY_TYPE_Parse(
    const ::std::string& name, ENTITY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ENTITY_TYPE>(
    ENTITY_TYPE_descriptor(), name, value);
}
enum CMD_TYPE {
  CMD__Create = 1,
  CMD__Remove = 2,
  CMD__Modify = 3,
  CMD__Move = 4,
  CMD__Copy = 5,
  CMD__Cut = 6,
  CMD__Paste = 7,
  CMD__SelectOne = 10,
  CMD__SelectAppend = 11,
  CMD__SelectBoxAppend = 12,
  CMD__SizeToContent = 13,
  CMD__Undo = 20,
  CMD__Redo = 21,
  CMD__History = 22,
  CMD__LuaNames = 23,
  CMD__ApplyToViewer = 30,
  CMD__ClearViewer = 31,
  CMD__EventToViewer = 32,
  CMD__ApplyToTool = 40,
  CMD__EventToTool = 41,
  CMD__MoveViewer = 50
};
bool CMD_TYPE_IsValid(int value);
const CMD_TYPE CMD_TYPE_MIN = CMD__Create;
const CMD_TYPE CMD_TYPE_MAX = CMD__MoveViewer;
const int CMD_TYPE_ARRAYSIZE = CMD_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMD_TYPE_descriptor();
inline const ::std::string& CMD_TYPE_Name(CMD_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMD_TYPE_descriptor(), value);
}
inline bool CMD_TYPE_Parse(
    const ::std::string& name, CMD_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMD_TYPE>(
    CMD_TYPE_descriptor(), name, value);
}
enum EVENT_TO_TOOL {
  EVENT__None = 1,
  EVENT__Save = 11,
  EVENT__SaveAs = 12,
  EVENT__Open = 13,
  EVENT__Close = 14,
  EVENT__Copy = 21,
  EVENT__Cut = 22,
  EVENT__Paste = 23,
  EVENT__Remove = 24,
  EVENT__ToggleDisplayStats = 30,
  EVENT__ReopenView = 40,
  EVENT__NextResolution = 41,
  EVENT__PrevResolution = 42,
  EVENT__SpecResolution = 43,
  EVENT__ConfResolution = 44,
  EVENT__ToggleVisible = 50
};
bool EVENT_TO_TOOL_IsValid(int value);
const EVENT_TO_TOOL EVENT_TO_TOOL_MIN = EVENT__None;
const EVENT_TO_TOOL EVENT_TO_TOOL_MAX = EVENT__ToggleVisible;
const int EVENT_TO_TOOL_ARRAYSIZE = EVENT_TO_TOOL_MAX + 1;

const ::google::protobuf::EnumDescriptor* EVENT_TO_TOOL_descriptor();
inline const ::std::string& EVENT_TO_TOOL_Name(EVENT_TO_TOOL value) {
  return ::google::protobuf::internal::NameOfEnum(
    EVENT_TO_TOOL_descriptor(), value);
}
inline bool EVENT_TO_TOOL_Parse(
    const ::std::string& name, EVENT_TO_TOOL* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVENT_TO_TOOL>(
    EVENT_TO_TOOL_descriptor(), name, value);
}
enum EVENT_TO_VIEWER {
  VIEWER_EVENT__None = 1,
  VIEWER_EVENT__StrokeSize1 = 11,
  VIEWER_EVENT__StrokeSize2 = 12,
  VIEWER_EVENT__StrokeSize3 = 13,
  VIEWER_EVENT__StrokeSize4 = 14,
  VIEWER_EVENT__GridOnOff = 20,
  VIEWER_EVENT__GridOpacity = 21,
  VIEWER_EVENT__ResetZoom = 22,
  VIEWER_EVENT__ResetScroll = 23
};
bool EVENT_TO_VIEWER_IsValid(int value);
const EVENT_TO_VIEWER EVENT_TO_VIEWER_MIN = VIEWER_EVENT__None;
const EVENT_TO_VIEWER EVENT_TO_VIEWER_MAX = VIEWER_EVENT__ResetScroll;
const int EVENT_TO_VIEWER_ARRAYSIZE = EVENT_TO_VIEWER_MAX + 1;

const ::google::protobuf::EnumDescriptor* EVENT_TO_VIEWER_descriptor();
inline const ::std::string& EVENT_TO_VIEWER_Name(EVENT_TO_VIEWER value) {
  return ::google::protobuf::internal::NameOfEnum(
    EVENT_TO_VIEWER_descriptor(), value);
}
inline bool EVENT_TO_VIEWER_Parse(
    const ::std::string& name, EVENT_TO_VIEWER* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVENT_TO_VIEWER>(
    EVENT_TO_VIEWER_descriptor(), name, value);
}
// ===================================================================

class COLOR : public ::google::protobuf::Message {
 public:
  COLOR();
  virtual ~COLOR();

  COLOR(const COLOR& from);

  inline COLOR& operator=(const COLOR& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const COLOR& default_instance();

  void Swap(COLOR* other);

  // implements Message ----------------------------------------------

  COLOR* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const COLOR& from);
  void MergeFrom(const COLOR& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 r = 1 [default = 255];
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 1;
  inline ::google::protobuf::int32 r() const;
  inline void set_r(::google::protobuf::int32 value);

  // required int32 g = 2 [default = 255];
  inline bool has_g() const;
  inline void clear_g();
  static const int kGFieldNumber = 2;
  inline ::google::protobuf::int32 g() const;
  inline void set_g(::google::protobuf::int32 value);

  // required int32 b = 3 [default = 255];
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 3;
  inline ::google::protobuf::int32 b() const;
  inline void set_b(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maker.COLOR)
 private:
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_g();
  inline void clear_has_g();
  inline void set_has_b();
  inline void clear_has_b();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 r_;
  ::google::protobuf::int32 g_;
  ::google::protobuf::int32 b_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static COLOR* default_instance_;
};
// -------------------------------------------------------------------

class FILE : public ::google::protobuf::Message {
 public:
  FILE();
  virtual ~FILE();

  FILE(const FILE& from);

  inline FILE& operator=(const FILE& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FILE& default_instance();

  void Swap(FILE* other);

  // implements Message ----------------------------------------------

  FILE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FILE& from);
  void MergeFrom(const FILE& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1 [default = ""];
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:maker.FILE)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static FILE* default_instance_;
};
// -------------------------------------------------------------------

class FILE_IMAGE : public ::google::protobuf::Message {
 public:
  FILE_IMAGE();
  virtual ~FILE_IMAGE();

  FILE_IMAGE(const FILE_IMAGE& from);

  inline FILE_IMAGE& operator=(const FILE_IMAGE& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FILE_IMAGE& default_instance();

  void Swap(FILE_IMAGE* other);

  // implements Message ----------------------------------------------

  FILE_IMAGE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FILE_IMAGE& from);
  void MergeFrom(const FILE_IMAGE& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1 [default = ""];
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:maker.FILE_IMAGE)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static FILE_IMAGE* default_instance_;
};
// -------------------------------------------------------------------

class FILE_SOUND : public ::google::protobuf::Message {
 public:
  FILE_SOUND();
  virtual ~FILE_SOUND();

  FILE_SOUND(const FILE_SOUND& from);

  inline FILE_SOUND& operator=(const FILE_SOUND& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FILE_SOUND& default_instance();

  void Swap(FILE_SOUND* other);

  // implements Message ----------------------------------------------

  FILE_SOUND* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FILE_SOUND& from);
  void MergeFrom(const FILE_SOUND& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1 [default = ""];
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:maker.FILE_SOUND)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static FILE_SOUND* default_instance_;
};
// -------------------------------------------------------------------

class FILE_BMFONT : public ::google::protobuf::Message {
 public:
  FILE_BMFONT();
  virtual ~FILE_BMFONT();

  FILE_BMFONT(const FILE_BMFONT& from);

  inline FILE_BMFONT& operator=(const FILE_BMFONT& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FILE_BMFONT& default_instance();

  void Swap(FILE_BMFONT* other);

  // implements Message ----------------------------------------------

  FILE_BMFONT* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FILE_BMFONT& from);
  void MergeFrom(const FILE_BMFONT& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1 [default = ""];
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:maker.FILE_BMFONT)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static FILE_BMFONT* default_instance_;
};
// -------------------------------------------------------------------

class FILE_TTF : public ::google::protobuf::Message {
 public:
  FILE_TTF();
  virtual ~FILE_TTF();

  FILE_TTF(const FILE_TTF& from);

  inline FILE_TTF& operator=(const FILE_TTF& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FILE_TTF& default_instance();

  void Swap(FILE_TTF* other);

  // implements Message ----------------------------------------------

  FILE_TTF* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FILE_TTF& from);
  void MergeFrom(const FILE_TTF& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1 [default = ""];
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:maker.FILE_TTF)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static FILE_TTF* default_instance_;
};
// -------------------------------------------------------------------

class FILE_VISUAL : public ::google::protobuf::Message {
 public:
  FILE_VISUAL();
  virtual ~FILE_VISUAL();

  FILE_VISUAL(const FILE_VISUAL& from);

  inline FILE_VISUAL& operator=(const FILE_VISUAL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FILE_VISUAL& default_instance();

  void Swap(FILE_VISUAL* other);

  // implements Message ----------------------------------------------

  FILE_VISUAL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FILE_VISUAL& from);
  void MergeFrom(const FILE_VISUAL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1 [default = ""];
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:maker.FILE_VISUAL)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static FILE_VISUAL* default_instance_;
};
// -------------------------------------------------------------------

class FILE_PLIST : public ::google::protobuf::Message {
 public:
  FILE_PLIST();
  virtual ~FILE_PLIST();

  FILE_PLIST(const FILE_PLIST& from);

  inline FILE_PLIST& operator=(const FILE_PLIST& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FILE_PLIST& default_instance();

  void Swap(FILE_PLIST* other);

  // implements Message ----------------------------------------------

  FILE_PLIST* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FILE_PLIST& from);
  void MergeFrom(const FILE_PLIST& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1 [default = ""];
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:maker.FILE_PLIST)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static FILE_PLIST* default_instance_;
};
// -------------------------------------------------------------------

class NAME_VISUAL_GROUP : public ::google::protobuf::Message {
 public:
  NAME_VISUAL_GROUP();
  virtual ~NAME_VISUAL_GROUP();

  NAME_VISUAL_GROUP(const NAME_VISUAL_GROUP& from);

  inline NAME_VISUAL_GROUP& operator=(const NAME_VISUAL_GROUP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NAME_VISUAL_GROUP& default_instance();

  void Swap(NAME_VISUAL_GROUP* other);

  // implements Message ----------------------------------------------

  NAME_VISUAL_GROUP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NAME_VISUAL_GROUP& from);
  void MergeFrom(const NAME_VISUAL_GROUP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = ""];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:maker.NAME_VISUAL_GROUP)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static NAME_VISUAL_GROUP* default_instance_;
};
// -------------------------------------------------------------------

class NAME_VISUAL : public ::google::protobuf::Message {
 public:
  NAME_VISUAL();
  virtual ~NAME_VISUAL();

  NAME_VISUAL(const NAME_VISUAL& from);

  inline NAME_VISUAL& operator=(const NAME_VISUAL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NAME_VISUAL& default_instance();

  void Swap(NAME_VISUAL* other);

  // implements Message ----------------------------------------------

  NAME_VISUAL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NAME_VISUAL& from);
  void MergeFrom(const NAME_VISUAL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = ""];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:maker.NAME_VISUAL)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static NAME_VISUAL* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ui_name = 1 [default = ""];
  inline bool has_ui_name() const;
  inline void clear_ui_name();
  static const int kUiNameFieldNumber = 1;
  inline const ::std::string& ui_name() const;
  inline void set_ui_name(const ::std::string& value);
  inline void set_ui_name(const char* value);
  inline void set_ui_name(const char* value, size_t size);
  inline ::std::string* mutable_ui_name();
  inline ::std::string* release_ui_name();
  inline void set_allocated_ui_name(::std::string* ui_name);

  // optional string flag = 2 [default = ""];
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline const ::std::string& flag() const;
  inline void set_flag(const ::std::string& value);
  inline void set_flag(const char* value);
  inline void set_flag(const char* value, size_t size);
  inline ::std::string* mutable_flag();
  inline ::std::string* release_flag();
  inline void set_allocated_flag(::std::string* flag);

  // optional float x = 3 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 4 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline float y() const;
  inline void set_y(float value);

  // optional .maker.DOCK_POINT dock_point = 5 [default = DOCK__MIDDLE_CENTER];
  inline bool has_dock_point() const;
  inline void clear_dock_point();
  static const int kDockPointFieldNumber = 5;
  inline ::maker::DOCK_POINT dock_point() const;
  inline void set_dock_point(::maker::DOCK_POINT value);

  // optional .maker.ANCHOR_POINT anchor_point = 6 [default = ANCHOR__MIDDLE_CENTER];
  inline bool has_anchor_point() const;
  inline void clear_anchor_point();
  static const int kAnchorPointFieldNumber = 6;
  inline ::maker::ANCHOR_POINT anchor_point() const;
  inline void set_anchor_point(::maker::ANCHOR_POINT value);

  // optional .maker.RELATIVE_SIZE_TYPE relative_size_type = 7 [default = RELATIVE_SIZE_TYPE__NONE];
  inline bool has_relative_size_type() const;
  inline void clear_relative_size_type();
  static const int kRelativeSizeTypeFieldNumber = 7;
  inline ::maker::RELATIVE_SIZE_TYPE relative_size_type() const;
  inline void set_relative_size_type(::maker::RELATIVE_SIZE_TYPE value);

  // optional int32 rel_width = 8 [default = 0];
  inline bool has_rel_width() const;
  inline void clear_rel_width();
  static const int kRelWidthFieldNumber = 8;
  inline ::google::protobuf::int32 rel_width() const;
  inline void set_rel_width(::google::protobuf::int32 value);

  // optional int32 rel_height = 9 [default = 0];
  inline bool has_rel_height() const;
  inline void clear_rel_height();
  static const int kRelHeightFieldNumber = 9;
  inline ::google::protobuf::int32 rel_height() const;
  inline void set_rel_height(::google::protobuf::int32 value);

  // optional int32 width = 10 [default = 100];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 10;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 height = 11 [default = 100];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 11;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional float scale_x = 12 [default = 1];
  inline bool has_scale_x() const;
  inline void clear_scale_x();
  static const int kScaleXFieldNumber = 12;
  inline float scale_x() const;
  inline void set_scale_x(float value);

  // optional float scale_y = 13 [default = 1];
  inline bool has_scale_y() const;
  inline void clear_scale_y();
  static const int kScaleYFieldNumber = 13;
  inline float scale_y() const;
  inline void set_scale_y(float value);

  // optional float skew_x = 14 [default = 0];
  inline bool has_skew_x() const;
  inline void clear_skew_x();
  static const int kSkewXFieldNumber = 14;
  inline float skew_x() const;
  inline void set_skew_x(float value);

  // optional float skew_y = 15 [default = 0];
  inline bool has_skew_y() const;
  inline void clear_skew_y();
  static const int kSkewYFieldNumber = 15;
  inline float skew_y() const;
  inline void set_skew_y(float value);

  // optional float rotation = 16 [default = 0];
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 16;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional bool visible = 17 [default = true];
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 17;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional .maker.NODE_ACTION_TYPE action_type = 18 [default = NODE_ACTION_TYPE__NONE];
  inline bool has_action_type() const;
  inline void clear_action_type();
  static const int kActionTypeFieldNumber = 18;
  inline ::maker::NODE_ACTION_TYPE action_type() const;
  inline void set_action_type(::maker::NODE_ACTION_TYPE value);

  // optional float action_delay_1 = 19 [default = 0];
  inline bool has_action_delay_1() const;
  inline void clear_action_delay_1();
  static const int kActionDelay1FieldNumber = 19;
  inline float action_delay_1() const;
  inline void set_action_delay_1(float value);

  // optional float action_delay_2 = 20 [default = 0];
  inline bool has_action_delay_2() const;
  inline void clear_action_delay_2();
  static const int kActionDelay2FieldNumber = 20;
  inline float action_delay_2() const;
  inline void set_action_delay_2(float value);

  // optional float action_duration = 21 [default = 0];
  inline bool has_action_duration() const;
  inline void clear_action_duration();
  static const int kActionDurationFieldNumber = 21;
  inline float action_duration() const;
  inline void set_action_duration(float value);

  // optional .maker.SCREEN_UI_TYPE screen_ui = 22 [default = SCREEN_UI_TYPE__NONE];
  inline bool has_screen_ui() const;
  inline void clear_screen_ui();
  static const int kScreenUiFieldNumber = 22;
  inline ::maker::SCREEN_UI_TYPE screen_ui() const;
  inline void set_screen_ui(::maker::SCREEN_UI_TYPE value);

  // optional string lua_name = 23 [default = ""];
  inline bool has_lua_name() const;
  inline void clear_lua_name();
  static const int kLuaNameFieldNumber = 23;
  inline const ::std::string& lua_name() const;
  inline void set_lua_name(const ::std::string& value);
  inline void set_lua_name(const char* value);
  inline void set_lua_name(const char* value, size_t size);
  inline ::std::string* mutable_lua_name();
  inline ::std::string* release_lua_name();
  inline void set_allocated_lua_name(::std::string* lua_name);

  // @@protoc_insertion_point(class_scope:maker.Node)
 private:
  inline void set_has_ui_name();
  inline void clear_has_ui_name();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_dock_point();
  inline void clear_has_dock_point();
  inline void set_has_anchor_point();
  inline void clear_has_anchor_point();
  inline void set_has_relative_size_type();
  inline void clear_has_relative_size_type();
  inline void set_has_rel_width();
  inline void clear_has_rel_width();
  inline void set_has_rel_height();
  inline void clear_has_rel_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_scale_x();
  inline void clear_has_scale_x();
  inline void set_has_scale_y();
  inline void clear_has_scale_y();
  inline void set_has_skew_x();
  inline void clear_has_skew_x();
  inline void set_has_skew_y();
  inline void clear_has_skew_y();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_action_type();
  inline void clear_has_action_type();
  inline void set_has_action_delay_1();
  inline void clear_has_action_delay_1();
  inline void set_has_action_delay_2();
  inline void clear_has_action_delay_2();
  inline void set_has_action_duration();
  inline void clear_has_action_duration();
  inline void set_has_screen_ui();
  inline void clear_has_screen_ui();
  inline void set_has_lua_name();
  inline void clear_has_lua_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ui_name_;
  ::std::string* flag_;
  float x_;
  float y_;
  int dock_point_;
  int anchor_point_;
  int relative_size_type_;
  ::google::protobuf::int32 rel_width_;
  ::google::protobuf::int32 rel_height_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  float scale_x_;
  float scale_y_;
  float skew_x_;
  float skew_y_;
  float rotation_;
  bool visible_;
  int action_type_;
  float action_delay_1_;
  float action_delay_2_;
  float action_duration_;
  int screen_ui_;
  ::std::string* lua_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class ClippingNode : public ::google::protobuf::Message {
 public:
  ClippingNode();
  virtual ~ClippingNode();

  ClippingNode(const ClippingNode& from);

  inline ClippingNode& operator=(const ClippingNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClippingNode& default_instance();

  void Swap(ClippingNode* other);

  // implements Message ----------------------------------------------

  ClippingNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClippingNode& from);
  void MergeFrom(const ClippingNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.STENCIL_TYPE stencil_type = 1 [default = SQUARE];
  inline bool has_stencil_type() const;
  inline void clear_stencil_type();
  static const int kStencilTypeFieldNumber = 1;
  inline ::maker::STENCIL_TYPE stencil_type() const;
  inline void set_stencil_type(::maker::STENCIL_TYPE value);

  // optional .maker.FILE_IMAGE stencil_img = 2;
  inline bool has_stencil_img() const;
  inline void clear_stencil_img();
  static const int kStencilImgFieldNumber = 2;
  inline const ::maker::FILE_IMAGE& stencil_img() const;
  inline ::maker::FILE_IMAGE* mutable_stencil_img();
  inline ::maker::FILE_IMAGE* release_stencil_img();
  inline void set_allocated_stencil_img(::maker::FILE_IMAGE* stencil_img);

  // optional float alpha_threshold = 3 [default = 1];
  inline bool has_alpha_threshold() const;
  inline void clear_alpha_threshold();
  static const int kAlphaThresholdFieldNumber = 3;
  inline float alpha_threshold() const;
  inline void set_alpha_threshold(float value);

  // optional bool is_invert = 4 [default = false];
  inline bool has_is_invert() const;
  inline void clear_is_invert();
  static const int kIsInvertFieldNumber = 4;
  inline bool is_invert() const;
  inline void set_is_invert(bool value);

  // @@protoc_insertion_point(class_scope:maker.ClippingNode)
 private:
  inline void set_has_stencil_type();
  inline void clear_has_stencil_type();
  inline void set_has_stencil_img();
  inline void clear_has_stencil_img();
  inline void set_has_alpha_threshold();
  inline void clear_has_alpha_threshold();
  inline void set_has_is_invert();
  inline void clear_has_is_invert();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::FILE_IMAGE* stencil_img_;
  int stencil_type_;
  float alpha_threshold_;
  bool is_invert_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static ClippingNode* default_instance_;
};
// -------------------------------------------------------------------

class LayerColor : public ::google::protobuf::Message {
 public:
  LayerColor();
  virtual ~LayerColor();

  LayerColor(const LayerColor& from);

  inline LayerColor& operator=(const LayerColor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerColor& default_instance();

  void Swap(LayerColor* other);

  // implements Message ----------------------------------------------

  LayerColor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerColor& from);
  void MergeFrom(const LayerColor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.COLOR color = 1;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 1;
  inline const ::maker::COLOR& color() const;
  inline ::maker::COLOR* mutable_color();
  inline ::maker::COLOR* release_color();
  inline void set_allocated_color(::maker::COLOR* color);

  // optional int32 opacity = 2 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 2;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional .maker.BLEND_FUNCTION src_blend = 3 [default = BLEND__GL_SRC_ALPHA];
  inline bool has_src_blend() const;
  inline void clear_src_blend();
  static const int kSrcBlendFieldNumber = 3;
  inline ::maker::BLEND_FUNCTION src_blend() const;
  inline void set_src_blend(::maker::BLEND_FUNCTION value);

  // optional .maker.BLEND_FUNCTION dest_blend = 4 [default = BLEND__GL_ONE_MINUS_SRC_ALPHA];
  inline bool has_dest_blend() const;
  inline void clear_dest_blend();
  static const int kDestBlendFieldNumber = 4;
  inline ::maker::BLEND_FUNCTION dest_blend() const;
  inline void set_dest_blend(::maker::BLEND_FUNCTION value);

  // @@protoc_insertion_point(class_scope:maker.LayerColor)
 private:
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_src_blend();
  inline void clear_has_src_blend();
  inline void set_has_dest_blend();
  inline void clear_has_dest_blend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::COLOR* color_;
  ::google::protobuf::int32 opacity_;
  int src_blend_;
  int dest_blend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static LayerColor* default_instance_;
};
// -------------------------------------------------------------------

class LayerGradient : public ::google::protobuf::Message {
 public:
  LayerGradient();
  virtual ~LayerGradient();

  LayerGradient(const LayerGradient& from);

  inline LayerGradient& operator=(const LayerGradient& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerGradient& default_instance();

  void Swap(LayerGradient* other);

  // implements Message ----------------------------------------------

  LayerGradient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerGradient& from);
  void MergeFrom(const LayerGradient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.COLOR color = 1;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 1;
  inline const ::maker::COLOR& color() const;
  inline ::maker::COLOR* mutable_color();
  inline ::maker::COLOR* release_color();
  inline void set_allocated_color(::maker::COLOR* color);

  // optional int32 opacity = 2 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 2;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional .maker.BLEND_FUNCTION src_blend = 3 [default = BLEND__GL_SRC_ALPHA];
  inline bool has_src_blend() const;
  inline void clear_src_blend();
  static const int kSrcBlendFieldNumber = 3;
  inline ::maker::BLEND_FUNCTION src_blend() const;
  inline void set_src_blend(::maker::BLEND_FUNCTION value);

  // optional .maker.BLEND_FUNCTION dest_blend = 4 [default = BLEND__GL_ONE_MINUS_SRC_ALPHA];
  inline bool has_dest_blend() const;
  inline void clear_dest_blend();
  static const int kDestBlendFieldNumber = 4;
  inline ::maker::BLEND_FUNCTION dest_blend() const;
  inline void set_dest_blend(::maker::BLEND_FUNCTION value);

  // optional .maker.COLOR start_color = 5;
  inline bool has_start_color() const;
  inline void clear_start_color();
  static const int kStartColorFieldNumber = 5;
  inline const ::maker::COLOR& start_color() const;
  inline ::maker::COLOR* mutable_start_color();
  inline ::maker::COLOR* release_start_color();
  inline void set_allocated_start_color(::maker::COLOR* start_color);

  // optional .maker.COLOR end_color = 6;
  inline bool has_end_color() const;
  inline void clear_end_color();
  static const int kEndColorFieldNumber = 6;
  inline const ::maker::COLOR& end_color() const;
  inline ::maker::COLOR* mutable_end_color();
  inline ::maker::COLOR* release_end_color();
  inline void set_allocated_end_color(::maker::COLOR* end_color);

  // optional int32 start_opacity = 7 [default = 255];
  inline bool has_start_opacity() const;
  inline void clear_start_opacity();
  static const int kStartOpacityFieldNumber = 7;
  inline ::google::protobuf::int32 start_opacity() const;
  inline void set_start_opacity(::google::protobuf::int32 value);

  // optional int32 end_opacity = 8 [default = 255];
  inline bool has_end_opacity() const;
  inline void clear_end_opacity();
  static const int kEndOpacityFieldNumber = 8;
  inline ::google::protobuf::int32 end_opacity() const;
  inline void set_end_opacity(::google::protobuf::int32 value);

  // optional float angle = 9 [default = 0];
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 9;
  inline float angle() const;
  inline void set_angle(float value);

  // @@protoc_insertion_point(class_scope:maker.LayerGradient)
 private:
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_src_blend();
  inline void clear_has_src_blend();
  inline void set_has_dest_blend();
  inline void clear_has_dest_blend();
  inline void set_has_start_color();
  inline void clear_has_start_color();
  inline void set_has_end_color();
  inline void clear_has_end_color();
  inline void set_has_start_opacity();
  inline void clear_has_start_opacity();
  inline void set_has_end_opacity();
  inline void clear_has_end_opacity();
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::COLOR* color_;
  ::google::protobuf::int32 opacity_;
  int src_blend_;
  ::maker::COLOR* start_color_;
  int dest_blend_;
  ::google::protobuf::int32 start_opacity_;
  ::maker::COLOR* end_color_;
  ::google::protobuf::int32 end_opacity_;
  float angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static LayerGradient* default_instance_;
};
// -------------------------------------------------------------------

class LabelSystemFont : public ::google::protobuf::Message {
 public:
  LabelSystemFont();
  virtual ~LabelSystemFont();

  LabelSystemFont(const LabelSystemFont& from);

  inline LabelSystemFont& operator=(const LabelSystemFont& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LabelSystemFont& default_instance();

  void Swap(LabelSystemFont* other);

  // implements Message ----------------------------------------------

  LabelSystemFont* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LabelSystemFont& from);
  void MergeFrom(const LabelSystemFont& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string font_name = 1 [default = "Helvetica"];
  inline bool has_font_name() const;
  inline void clear_font_name();
  static const int kFontNameFieldNumber = 1;
  inline const ::std::string& font_name() const;
  inline void set_font_name(const ::std::string& value);
  inline void set_font_name(const char* value);
  inline void set_font_name(const char* value, size_t size);
  inline ::std::string* mutable_font_name();
  inline ::std::string* release_font_name();
  inline void set_allocated_font_name(::std::string* font_name);

  // optional int32 font_size = 2 [default = 10];
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 2;
  inline ::google::protobuf::int32 font_size() const;
  inline void set_font_size(::google::protobuf::int32 value);

  // optional string text = 3 [default = "New Label System Font"];
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .maker.TEXT_ALIGNMENT_H h_alignment = 4 [default = TEXT_ALIGN_H__CENTER];
  inline bool has_h_alignment() const;
  inline void clear_h_alignment();
  static const int kHAlignmentFieldNumber = 4;
  inline ::maker::TEXT_ALIGNMENT_H h_alignment() const;
  inline void set_h_alignment(::maker::TEXT_ALIGNMENT_H value);

  // optional .maker.TEXT_ALIGNMENT_V v_alignment = 5 [default = TEXT_ALIGN_V__CENTER];
  inline bool has_v_alignment() const;
  inline void clear_v_alignment();
  static const int kVAlignmentFieldNumber = 5;
  inline ::maker::TEXT_ALIGNMENT_V v_alignment() const;
  inline void set_v_alignment(::maker::TEXT_ALIGNMENT_V value);

  // optional .maker.COLOR color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline const ::maker::COLOR& color() const;
  inline ::maker::COLOR* mutable_color();
  inline ::maker::COLOR* release_color();
  inline void set_allocated_color(::maker::COLOR* color);

  // optional int32 opacity = 7 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 7;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional int32 dimension_width = 8 [default = 0];
  inline bool has_dimension_width() const;
  inline void clear_dimension_width();
  static const int kDimensionWidthFieldNumber = 8;
  inline ::google::protobuf::int32 dimension_width() const;
  inline void set_dimension_width(::google::protobuf::int32 value);

  // optional int32 dimension_height = 9 [default = 0];
  inline bool has_dimension_height() const;
  inline void clear_dimension_height();
  static const int kDimensionHeightFieldNumber = 9;
  inline ::google::protobuf::int32 dimension_height() const;
  inline void set_dimension_height(::google::protobuf::int32 value);

  // optional bool has_shadow = 31 [default = false];
  inline bool has_has_shadow() const;
  inline void clear_has_shadow();
  static const int kHasShadowFieldNumber = 31;
  inline bool has_shadow() const;
  inline void set_has_shadow(bool value);

  // optional .maker.COLOR shadow_color = 32;
  inline bool has_shadow_color() const;
  inline void clear_shadow_color();
  static const int kShadowColorFieldNumber = 32;
  inline const ::maker::COLOR& shadow_color() const;
  inline ::maker::COLOR* mutable_shadow_color();
  inline ::maker::COLOR* release_shadow_color();
  inline void set_allocated_shadow_color(::maker::COLOR* shadow_color);

  // optional int32 shadow_opacity = 33 [default = 255];
  inline bool has_shadow_opacity() const;
  inline void clear_shadow_opacity();
  static const int kShadowOpacityFieldNumber = 33;
  inline ::google::protobuf::int32 shadow_opacity() const;
  inline void set_shadow_opacity(::google::protobuf::int32 value);

  // optional .maker.SHADOW_DIRECTION shadow_direction = 34 [default = SHADOW_DIR_90];
  inline bool has_shadow_direction() const;
  inline void clear_shadow_direction();
  static const int kShadowDirectionFieldNumber = 34;
  inline ::maker::SHADOW_DIRECTION shadow_direction() const;
  inline void set_shadow_direction(::maker::SHADOW_DIRECTION value);

  // optional float shadow_distance = 35 [default = 5];
  inline bool has_shadow_distance() const;
  inline void clear_shadow_distance();
  static const int kShadowDistanceFieldNumber = 35;
  inline float shadow_distance() const;
  inline void set_shadow_distance(float value);

  // @@protoc_insertion_point(class_scope:maker.LabelSystemFont)
 private:
  inline void set_has_font_name();
  inline void clear_has_font_name();
  inline void set_has_font_size();
  inline void clear_has_font_size();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_h_alignment();
  inline void clear_has_h_alignment();
  inline void set_has_v_alignment();
  inline void clear_has_v_alignment();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_dimension_width();
  inline void clear_has_dimension_width();
  inline void set_has_dimension_height();
  inline void clear_has_dimension_height();
  inline void set_has_has_shadow();
  inline void clear_has_has_shadow();
  inline void set_has_shadow_color();
  inline void clear_has_shadow_color();
  inline void set_has_shadow_opacity();
  inline void clear_has_shadow_opacity();
  inline void set_has_shadow_direction();
  inline void clear_has_shadow_direction();
  inline void set_has_shadow_distance();
  inline void clear_has_shadow_distance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* font_name_;
  static ::std::string* _default_font_name_;
  ::std::string* text_;
  static ::std::string* _default_text_;
  ::google::protobuf::int32 font_size_;
  int h_alignment_;
  ::maker::COLOR* color_;
  int v_alignment_;
  ::google::protobuf::int32 opacity_;
  ::google::protobuf::int32 dimension_width_;
  ::google::protobuf::int32 dimension_height_;
  ::maker::COLOR* shadow_color_;
  bool has_shadow_;
  ::google::protobuf::int32 shadow_opacity_;
  int shadow_direction_;
  float shadow_distance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static LabelSystemFont* default_instance_;
};
// -------------------------------------------------------------------

class LabelTTF : public ::google::protobuf::Message {
 public:
  LabelTTF();
  virtual ~LabelTTF();

  LabelTTF(const LabelTTF& from);

  inline LabelTTF& operator=(const LabelTTF& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LabelTTF& default_instance();

  void Swap(LabelTTF* other);

  // implements Message ----------------------------------------------

  LabelTTF* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LabelTTF& from);
  void MergeFrom(const LabelTTF& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.FILE_TTF font_name = 1;
  inline bool has_font_name() const;
  inline void clear_font_name();
  static const int kFontNameFieldNumber = 1;
  inline const ::maker::FILE_TTF& font_name() const;
  inline ::maker::FILE_TTF* mutable_font_name();
  inline ::maker::FILE_TTF* release_font_name();
  inline void set_allocated_font_name(::maker::FILE_TTF* font_name);

  // optional int32 font_size = 2 [default = 10];
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 2;
  inline ::google::protobuf::int32 font_size() const;
  inline void set_font_size(::google::protobuf::int32 value);

  // optional string text = 3 [default = "New Label TTF"];
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .maker.TEXT_ALIGNMENT_H h_alignment = 4 [default = TEXT_ALIGN_H__CENTER];
  inline bool has_h_alignment() const;
  inline void clear_h_alignment();
  static const int kHAlignmentFieldNumber = 4;
  inline ::maker::TEXT_ALIGNMENT_H h_alignment() const;
  inline void set_h_alignment(::maker::TEXT_ALIGNMENT_H value);

  // optional .maker.TEXT_ALIGNMENT_V v_alignment = 5 [default = TEXT_ALIGN_V__CENTER];
  inline bool has_v_alignment() const;
  inline void clear_v_alignment();
  static const int kVAlignmentFieldNumber = 5;
  inline ::maker::TEXT_ALIGNMENT_V v_alignment() const;
  inline void set_v_alignment(::maker::TEXT_ALIGNMENT_V value);

  // optional .maker.COLOR color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline const ::maker::COLOR& color() const;
  inline ::maker::COLOR* mutable_color();
  inline ::maker::COLOR* release_color();
  inline void set_allocated_color(::maker::COLOR* color);

  // optional int32 opacity = 7 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 7;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional int32 dimension_width = 8 [default = 0];
  inline bool has_dimension_width() const;
  inline void clear_dimension_width();
  static const int kDimensionWidthFieldNumber = 8;
  inline ::google::protobuf::int32 dimension_width() const;
  inline void set_dimension_width(::google::protobuf::int32 value);

  // optional int32 dimension_height = 9 [default = 0];
  inline bool has_dimension_height() const;
  inline void clear_dimension_height();
  static const int kDimensionHeightFieldNumber = 9;
  inline ::google::protobuf::int32 dimension_height() const;
  inline void set_dimension_height(::google::protobuf::int32 value);

  // optional float letter_spacing = 10 [default = 0];
  inline bool has_letter_spacing() const;
  inline void clear_letter_spacing();
  static const int kLetterSpacingFieldNumber = 10;
  inline float letter_spacing() const;
  inline void set_letter_spacing(float value);

  // optional bool has_stroke = 21 [default = false];
  inline bool has_has_stroke() const;
  inline void clear_has_stroke();
  static const int kHasStrokeFieldNumber = 21;
  inline bool has_stroke() const;
  inline void set_has_stroke(bool value);

  // optional .maker.STROKE_TYPE stroke_type = 22 [default = STROKE_TYPE__NORMAL];
  inline bool has_stroke_type() const;
  inline void clear_stroke_type();
  static const int kStrokeTypeFieldNumber = 22;
  inline ::maker::STROKE_TYPE stroke_type() const;
  inline void set_stroke_type(::maker::STROKE_TYPE value);

  // optional int32 stroke_detail_level = 23 [default = 0];
  inline bool has_stroke_detail_level() const;
  inline void clear_stroke_detail_level();
  static const int kStrokeDetailLevelFieldNumber = 23;
  inline ::google::protobuf::int32 stroke_detail_level() const;
  inline void set_stroke_detail_level(::google::protobuf::int32 value);

  // optional bool is_sharp_text = 24 [default = true];
  inline bool has_is_sharp_text() const;
  inline void clear_is_sharp_text();
  static const int kIsSharpTextFieldNumber = 24;
  inline bool is_sharp_text() const;
  inline void set_is_sharp_text(bool value);

  // optional float stroke_tickness = 25 [default = 1];
  inline bool has_stroke_tickness() const;
  inline void clear_stroke_tickness();
  static const int kStrokeTicknessFieldNumber = 25;
  inline float stroke_tickness() const;
  inline void set_stroke_tickness(float value);

  // optional .maker.COLOR stroke_color = 26;
  inline bool has_stroke_color() const;
  inline void clear_stroke_color();
  static const int kStrokeColorFieldNumber = 26;
  inline const ::maker::COLOR& stroke_color() const;
  inline ::maker::COLOR* mutable_stroke_color();
  inline ::maker::COLOR* release_stroke_color();
  inline void set_allocated_stroke_color(::maker::COLOR* stroke_color);

  // optional bool has_shadow = 31 [default = false];
  inline bool has_has_shadow() const;
  inline void clear_has_shadow();
  static const int kHasShadowFieldNumber = 31;
  inline bool has_shadow() const;
  inline void set_has_shadow(bool value);

  // optional .maker.COLOR shadow_color = 32;
  inline bool has_shadow_color() const;
  inline void clear_shadow_color();
  static const int kShadowColorFieldNumber = 32;
  inline const ::maker::COLOR& shadow_color() const;
  inline ::maker::COLOR* mutable_shadow_color();
  inline ::maker::COLOR* release_shadow_color();
  inline void set_allocated_shadow_color(::maker::COLOR* shadow_color);

  // optional int32 shadow_opacity = 33 [default = 255];
  inline bool has_shadow_opacity() const;
  inline void clear_shadow_opacity();
  static const int kShadowOpacityFieldNumber = 33;
  inline ::google::protobuf::int32 shadow_opacity() const;
  inline void set_shadow_opacity(::google::protobuf::int32 value);

  // optional .maker.SHADOW_DIRECTION shadow_direction = 34 [default = SHADOW_DIR_90];
  inline bool has_shadow_direction() const;
  inline void clear_shadow_direction();
  static const int kShadowDirectionFieldNumber = 34;
  inline ::maker::SHADOW_DIRECTION shadow_direction() const;
  inline void set_shadow_direction(::maker::SHADOW_DIRECTION value);

  // optional float shadow_distance = 35 [default = 5];
  inline bool has_shadow_distance() const;
  inline void clear_shadow_distance();
  static const int kShadowDistanceFieldNumber = 35;
  inline float shadow_distance() const;
  inline void set_shadow_distance(float value);

  // optional bool use_auto_fontsize = 41 [default = false];
  inline bool has_use_auto_fontsize() const;
  inline void clear_use_auto_fontsize();
  static const int kUseAutoFontsizeFieldNumber = 41;
  inline bool use_auto_fontsize() const;
  inline void set_use_auto_fontsize(bool value);

  // optional bool has_bold = 42 [default = false];
  inline bool has_has_bold() const;
  inline void clear_has_bold();
  static const int kHasBoldFieldNumber = 42;
  inline bool has_bold() const;
  inline void set_has_bold(bool value);

  // @@protoc_insertion_point(class_scope:maker.LabelTTF)
 private:
  inline void set_has_font_name();
  inline void clear_has_font_name();
  inline void set_has_font_size();
  inline void clear_has_font_size();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_h_alignment();
  inline void clear_has_h_alignment();
  inline void set_has_v_alignment();
  inline void clear_has_v_alignment();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_dimension_width();
  inline void clear_has_dimension_width();
  inline void set_has_dimension_height();
  inline void clear_has_dimension_height();
  inline void set_has_letter_spacing();
  inline void clear_has_letter_spacing();
  inline void set_has_has_stroke();
  inline void clear_has_has_stroke();
  inline void set_has_stroke_type();
  inline void clear_has_stroke_type();
  inline void set_has_stroke_detail_level();
  inline void clear_has_stroke_detail_level();
  inline void set_has_is_sharp_text();
  inline void clear_has_is_sharp_text();
  inline void set_has_stroke_tickness();
  inline void clear_has_stroke_tickness();
  inline void set_has_stroke_color();
  inline void clear_has_stroke_color();
  inline void set_has_has_shadow();
  inline void clear_has_has_shadow();
  inline void set_has_shadow_color();
  inline void clear_has_shadow_color();
  inline void set_has_shadow_opacity();
  inline void clear_has_shadow_opacity();
  inline void set_has_shadow_direction();
  inline void clear_has_shadow_direction();
  inline void set_has_shadow_distance();
  inline void clear_has_shadow_distance();
  inline void set_has_use_auto_fontsize();
  inline void clear_has_use_auto_fontsize();
  inline void set_has_has_bold();
  inline void clear_has_has_bold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::FILE_TTF* font_name_;
  ::std::string* text_;
  static ::std::string* _default_text_;
  ::google::protobuf::int32 font_size_;
  int h_alignment_;
  ::maker::COLOR* color_;
  int v_alignment_;
  ::google::protobuf::int32 opacity_;
  ::google::protobuf::int32 dimension_width_;
  ::google::protobuf::int32 dimension_height_;
  float letter_spacing_;
  int stroke_type_;
  ::google::protobuf::int32 stroke_detail_level_;
  float stroke_tickness_;
  ::maker::COLOR* stroke_color_;
  bool has_stroke_;
  bool is_sharp_text_;
  bool has_shadow_;
  bool use_auto_fontsize_;
  ::google::protobuf::int32 shadow_opacity_;
  ::maker::COLOR* shadow_color_;
  int shadow_direction_;
  float shadow_distance_;
  bool has_bold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static LabelTTF* default_instance_;
};
// -------------------------------------------------------------------

class LabelBMFont : public ::google::protobuf::Message {
 public:
  LabelBMFont();
  virtual ~LabelBMFont();

  LabelBMFont(const LabelBMFont& from);

  inline LabelBMFont& operator=(const LabelBMFont& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LabelBMFont& default_instance();

  void Swap(LabelBMFont* other);

  // implements Message ----------------------------------------------

  LabelBMFont* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LabelBMFont& from);
  void MergeFrom(const LabelBMFont& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.FILE_BMFONT font_name = 1;
  inline bool has_font_name() const;
  inline void clear_font_name();
  static const int kFontNameFieldNumber = 1;
  inline const ::maker::FILE_BMFONT& font_name() const;
  inline ::maker::FILE_BMFONT* mutable_font_name();
  inline ::maker::FILE_BMFONT* release_font_name();
  inline void set_allocated_font_name(::maker::FILE_BMFONT* font_name);

  // optional int32 font_size = 2 [default = 10];
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 2;
  inline ::google::protobuf::int32 font_size() const;
  inline void set_font_size(::google::protobuf::int32 value);

  // optional string text = 3 [default = "New Label BMFont"];
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .maker.TEXT_ALIGNMENT_H h_alignment = 4 [default = TEXT_ALIGN_H__CENTER];
  inline bool has_h_alignment() const;
  inline void clear_h_alignment();
  static const int kHAlignmentFieldNumber = 4;
  inline ::maker::TEXT_ALIGNMENT_H h_alignment() const;
  inline void set_h_alignment(::maker::TEXT_ALIGNMENT_H value);

  // optional .maker.TEXT_ALIGNMENT_V v_alignment = 5 [default = TEXT_ALIGN_V__CENTER];
  inline bool has_v_alignment() const;
  inline void clear_v_alignment();
  static const int kVAlignmentFieldNumber = 5;
  inline ::maker::TEXT_ALIGNMENT_V v_alignment() const;
  inline void set_v_alignment(::maker::TEXT_ALIGNMENT_V value);

  // optional .maker.COLOR color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline const ::maker::COLOR& color() const;
  inline ::maker::COLOR* mutable_color();
  inline ::maker::COLOR* release_color();
  inline void set_allocated_color(::maker::COLOR* color);

  // optional int32 opacity = 7 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 7;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional int32 dimension_width = 8 [default = 0];
  inline bool has_dimension_width() const;
  inline void clear_dimension_width();
  static const int kDimensionWidthFieldNumber = 8;
  inline ::google::protobuf::int32 dimension_width() const;
  inline void set_dimension_width(::google::protobuf::int32 value);

  // optional int32 dimension_height = 9 [default = 0];
  inline bool has_dimension_height() const;
  inline void clear_dimension_height();
  static const int kDimensionHeightFieldNumber = 9;
  inline ::google::protobuf::int32 dimension_height() const;
  inline void set_dimension_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maker.LabelBMFont)
 private:
  inline void set_has_font_name();
  inline void clear_has_font_name();
  inline void set_has_font_size();
  inline void clear_has_font_size();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_h_alignment();
  inline void clear_has_h_alignment();
  inline void set_has_v_alignment();
  inline void clear_has_v_alignment();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_dimension_width();
  inline void clear_has_dimension_width();
  inline void set_has_dimension_height();
  inline void clear_has_dimension_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::FILE_BMFONT* font_name_;
  ::std::string* text_;
  static ::std::string* _default_text_;
  ::google::protobuf::int32 font_size_;
  int h_alignment_;
  ::maker::COLOR* color_;
  int v_alignment_;
  ::google::protobuf::int32 opacity_;
  ::google::protobuf::int32 dimension_width_;
  ::google::protobuf::int32 dimension_height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static LabelBMFont* default_instance_;
};
// -------------------------------------------------------------------

class TextFieldTTF : public ::google::protobuf::Message {
 public:
  TextFieldTTF();
  virtual ~TextFieldTTF();

  TextFieldTTF(const TextFieldTTF& from);

  inline TextFieldTTF& operator=(const TextFieldTTF& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextFieldTTF& default_instance();

  void Swap(TextFieldTTF* other);

  // implements Message ----------------------------------------------

  TextFieldTTF* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextFieldTTF& from);
  void MergeFrom(const TextFieldTTF& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.FILE_TTF font_name = 1;
  inline bool has_font_name() const;
  inline void clear_font_name();
  static const int kFontNameFieldNumber = 1;
  inline const ::maker::FILE_TTF& font_name() const;
  inline ::maker::FILE_TTF* mutable_font_name();
  inline ::maker::FILE_TTF* release_font_name();
  inline void set_allocated_font_name(::maker::FILE_TTF* font_name);

  // optional int32 font_size = 2 [default = 10];
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 2;
  inline ::google::protobuf::int32 font_size() const;
  inline void set_font_size(::google::protobuf::int32 value);

  // optional string text = 3 [default = "New TextField"];
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .maker.TEXT_ALIGNMENT_H h_alignment = 4 [default = TEXT_ALIGN_H__CENTER];
  inline bool has_h_alignment() const;
  inline void clear_h_alignment();
  static const int kHAlignmentFieldNumber = 4;
  inline ::maker::TEXT_ALIGNMENT_H h_alignment() const;
  inline void set_h_alignment(::maker::TEXT_ALIGNMENT_H value);

  // optional .maker.TEXT_ALIGNMENT_V v_alignment = 5 [default = TEXT_ALIGN_V__CENTER];
  inline bool has_v_alignment() const;
  inline void clear_v_alignment();
  static const int kVAlignmentFieldNumber = 5;
  inline ::maker::TEXT_ALIGNMENT_V v_alignment() const;
  inline void set_v_alignment(::maker::TEXT_ALIGNMENT_V value);

  // optional .maker.COLOR color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline const ::maker::COLOR& color() const;
  inline ::maker::COLOR* mutable_color();
  inline ::maker::COLOR* release_color();
  inline void set_allocated_color(::maker::COLOR* color);

  // optional int32 opacity = 7 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 7;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional int32 dimension_width = 8 [default = 0];
  inline bool has_dimension_width() const;
  inline void clear_dimension_width();
  static const int kDimensionWidthFieldNumber = 8;
  inline ::google::protobuf::int32 dimension_width() const;
  inline void set_dimension_width(::google::protobuf::int32 value);

  // optional int32 dimension_height = 9 [default = 0];
  inline bool has_dimension_height() const;
  inline void clear_dimension_height();
  static const int kDimensionHeightFieldNumber = 9;
  inline ::google::protobuf::int32 dimension_height() const;
  inline void set_dimension_height(::google::protobuf::int32 value);

  // optional bool has_stroke = 10 [default = false];
  inline bool has_has_stroke() const;
  inline void clear_has_stroke();
  static const int kHasStrokeFieldNumber = 10;
  inline bool has_stroke() const;
  inline void set_has_stroke(bool value);

  // optional float stroke_tickness = 11 [default = 1];
  inline bool has_stroke_tickness() const;
  inline void clear_stroke_tickness();
  static const int kStrokeTicknessFieldNumber = 11;
  inline float stroke_tickness() const;
  inline void set_stroke_tickness(float value);

  // optional .maker.COLOR stroke_color = 12;
  inline bool has_stroke_color() const;
  inline void clear_stroke_color();
  static const int kStrokeColorFieldNumber = 12;
  inline const ::maker::COLOR& stroke_color() const;
  inline ::maker::COLOR* mutable_stroke_color();
  inline ::maker::COLOR* release_stroke_color();
  inline void set_allocated_stroke_color(::maker::COLOR* stroke_color);

  // @@protoc_insertion_point(class_scope:maker.TextFieldTTF)
 private:
  inline void set_has_font_name();
  inline void clear_has_font_name();
  inline void set_has_font_size();
  inline void clear_has_font_size();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_h_alignment();
  inline void clear_has_h_alignment();
  inline void set_has_v_alignment();
  inline void clear_has_v_alignment();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_dimension_width();
  inline void clear_has_dimension_width();
  inline void set_has_dimension_height();
  inline void clear_has_dimension_height();
  inline void set_has_has_stroke();
  inline void clear_has_has_stroke();
  inline void set_has_stroke_tickness();
  inline void clear_has_stroke_tickness();
  inline void set_has_stroke_color();
  inline void clear_has_stroke_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::FILE_TTF* font_name_;
  ::std::string* text_;
  static ::std::string* _default_text_;
  ::google::protobuf::int32 font_size_;
  int h_alignment_;
  ::maker::COLOR* color_;
  int v_alignment_;
  ::google::protobuf::int32 opacity_;
  ::google::protobuf::int32 dimension_width_;
  ::google::protobuf::int32 dimension_height_;
  bool has_stroke_;
  float stroke_tickness_;
  ::maker::COLOR* stroke_color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static TextFieldTTF* default_instance_;
};
// -------------------------------------------------------------------

class EditBox : public ::google::protobuf::Message {
 public:
  EditBox();
  virtual ~EditBox();

  EditBox(const EditBox& from);

  inline EditBox& operator=(const EditBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EditBox& default_instance();

  void Swap(EditBox* other);

  // implements Message ----------------------------------------------

  EditBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EditBox& from);
  void MergeFrom(const EditBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1 [default = false];
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional .maker.EDITBOX_INPUT_MODE input_mode = 2 [default = EDITBOX_INPUT_MODE__SINGLE_LINE];
  inline bool has_input_mode() const;
  inline void clear_input_mode();
  static const int kInputModeFieldNumber = 2;
  inline ::maker::EDITBOX_INPUT_MODE input_mode() const;
  inline void set_input_mode(::maker::EDITBOX_INPUT_MODE value);

  // optional .maker.EDITBOX_INPUT_FLAG input_flag = 3 [default = EDITBOX_INPUT_FLAG__INTIAL_CAPS_ALL_CHARACTERS];
  inline bool has_input_flag() const;
  inline void clear_input_flag();
  static const int kInputFlagFieldNumber = 3;
  inline ::maker::EDITBOX_INPUT_FLAG input_flag() const;
  inline void set_input_flag(::maker::EDITBOX_INPUT_FLAG value);

  // optional .maker.EDITBOX_RETURN_TYPE return_type = 4 [default = EDITBOX_RETURN_TYPE__DONE];
  inline bool has_return_type() const;
  inline void clear_return_type();
  static const int kReturnTypeFieldNumber = 4;
  inline ::maker::EDITBOX_RETURN_TYPE return_type() const;
  inline void set_return_type(::maker::EDITBOX_RETURN_TYPE value);

  // optional int32 max_length = 5 [default = 0];
  inline bool has_max_length() const;
  inline void clear_max_length();
  static const int kMaxLengthFieldNumber = 5;
  inline ::google::protobuf::int32 max_length() const;
  inline void set_max_length(::google::protobuf::int32 value);

  // optional string text = 6 [default = ""];
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 6;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string font_name = 7 [default = "Helvetica"];
  inline bool has_font_name() const;
  inline void clear_font_name();
  static const int kFontNameFieldNumber = 7;
  inline const ::std::string& font_name() const;
  inline void set_font_name(const ::std::string& value);
  inline void set_font_name(const char* value);
  inline void set_font_name(const char* value, size_t size);
  inline ::std::string* mutable_font_name();
  inline ::std::string* release_font_name();
  inline void set_allocated_font_name(::std::string* font_name);

  // optional int32 font_size = 8 [default = 20];
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 8;
  inline ::google::protobuf::int32 font_size() const;
  inline void set_font_size(::google::protobuf::int32 value);

  // optional .maker.COLOR font_color = 9;
  inline bool has_font_color() const;
  inline void clear_font_color();
  static const int kFontColorFieldNumber = 9;
  inline const ::maker::COLOR& font_color() const;
  inline ::maker::COLOR* mutable_font_color();
  inline ::maker::COLOR* release_font_color();
  inline void set_allocated_font_color(::maker::COLOR* font_color);

  // optional string placeholder = 10 [default = "\355\205\215\354\212\244\355\212\270\353\245\274 \354\236\205\353\240\245\355\225\230\354\204\270\354\232\224."];
  inline bool has_placeholder() const;
  inline void clear_placeholder();
  static const int kPlaceholderFieldNumber = 10;
  inline const ::std::string& placeholder() const;
  inline void set_placeholder(const ::std::string& value);
  inline void set_placeholder(const char* value);
  inline void set_placeholder(const char* value, size_t size);
  inline ::std::string* mutable_placeholder();
  inline ::std::string* release_placeholder();
  inline void set_allocated_placeholder(::std::string* placeholder);

  // optional string placeholder_font_name = 11 [default = "Helvetica"];
  inline bool has_placeholder_font_name() const;
  inline void clear_placeholder_font_name();
  static const int kPlaceholderFontNameFieldNumber = 11;
  inline const ::std::string& placeholder_font_name() const;
  inline void set_placeholder_font_name(const ::std::string& value);
  inline void set_placeholder_font_name(const char* value);
  inline void set_placeholder_font_name(const char* value, size_t size);
  inline ::std::string* mutable_placeholder_font_name();
  inline ::std::string* release_placeholder_font_name();
  inline void set_allocated_placeholder_font_name(::std::string* placeholder_font_name);

  // optional int32 placeholder_font_size = 12 [default = 20];
  inline bool has_placeholder_font_size() const;
  inline void clear_placeholder_font_size();
  static const int kPlaceholderFontSizeFieldNumber = 12;
  inline ::google::protobuf::int32 placeholder_font_size() const;
  inline void set_placeholder_font_size(::google::protobuf::int32 value);

  // optional .maker.COLOR placeholder_font_color = 13;
  inline bool has_placeholder_font_color() const;
  inline void clear_placeholder_font_color();
  static const int kPlaceholderFontColorFieldNumber = 13;
  inline const ::maker::COLOR& placeholder_font_color() const;
  inline ::maker::COLOR* mutable_placeholder_font_color();
  inline ::maker::COLOR* release_placeholder_font_color();
  inline void set_allocated_placeholder_font_color(::maker::COLOR* placeholder_font_color);

  // optional .maker.FILE_IMAGE normal_bg = 14;
  inline bool has_normal_bg() const;
  inline void clear_normal_bg();
  static const int kNormalBgFieldNumber = 14;
  inline const ::maker::FILE_IMAGE& normal_bg() const;
  inline ::maker::FILE_IMAGE* mutable_normal_bg();
  inline ::maker::FILE_IMAGE* release_normal_bg();
  inline void set_allocated_normal_bg(::maker::FILE_IMAGE* normal_bg);

  // optional .maker.FILE_IMAGE pressed_bg = 15;
  inline bool has_pressed_bg() const;
  inline void clear_pressed_bg();
  static const int kPressedBgFieldNumber = 15;
  inline const ::maker::FILE_IMAGE& pressed_bg() const;
  inline ::maker::FILE_IMAGE* mutable_pressed_bg();
  inline ::maker::FILE_IMAGE* release_pressed_bg();
  inline void set_allocated_pressed_bg(::maker::FILE_IMAGE* pressed_bg);

  // optional .maker.FILE_IMAGE disabled_bg = 16;
  inline bool has_disabled_bg() const;
  inline void clear_disabled_bg();
  static const int kDisabledBgFieldNumber = 16;
  inline const ::maker::FILE_IMAGE& disabled_bg() const;
  inline ::maker::FILE_IMAGE* mutable_disabled_bg();
  inline ::maker::FILE_IMAGE* release_disabled_bg();
  inline void set_allocated_disabled_bg(::maker::FILE_IMAGE* disabled_bg);

  // @@protoc_insertion_point(class_scope:maker.EditBox)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_input_mode();
  inline void clear_has_input_mode();
  inline void set_has_input_flag();
  inline void clear_has_input_flag();
  inline void set_has_return_type();
  inline void clear_has_return_type();
  inline void set_has_max_length();
  inline void clear_has_max_length();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_font_name();
  inline void clear_has_font_name();
  inline void set_has_font_size();
  inline void clear_has_font_size();
  inline void set_has_font_color();
  inline void clear_has_font_color();
  inline void set_has_placeholder();
  inline void clear_has_placeholder();
  inline void set_has_placeholder_font_name();
  inline void clear_has_placeholder_font_name();
  inline void set_has_placeholder_font_size();
  inline void clear_has_placeholder_font_size();
  inline void set_has_placeholder_font_color();
  inline void clear_has_placeholder_font_color();
  inline void set_has_normal_bg();
  inline void clear_has_normal_bg();
  inline void set_has_pressed_bg();
  inline void clear_has_pressed_bg();
  inline void set_has_disabled_bg();
  inline void clear_has_disabled_bg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enable_;
  int input_mode_;
  int input_flag_;
  int return_type_;
  ::std::string* text_;
  ::google::protobuf::int32 max_length_;
  ::google::protobuf::int32 font_size_;
  ::std::string* font_name_;
  static ::std::string* _default_font_name_;
  ::maker::COLOR* font_color_;
  ::std::string* placeholder_;
  static ::std::string* _default_placeholder_;
  ::std::string* placeholder_font_name_;
  static ::std::string* _default_placeholder_font_name_;
  ::maker::COLOR* placeholder_font_color_;
  ::maker::FILE_IMAGE* normal_bg_;
  ::maker::FILE_IMAGE* pressed_bg_;
  ::maker::FILE_IMAGE* disabled_bg_;
  ::google::protobuf::int32 placeholder_font_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static EditBox* default_instance_;
};
// -------------------------------------------------------------------

class Button : public ::google::protobuf::Message {
 public:
  Button();
  virtual ~Button();

  Button(const Button& from);

  inline Button& operator=(const Button& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Button& default_instance();

  void Swap(Button* other);

  // implements Message ----------------------------------------------

  Button* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Button& from);
  void MergeFrom(const Button& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1 [default = true];
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional .maker.FILE_IMAGE normal = 2;
  inline bool has_normal() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 2;
  inline const ::maker::FILE_IMAGE& normal() const;
  inline ::maker::FILE_IMAGE* mutable_normal();
  inline ::maker::FILE_IMAGE* release_normal();
  inline void set_allocated_normal(::maker::FILE_IMAGE* normal);

  // optional .maker.FILE_IMAGE selected = 3;
  inline bool has_selected() const;
  inline void clear_selected();
  static const int kSelectedFieldNumber = 3;
  inline const ::maker::FILE_IMAGE& selected() const;
  inline ::maker::FILE_IMAGE* mutable_selected();
  inline ::maker::FILE_IMAGE* release_selected();
  inline void set_allocated_selected(::maker::FILE_IMAGE* selected);

  // optional .maker.FILE_IMAGE disable = 4;
  inline bool has_disable() const;
  inline void clear_disable();
  static const int kDisableFieldNumber = 4;
  inline const ::maker::FILE_IMAGE& disable() const;
  inline ::maker::FILE_IMAGE* mutable_disable();
  inline ::maker::FILE_IMAGE* release_disable();
  inline void set_allocated_disable(::maker::FILE_IMAGE* disable);

  // optional .maker.BUTTON_IMAGE_TYPE image_type = 5 [default = BUTTON_IMAGE_TYPE__SPRITE];
  inline bool has_image_type() const;
  inline void clear_image_type();
  static const int kImageTypeFieldNumber = 5;
  inline ::maker::BUTTON_IMAGE_TYPE image_type() const;
  inline void set_image_type(::maker::BUTTON_IMAGE_TYPE value);

  // @@protoc_insertion_point(class_scope:maker.Button)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_normal();
  inline void clear_has_normal();
  inline void set_has_selected();
  inline void clear_has_selected();
  inline void set_has_disable();
  inline void clear_has_disable();
  inline void set_has_image_type();
  inline void clear_has_image_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::FILE_IMAGE* normal_;
  ::maker::FILE_IMAGE* selected_;
  bool enable_;
  int image_type_;
  ::maker::FILE_IMAGE* disable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static Button* default_instance_;
};
// -------------------------------------------------------------------

class Sprite : public ::google::protobuf::Message {
 public:
  Sprite();
  virtual ~Sprite();

  Sprite(const Sprite& from);

  inline Sprite& operator=(const Sprite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sprite& default_instance();

  void Swap(Sprite* other);

  // implements Message ----------------------------------------------

  Sprite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sprite& from);
  void MergeFrom(const Sprite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.FILE_IMAGE file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::maker::FILE_IMAGE& file_name() const;
  inline ::maker::FILE_IMAGE* mutable_file_name();
  inline ::maker::FILE_IMAGE* release_file_name();
  inline void set_allocated_file_name(::maker::FILE_IMAGE* file_name);

  // optional .maker.COLOR color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline const ::maker::COLOR& color() const;
  inline ::maker::COLOR* mutable_color();
  inline ::maker::COLOR* release_color();
  inline void set_allocated_color(::maker::COLOR* color);

  // optional int32 opacity = 3 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 3;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional bool flip_x = 4 [default = false];
  inline bool has_flip_x() const;
  inline void clear_flip_x();
  static const int kFlipXFieldNumber = 4;
  inline bool flip_x() const;
  inline void set_flip_x(bool value);

  // optional bool flip_y = 5 [default = false];
  inline bool has_flip_y() const;
  inline void clear_flip_y();
  static const int kFlipYFieldNumber = 5;
  inline bool flip_y() const;
  inline void set_flip_y(bool value);

  // optional .maker.BLEND_FUNCTION src_blend = 6 [default = BLEND__GL_SRC_ALPHA];
  inline bool has_src_blend() const;
  inline void clear_src_blend();
  static const int kSrcBlendFieldNumber = 6;
  inline ::maker::BLEND_FUNCTION src_blend() const;
  inline void set_src_blend(::maker::BLEND_FUNCTION value);

  // optional .maker.BLEND_FUNCTION dest_blend = 7 [default = BLEND__GL_ONE_MINUS_SRC_ALPHA];
  inline bool has_dest_blend() const;
  inline void clear_dest_blend();
  static const int kDestBlendFieldNumber = 7;
  inline ::maker::BLEND_FUNCTION dest_blend() const;
  inline void set_dest_blend(::maker::BLEND_FUNCTION value);

  // @@protoc_insertion_point(class_scope:maker.Sprite)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_flip_x();
  inline void clear_has_flip_x();
  inline void set_has_flip_y();
  inline void clear_has_flip_y();
  inline void set_has_src_blend();
  inline void clear_has_src_blend();
  inline void set_has_dest_blend();
  inline void clear_has_dest_blend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::FILE_IMAGE* file_name_;
  ::maker::COLOR* color_;
  ::google::protobuf::int32 opacity_;
  bool flip_x_;
  bool flip_y_;
  int src_blend_;
  int dest_blend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static Sprite* default_instance_;
};
// -------------------------------------------------------------------

class Scale9Sprite : public ::google::protobuf::Message {
 public:
  Scale9Sprite();
  virtual ~Scale9Sprite();

  Scale9Sprite(const Scale9Sprite& from);

  inline Scale9Sprite& operator=(const Scale9Sprite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scale9Sprite& default_instance();

  void Swap(Scale9Sprite* other);

  // implements Message ----------------------------------------------

  Scale9Sprite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scale9Sprite& from);
  void MergeFrom(const Scale9Sprite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.FILE_IMAGE file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::maker::FILE_IMAGE& file_name() const;
  inline ::maker::FILE_IMAGE* mutable_file_name();
  inline ::maker::FILE_IMAGE* release_file_name();
  inline void set_allocated_file_name(::maker::FILE_IMAGE* file_name);

  // optional .maker.COLOR color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline const ::maker::COLOR& color() const;
  inline ::maker::COLOR* mutable_color();
  inline ::maker::COLOR* release_color();
  inline void set_allocated_color(::maker::COLOR* color);

  // optional int32 opacity = 3 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 3;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional int32 center_rect_x = 4 [default = 0];
  inline bool has_center_rect_x() const;
  inline void clear_center_rect_x();
  static const int kCenterRectXFieldNumber = 4;
  inline ::google::protobuf::int32 center_rect_x() const;
  inline void set_center_rect_x(::google::protobuf::int32 value);

  // optional int32 center_rect_y = 5 [default = 0];
  inline bool has_center_rect_y() const;
  inline void clear_center_rect_y();
  static const int kCenterRectYFieldNumber = 5;
  inline ::google::protobuf::int32 center_rect_y() const;
  inline void set_center_rect_y(::google::protobuf::int32 value);

  // optional int32 center_rect_width = 6 [default = 0];
  inline bool has_center_rect_width() const;
  inline void clear_center_rect_width();
  static const int kCenterRectWidthFieldNumber = 6;
  inline ::google::protobuf::int32 center_rect_width() const;
  inline void set_center_rect_width(::google::protobuf::int32 value);

  // optional int32 center_rect_height = 7 [default = 0];
  inline bool has_center_rect_height() const;
  inline void clear_center_rect_height();
  static const int kCenterRectHeightFieldNumber = 7;
  inline ::google::protobuf::int32 center_rect_height() const;
  inline void set_center_rect_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maker.Scale9Sprite)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_center_rect_x();
  inline void clear_has_center_rect_x();
  inline void set_has_center_rect_y();
  inline void clear_has_center_rect_y();
  inline void set_has_center_rect_width();
  inline void clear_has_center_rect_width();
  inline void set_has_center_rect_height();
  inline void clear_has_center_rect_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::FILE_IMAGE* file_name_;
  ::maker::COLOR* color_;
  ::google::protobuf::int32 opacity_;
  ::google::protobuf::int32 center_rect_x_;
  ::google::protobuf::int32 center_rect_y_;
  ::google::protobuf::int32 center_rect_width_;
  ::google::protobuf::int32 center_rect_height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static Scale9Sprite* default_instance_;
};
// -------------------------------------------------------------------

class TableView : public ::google::protobuf::Message {
 public:
  TableView();
  virtual ~TableView();

  TableView(const TableView& from);

  inline TableView& operator=(const TableView& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableView& default_instance();

  void Swap(TableView* other);

  // implements Message ----------------------------------------------

  TableView* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableView& from);
  void MergeFrom(const TableView& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.SCROLL_TYPE scroll = 1 [default = SCROLL__BOTH];
  inline bool has_scroll() const;
  inline void clear_scroll();
  static const int kScrollFieldNumber = 1;
  inline ::maker::SCROLL_TYPE scroll() const;
  inline void set_scroll(::maker::SCROLL_TYPE value);

  // optional bool bounce = 2 [default = true];
  inline bool has_bounce() const;
  inline void clear_bounce();
  static const int kBounceFieldNumber = 2;
  inline bool bounce() const;
  inline void set_bounce(bool value);

  // optional int32 view_width = 3 [default = 200];
  inline bool has_view_width() const;
  inline void clear_view_width();
  static const int kViewWidthFieldNumber = 3;
  inline ::google::protobuf::int32 view_width() const;
  inline void set_view_width(::google::protobuf::int32 value);

  // optional int32 view_height = 4 [default = 200];
  inline bool has_view_height() const;
  inline void clear_view_height();
  static const int kViewHeightFieldNumber = 4;
  inline ::google::protobuf::int32 view_height() const;
  inline void set_view_height(::google::protobuf::int32 value);

  // optional int32 cell_width = 5 [default = 60];
  inline bool has_cell_width() const;
  inline void clear_cell_width();
  static const int kCellWidthFieldNumber = 5;
  inline ::google::protobuf::int32 cell_width() const;
  inline void set_cell_width(::google::protobuf::int32 value);

  // optional int32 cell_height = 6 [default = 60];
  inline bool has_cell_height() const;
  inline void clear_cell_height();
  static const int kCellHeightFieldNumber = 6;
  inline ::google::protobuf::int32 cell_height() const;
  inline void set_cell_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maker.TableView)
 private:
  inline void set_has_scroll();
  inline void clear_has_scroll();
  inline void set_has_bounce();
  inline void clear_has_bounce();
  inline void set_has_view_width();
  inline void clear_has_view_width();
  inline void set_has_view_height();
  inline void clear_has_view_height();
  inline void set_has_cell_width();
  inline void clear_has_cell_width();
  inline void set_has_cell_height();
  inline void clear_has_cell_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int scroll_;
  bool bounce_;
  ::google::protobuf::int32 view_width_;
  ::google::protobuf::int32 view_height_;
  ::google::protobuf::int32 cell_width_;
  ::google::protobuf::int32 cell_height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static TableView* default_instance_;
};
// -------------------------------------------------------------------

class ProgressTimer : public ::google::protobuf::Message {
 public:
  ProgressTimer();
  virtual ~ProgressTimer();

  ProgressTimer(const ProgressTimer& from);

  inline ProgressTimer& operator=(const ProgressTimer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProgressTimer& default_instance();

  void Swap(ProgressTimer* other);

  // implements Message ----------------------------------------------

  ProgressTimer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProgressTimer& from);
  void MergeFrom(const ProgressTimer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.FILE_IMAGE file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::maker::FILE_IMAGE& file_name() const;
  inline ::maker::FILE_IMAGE* mutable_file_name();
  inline ::maker::FILE_IMAGE* release_file_name();
  inline void set_allocated_file_name(::maker::FILE_IMAGE* file_name);

  // optional .maker.COLOR color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline const ::maker::COLOR& color() const;
  inline ::maker::COLOR* mutable_color();
  inline ::maker::COLOR* release_color();
  inline void set_allocated_color(::maker::COLOR* color);

  // optional int32 opacity = 3 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 3;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional bool flip_x = 4 [default = false];
  inline bool has_flip_x() const;
  inline void clear_flip_x();
  static const int kFlipXFieldNumber = 4;
  inline bool flip_x() const;
  inline void set_flip_x(bool value);

  // optional bool flip_y = 5 [default = false];
  inline bool has_flip_y() const;
  inline void clear_flip_y();
  static const int kFlipYFieldNumber = 5;
  inline bool flip_y() const;
  inline void set_flip_y(bool value);

  // optional .maker.BLEND_FUNCTION src_blend = 6 [default = BLEND__GL_SRC_ALPHA];
  inline bool has_src_blend() const;
  inline void clear_src_blend();
  static const int kSrcBlendFieldNumber = 6;
  inline ::maker::BLEND_FUNCTION src_blend() const;
  inline void set_src_blend(::maker::BLEND_FUNCTION value);

  // optional .maker.BLEND_FUNCTION dest_blend = 7 [default = BLEND__GL_ONE_MINUS_SRC_ALPHA];
  inline bool has_dest_blend() const;
  inline void clear_dest_blend();
  static const int kDestBlendFieldNumber = 7;
  inline ::maker::BLEND_FUNCTION dest_blend() const;
  inline void set_dest_blend(::maker::BLEND_FUNCTION value);

  // optional .maker.PROGRESS_TYPE progress_type = 8 [default = PROGRESS__RADIAL_CW];
  inline bool has_progress_type() const;
  inline void clear_progress_type();
  static const int kProgressTypeFieldNumber = 8;
  inline ::maker::PROGRESS_TYPE progress_type() const;
  inline void set_progress_type(::maker::PROGRESS_TYPE value);

  // optional float mid_point_x = 9 [default = 0.5];
  inline bool has_mid_point_x() const;
  inline void clear_mid_point_x();
  static const int kMidPointXFieldNumber = 9;
  inline float mid_point_x() const;
  inline void set_mid_point_x(float value);

  // optional float mid_point_y = 10 [default = 0.5];
  inline bool has_mid_point_y() const;
  inline void clear_mid_point_y();
  static const int kMidPointYFieldNumber = 10;
  inline float mid_point_y() const;
  inline void set_mid_point_y(float value);

  // optional int32 percentage = 11 [default = 75];
  inline bool has_percentage() const;
  inline void clear_percentage();
  static const int kPercentageFieldNumber = 11;
  inline ::google::protobuf::int32 percentage() const;
  inline void set_percentage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maker.ProgressTimer)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_flip_x();
  inline void clear_has_flip_x();
  inline void set_has_flip_y();
  inline void clear_has_flip_y();
  inline void set_has_src_blend();
  inline void clear_has_src_blend();
  inline void set_has_dest_blend();
  inline void clear_has_dest_blend();
  inline void set_has_progress_type();
  inline void clear_has_progress_type();
  inline void set_has_mid_point_x();
  inline void clear_has_mid_point_x();
  inline void set_has_mid_point_y();
  inline void clear_has_mid_point_y();
  inline void set_has_percentage();
  inline void clear_has_percentage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::FILE_IMAGE* file_name_;
  ::maker::COLOR* color_;
  ::google::protobuf::int32 opacity_;
  bool flip_x_;
  bool flip_y_;
  int src_blend_;
  int dest_blend_;
  int progress_type_;
  float mid_point_x_;
  float mid_point_y_;
  ::google::protobuf::int32 percentage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static ProgressTimer* default_instance_;
};
// -------------------------------------------------------------------

class Visual : public ::google::protobuf::Message {
 public:
  Visual();
  virtual ~Visual();

  Visual(const Visual& from);

  inline Visual& operator=(const Visual& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Visual& default_instance();

  void Swap(Visual* other);

  // implements Message ----------------------------------------------

  Visual* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Visual& from);
  void MergeFrom(const Visual& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.FILE_VISUAL file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::maker::FILE_VISUAL& file_name() const;
  inline ::maker::FILE_VISUAL* mutable_file_name();
  inline ::maker::FILE_VISUAL* release_file_name();
  inline void set_allocated_file_name(::maker::FILE_VISUAL* file_name);

  // optional bool auto_play = 2 [default = true];
  inline bool has_auto_play() const;
  inline void clear_auto_play();
  static const int kAutoPlayFieldNumber = 2;
  inline bool auto_play() const;
  inline void set_auto_play(bool value);

  // optional bool is_repeat = 3 [default = true];
  inline bool has_is_repeat() const;
  inline void clear_is_repeat();
  static const int kIsRepeatFieldNumber = 3;
  inline bool is_repeat() const;
  inline void set_is_repeat(bool value);

  // optional .maker.NAME_VISUAL visual_id = 4;
  inline bool has_visual_id() const;
  inline void clear_visual_id();
  static const int kVisualIdFieldNumber = 4;
  inline const ::maker::NAME_VISUAL& visual_id() const;
  inline ::maker::NAME_VISUAL* mutable_visual_id();
  inline ::maker::NAME_VISUAL* release_visual_id();
  inline void set_allocated_visual_id(::maker::NAME_VISUAL* visual_id);

  // optional .maker.COLOR color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline const ::maker::COLOR& color() const;
  inline ::maker::COLOR* mutable_color();
  inline ::maker::COLOR* release_color();
  inline void set_allocated_color(::maker::COLOR* color);

  // optional int32 opacity = 7 [default = 255];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 7;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maker.Visual)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_auto_play();
  inline void clear_has_auto_play();
  inline void set_has_is_repeat();
  inline void clear_has_is_repeat();
  inline void set_has_visual_id();
  inline void clear_has_visual_id();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_opacity();
  inline void clear_has_opacity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::FILE_VISUAL* file_name_;
  bool auto_play_;
  bool is_repeat_;
  ::google::protobuf::int32 opacity_;
  ::maker::NAME_VISUAL* visual_id_;
  ::maker::COLOR* color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static Visual* default_instance_;
};
// -------------------------------------------------------------------

class SocketNode : public ::google::protobuf::Message {
 public:
  SocketNode();
  virtual ~SocketNode();

  SocketNode(const SocketNode& from);

  inline SocketNode& operator=(const SocketNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SocketNode& default_instance();

  void Swap(SocketNode* other);

  // implements Message ----------------------------------------------

  SocketNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SocketNode& from);
  void MergeFrom(const SocketNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string socket_name = 1;
  inline bool has_socket_name() const;
  inline void clear_socket_name();
  static const int kSocketNameFieldNumber = 1;
  inline const ::std::string& socket_name() const;
  inline void set_socket_name(const ::std::string& value);
  inline void set_socket_name(const char* value);
  inline void set_socket_name(const char* value, size_t size);
  inline ::std::string* mutable_socket_name();
  inline ::std::string* release_socket_name();
  inline void set_allocated_socket_name(::std::string* socket_name);

  // @@protoc_insertion_point(class_scope:maker.SocketNode)
 private:
  inline void set_has_socket_name();
  inline void clear_has_socket_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* socket_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static SocketNode* default_instance_;
};
// -------------------------------------------------------------------

class Particle : public ::google::protobuf::Message {
 public:
  Particle();
  virtual ~Particle();

  Particle(const Particle& from);

  inline Particle& operator=(const Particle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Particle& default_instance();

  void Swap(Particle* other);

  // implements Message ----------------------------------------------

  Particle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Particle& from);
  void MergeFrom(const Particle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .maker.FILE_PLIST file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::maker::FILE_PLIST& file_name() const;
  inline ::maker::FILE_PLIST* mutable_file_name();
  inline ::maker::FILE_PLIST* release_file_name();
  inline void set_allocated_file_name(::maker::FILE_PLIST* file_name);

  // @@protoc_insertion_point(class_scope:maker.Particle)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::FILE_PLIST* file_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static Particle* default_instance_;
};
// -------------------------------------------------------------------

class RotatePlate : public ::google::protobuf::Message {
 public:
  RotatePlate();
  virtual ~RotatePlate();

  RotatePlate(const RotatePlate& from);

  inline RotatePlate& operator=(const RotatePlate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotatePlate& default_instance();

  void Swap(RotatePlate* other);

  // implements Message ----------------------------------------------

  RotatePlate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotatePlate& from);
  void MergeFrom(const RotatePlate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float radius_x = 1 [default = 100];
  inline bool has_radius_x() const;
  inline void clear_radius_x();
  static const int kRadiusXFieldNumber = 1;
  inline float radius_x() const;
  inline void set_radius_x(float value);

  // optional float radius_y = 2 [default = 50];
  inline bool has_radius_y() const;
  inline void clear_radius_y();
  static const int kRadiusYFieldNumber = 2;
  inline float radius_y() const;
  inline void set_radius_y(float value);

  // optional float min_scale = 3 [default = 0.5];
  inline bool has_min_scale() const;
  inline void clear_min_scale();
  static const int kMinScaleFieldNumber = 3;
  inline float min_scale() const;
  inline void set_min_scale(float value);

  // optional float max_scale = 4 [default = 1];
  inline bool has_max_scale() const;
  inline void clear_max_scale();
  static const int kMaxScaleFieldNumber = 4;
  inline float max_scale() const;
  inline void set_max_scale(float value);

  // optional .maker.ROTATE_PLATE_ORIGIN_DIR origin_dir = 5 [default = ROTATE_PLATE_ORIGIN_DIR__DOWN];
  inline bool has_origin_dir() const;
  inline void clear_origin_dir();
  static const int kOriginDirFieldNumber = 5;
  inline ::maker::ROTATE_PLATE_ORIGIN_DIR origin_dir() const;
  inline void set_origin_dir(::maker::ROTATE_PLATE_ORIGIN_DIR value);

  // @@protoc_insertion_point(class_scope:maker.RotatePlate)
 private:
  inline void set_has_radius_x();
  inline void clear_has_radius_x();
  inline void set_has_radius_y();
  inline void clear_has_radius_y();
  inline void set_has_min_scale();
  inline void clear_has_min_scale();
  inline void set_has_max_scale();
  inline void clear_has_max_scale();
  inline void set_has_origin_dir();
  inline void clear_has_origin_dir();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float radius_x_;
  float radius_y_;
  float min_scale_;
  float max_scale_;
  int origin_dir_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static RotatePlate* default_instance_;
};
// -------------------------------------------------------------------

class Properties : public ::google::protobuf::Message {
 public:
  Properties();
  virtual ~Properties();

  Properties(const Properties& from);

  inline Properties& operator=(const Properties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Properties& default_instance();

  void Swap(Properties* other);

  // implements Message ----------------------------------------------

  Properties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Properties& from);
  void MergeFrom(const Properties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .maker.ENTITY_TYPE type = 1 [default = ENTITY__Node];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::maker::ENTITY_TYPE type() const;
  inline void set_type(::maker::ENTITY_TYPE value);

  // optional .maker.Node node = 10;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 10;
  inline const ::maker::Node& node() const;
  inline ::maker::Node* mutable_node();
  inline ::maker::Node* release_node();
  inline void set_allocated_node(::maker::Node* node);

  // optional .maker.LayerColor layer_color = 11;
  inline bool has_layer_color() const;
  inline void clear_layer_color();
  static const int kLayerColorFieldNumber = 11;
  inline const ::maker::LayerColor& layer_color() const;
  inline ::maker::LayerColor* mutable_layer_color();
  inline ::maker::LayerColor* release_layer_color();
  inline void set_allocated_layer_color(::maker::LayerColor* layer_color);

  // optional .maker.LayerGradient layer_gradient = 12;
  inline bool has_layer_gradient() const;
  inline void clear_layer_gradient();
  static const int kLayerGradientFieldNumber = 12;
  inline const ::maker::LayerGradient& layer_gradient() const;
  inline ::maker::LayerGradient* mutable_layer_gradient();
  inline ::maker::LayerGradient* release_layer_gradient();
  inline void set_allocated_layer_gradient(::maker::LayerGradient* layer_gradient);

  // optional .maker.LabelSystemFont label_syatem_font = 13;
  inline bool has_label_syatem_font() const;
  inline void clear_label_syatem_font();
  static const int kLabelSyatemFontFieldNumber = 13;
  inline const ::maker::LabelSystemFont& label_syatem_font() const;
  inline ::maker::LabelSystemFont* mutable_label_syatem_font();
  inline ::maker::LabelSystemFont* release_label_syatem_font();
  inline void set_allocated_label_syatem_font(::maker::LabelSystemFont* label_syatem_font);

  // optional .maker.LabelTTF label_ttf = 14;
  inline bool has_label_ttf() const;
  inline void clear_label_ttf();
  static const int kLabelTtfFieldNumber = 14;
  inline const ::maker::LabelTTF& label_ttf() const;
  inline ::maker::LabelTTF* mutable_label_ttf();
  inline ::maker::LabelTTF* release_label_ttf();
  inline void set_allocated_label_ttf(::maker::LabelTTF* label_ttf);

  // optional .maker.TextFieldTTF text_field_ttf = 15;
  inline bool has_text_field_ttf() const;
  inline void clear_text_field_ttf();
  static const int kTextFieldTtfFieldNumber = 15;
  inline const ::maker::TextFieldTTF& text_field_ttf() const;
  inline ::maker::TextFieldTTF* mutable_text_field_ttf();
  inline ::maker::TextFieldTTF* release_text_field_ttf();
  inline void set_allocated_text_field_ttf(::maker::TextFieldTTF* text_field_ttf);

  // optional .maker.EditBox edit_box = 16;
  inline bool has_edit_box() const;
  inline void clear_edit_box();
  static const int kEditBoxFieldNumber = 16;
  inline const ::maker::EditBox& edit_box() const;
  inline ::maker::EditBox* mutable_edit_box();
  inline ::maker::EditBox* release_edit_box();
  inline void set_allocated_edit_box(::maker::EditBox* edit_box);

  // optional .maker.TableView table_view = 17;
  inline bool has_table_view() const;
  inline void clear_table_view();
  static const int kTableViewFieldNumber = 17;
  inline const ::maker::TableView& table_view() const;
  inline ::maker::TableView* mutable_table_view();
  inline ::maker::TableView* release_table_view();
  inline void set_allocated_table_view(::maker::TableView* table_view);

  // optional .maker.RotatePlate rotate_plate = 18;
  inline bool has_rotate_plate() const;
  inline void clear_rotate_plate();
  static const int kRotatePlateFieldNumber = 18;
  inline const ::maker::RotatePlate& rotate_plate() const;
  inline ::maker::RotatePlate* mutable_rotate_plate();
  inline ::maker::RotatePlate* release_rotate_plate();
  inline void set_allocated_rotate_plate(::maker::RotatePlate* rotate_plate);

  // optional .maker.Button button = 19;
  inline bool has_button() const;
  inline void clear_button();
  static const int kButtonFieldNumber = 19;
  inline const ::maker::Button& button() const;
  inline ::maker::Button* mutable_button();
  inline ::maker::Button* release_button();
  inline void set_allocated_button(::maker::Button* button);

  // optional .maker.Sprite sprite = 20;
  inline bool has_sprite() const;
  inline void clear_sprite();
  static const int kSpriteFieldNumber = 20;
  inline const ::maker::Sprite& sprite() const;
  inline ::maker::Sprite* mutable_sprite();
  inline ::maker::Sprite* release_sprite();
  inline void set_allocated_sprite(::maker::Sprite* sprite);

  // optional .maker.Scale9Sprite scale_9_sprite = 21;
  inline bool has_scale_9_sprite() const;
  inline void clear_scale_9_sprite();
  static const int kScale9SpriteFieldNumber = 21;
  inline const ::maker::Scale9Sprite& scale_9_sprite() const;
  inline ::maker::Scale9Sprite* mutable_scale_9_sprite();
  inline ::maker::Scale9Sprite* release_scale_9_sprite();
  inline void set_allocated_scale_9_sprite(::maker::Scale9Sprite* scale_9_sprite);

  // optional .maker.ProgressTimer progress_timer = 22;
  inline bool has_progress_timer() const;
  inline void clear_progress_timer();
  static const int kProgressTimerFieldNumber = 22;
  inline const ::maker::ProgressTimer& progress_timer() const;
  inline ::maker::ProgressTimer* mutable_progress_timer();
  inline ::maker::ProgressTimer* release_progress_timer();
  inline void set_allocated_progress_timer(::maker::ProgressTimer* progress_timer);

  // optional .maker.Visual visual = 23;
  inline bool has_visual() const;
  inline void clear_visual();
  static const int kVisualFieldNumber = 23;
  inline const ::maker::Visual& visual() const;
  inline ::maker::Visual* mutable_visual();
  inline ::maker::Visual* release_visual();
  inline void set_allocated_visual(::maker::Visual* visual);

  // optional .maker.Particle particle = 24;
  inline bool has_particle() const;
  inline void clear_particle();
  static const int kParticleFieldNumber = 24;
  inline const ::maker::Particle& particle() const;
  inline ::maker::Particle* mutable_particle();
  inline ::maker::Particle* release_particle();
  inline void set_allocated_particle(::maker::Particle* particle);

  // optional .maker.ClippingNode clipping_node = 25;
  inline bool has_clipping_node() const;
  inline void clear_clipping_node();
  static const int kClippingNodeFieldNumber = 25;
  inline const ::maker::ClippingNode& clipping_node() const;
  inline ::maker::ClippingNode* mutable_clipping_node();
  inline ::maker::ClippingNode* release_clipping_node();
  inline void set_allocated_clipping_node(::maker::ClippingNode* clipping_node);

  // optional .maker.SocketNode socket_node = 100;
  inline bool has_socket_node() const;
  inline void clear_socket_node();
  static const int kSocketNodeFieldNumber = 100;
  inline const ::maker::SocketNode& socket_node() const;
  inline ::maker::SocketNode* mutable_socket_node();
  inline ::maker::SocketNode* release_socket_node();
  inline void set_allocated_socket_node(::maker::SocketNode* socket_node);

  // @@protoc_insertion_point(class_scope:maker.Properties)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_layer_color();
  inline void clear_has_layer_color();
  inline void set_has_layer_gradient();
  inline void clear_has_layer_gradient();
  inline void set_has_label_syatem_font();
  inline void clear_has_label_syatem_font();
  inline void set_has_label_ttf();
  inline void clear_has_label_ttf();
  inline void set_has_text_field_ttf();
  inline void clear_has_text_field_ttf();
  inline void set_has_edit_box();
  inline void clear_has_edit_box();
  inline void set_has_table_view();
  inline void clear_has_table_view();
  inline void set_has_rotate_plate();
  inline void clear_has_rotate_plate();
  inline void set_has_button();
  inline void clear_has_button();
  inline void set_has_sprite();
  inline void clear_has_sprite();
  inline void set_has_scale_9_sprite();
  inline void clear_has_scale_9_sprite();
  inline void set_has_progress_timer();
  inline void clear_has_progress_timer();
  inline void set_has_visual();
  inline void clear_has_visual();
  inline void set_has_particle();
  inline void clear_has_particle();
  inline void set_has_clipping_node();
  inline void clear_has_clipping_node();
  inline void set_has_socket_node();
  inline void clear_has_socket_node();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::maker::Node* node_;
  ::maker::LayerColor* layer_color_;
  ::maker::LayerGradient* layer_gradient_;
  ::maker::LabelSystemFont* label_syatem_font_;
  ::maker::LabelTTF* label_ttf_;
  ::maker::TextFieldTTF* text_field_ttf_;
  ::maker::EditBox* edit_box_;
  ::maker::TableView* table_view_;
  ::maker::RotatePlate* rotate_plate_;
  ::maker::Button* button_;
  ::maker::Sprite* sprite_;
  ::maker::Scale9Sprite* scale_9_sprite_;
  ::maker::ProgressTimer* progress_timer_;
  ::maker::Visual* visual_;
  ::maker::Particle* particle_;
  ::maker::ClippingNode* clipping_node_;
  ::maker::SocketNode* socket_node_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static Properties* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message {
 public:
  Entity();
  virtual ~Entity();

  Entity(const Entity& from);

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();

  void Swap(Entity* other);

  // implements Message ----------------------------------------------

  Entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required bool expand = 2 [default = true];
  inline bool has_expand() const;
  inline void clear_expand();
  static const int kExpandFieldNumber = 2;
  inline bool expand() const;
  inline void set_expand(bool value);

  // optional bool selected = 3 [default = false];
  inline bool has_selected() const;
  inline void clear_selected();
  static const int kSelectedFieldNumber = 3;
  inline bool selected() const;
  inline void set_selected(bool value);

  // optional bool parent_selected = 4 [default = false];
  inline bool has_parent_selected() const;
  inline void clear_parent_selected();
  static const int kParentSelectedFieldNumber = 4;
  inline bool parent_selected() const;
  inline void set_parent_selected(bool value);

  // optional uint64 parent_id = 6 [default = 0];
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 6;
  inline ::google::protobuf::uint64 parent_id() const;
  inline void set_parent_id(::google::protobuf::uint64 value);

  // required uint64 prev_id = 7 [default = 0];
  inline bool has_prev_id() const;
  inline void clear_prev_id();
  static const int kPrevIdFieldNumber = 7;
  inline ::google::protobuf::uint64 prev_id() const;
  inline void set_prev_id(::google::protobuf::uint64 value);

  // optional uint64 dest_id = 8 [default = 0];
  inline bool has_dest_id() const;
  inline void clear_dest_id();
  static const int kDestIdFieldNumber = 8;
  inline ::google::protobuf::uint64 dest_id() const;
  inline void set_dest_id(::google::protobuf::uint64 value);

  // optional uint64 dest_parent_id = 9 [default = 0];
  inline bool has_dest_parent_id() const;
  inline void clear_dest_parent_id();
  static const int kDestParentIdFieldNumber = 9;
  inline ::google::protobuf::uint64 dest_parent_id() const;
  inline void set_dest_parent_id(::google::protobuf::uint64 value);

  // optional bool lua_name_duplicated = 10 [default = false];
  inline bool has_lua_name_duplicated() const;
  inline void clear_lua_name_duplicated();
  static const int kLuaNameDuplicatedFieldNumber = 10;
  inline bool lua_name_duplicated() const;
  inline void set_lua_name_duplicated(bool value);

  // optional .maker.Properties properties = 20;
  inline bool has_properties() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 20;
  inline const ::maker::Properties& properties() const;
  inline ::maker::Properties* mutable_properties();
  inline ::maker::Properties* release_properties();
  inline void set_allocated_properties(::maker::Properties* properties);

  // repeated .maker.Entity children = 30;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 30;
  inline const ::maker::Entity& children(int index) const;
  inline ::maker::Entity* mutable_children(int index);
  inline ::maker::Entity* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::maker::Entity >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::maker::Entity >*
      mutable_children();

  // @@protoc_insertion_point(class_scope:maker.Entity)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_expand();
  inline void clear_has_expand();
  inline void set_has_selected();
  inline void clear_has_selected();
  inline void set_has_parent_selected();
  inline void clear_has_parent_selected();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_prev_id();
  inline void clear_has_prev_id();
  inline void set_has_dest_id();
  inline void clear_has_dest_id();
  inline void set_has_dest_parent_id();
  inline void clear_has_dest_parent_id();
  inline void set_has_lua_name_duplicated();
  inline void clear_has_lua_name_duplicated();
  inline void set_has_properties();
  inline void clear_has_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 parent_id_;
  ::google::protobuf::uint64 prev_id_;
  ::google::protobuf::uint64 dest_id_;
  ::google::protobuf::uint64 dest_parent_id_;
  ::maker::Properties* properties_;
  ::google::protobuf::RepeatedPtrField< ::maker::Entity > children_;
  bool expand_;
  bool selected_;
  bool parent_selected_;
  bool lua_name_duplicated_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// -------------------------------------------------------------------

class CMD : public ::google::protobuf::Message {
 public:
  CMD();
  virtual ~CMD();

  CMD(const CMD& from);

  inline CMD& operator=(const CMD& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMD& default_instance();

  void Swap(CMD* other);

  // implements Message ----------------------------------------------

  CMD* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMD& from);
  void MergeFrom(const CMD& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required .maker.CMD_TYPE type = 2 [default = CMD__Create];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::maker::CMD_TYPE type() const;
  inline void set_type(::maker::CMD_TYPE value);

  // optional int32 window_x = 10 [default = 0];
  inline bool has_window_x() const;
  inline void clear_window_x();
  static const int kWindowXFieldNumber = 10;
  inline ::google::protobuf::int32 window_x() const;
  inline void set_window_x(::google::protobuf::int32 value);

  // optional int32 window_y = 11 [default = 0];
  inline bool has_window_y() const;
  inline void clear_window_y();
  static const int kWindowYFieldNumber = 11;
  inline ::google::protobuf::int32 window_y() const;
  inline void set_window_y(::google::protobuf::int32 value);

  // optional .maker.EVENT_TO_TOOL event_id = 14 [default = EVENT__None];
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 14;
  inline ::maker::EVENT_TO_TOOL event_id() const;
  inline void set_event_id(::maker::EVENT_TO_TOOL value);

  // optional .maker.EVENT_TO_VIEWER viewer_event_id = 15 [default = VIEWER_EVENT__None];
  inline bool has_viewer_event_id() const;
  inline void clear_viewer_event_id();
  static const int kViewerEventIdFieldNumber = 15;
  inline ::maker::EVENT_TO_VIEWER viewer_event_id() const;
  inline void set_viewer_event_id(::maker::EVENT_TO_VIEWER value);

  // optional string description = 16 [default = ""];
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 16;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional uint64 update_to_cmd_id = 17 [default = 0];
  inline bool has_update_to_cmd_id() const;
  inline void clear_update_to_cmd_id();
  static const int kUpdateToCmdIdFieldNumber = 17;
  inline ::google::protobuf::uint64 update_to_cmd_id() const;
  inline void set_update_to_cmd_id(::google::protobuf::uint64 value);

  // optional bool dont_append_history = 18 [default = false];
  inline bool has_dont_append_history() const;
  inline void clear_dont_append_history();
  static const int kDontAppendHistoryFieldNumber = 18;
  inline bool dont_append_history() const;
  inline void set_dont_append_history(bool value);

  // optional bool can_merge_prev_cmd = 19 [default = false];
  inline bool has_can_merge_prev_cmd() const;
  inline void clear_can_merge_prev_cmd();
  static const int kCanMergePrevCmdFieldNumber = 19;
  inline bool can_merge_prev_cmd() const;
  inline void set_can_merge_prev_cmd(bool value);

  // repeated .maker.Entity entities = 20;
  inline int entities_size() const;
  inline void clear_entities();
  static const int kEntitiesFieldNumber = 20;
  inline const ::maker::Entity& entities(int index) const;
  inline ::maker::Entity* mutable_entities(int index);
  inline ::maker::Entity* add_entities();
  inline const ::google::protobuf::RepeatedPtrField< ::maker::Entity >&
      entities() const;
  inline ::google::protobuf::RepeatedPtrField< ::maker::Entity >*
      mutable_entities();

  // repeated .maker.Entity backup_entities = 21;
  inline int backup_entities_size() const;
  inline void clear_backup_entities();
  static const int kBackupEntitiesFieldNumber = 21;
  inline const ::maker::Entity& backup_entities(int index) const;
  inline ::maker::Entity* mutable_backup_entities(int index);
  inline ::maker::Entity* add_backup_entities();
  inline const ::google::protobuf::RepeatedPtrField< ::maker::Entity >&
      backup_entities() const;
  inline ::google::protobuf::RepeatedPtrField< ::maker::Entity >*
      mutable_backup_entities();

  // repeated string enum_list = 30;
  inline int enum_list_size() const;
  inline void clear_enum_list();
  static const int kEnumListFieldNumber = 30;
  inline const ::std::string& enum_list(int index) const;
  inline ::std::string* mutable_enum_list(int index);
  inline void set_enum_list(int index, const ::std::string& value);
  inline void set_enum_list(int index, const char* value);
  inline void set_enum_list(int index, const char* value, size_t size);
  inline ::std::string* add_enum_list();
  inline void add_enum_list(const ::std::string& value);
  inline void add_enum_list(const char* value);
  inline void add_enum_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& enum_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_enum_list();

  // repeated string socket_node_list = 31;
  inline int socket_node_list_size() const;
  inline void clear_socket_node_list();
  static const int kSocketNodeListFieldNumber = 31;
  inline const ::std::string& socket_node_list(int index) const;
  inline ::std::string* mutable_socket_node_list(int index);
  inline void set_socket_node_list(int index, const ::std::string& value);
  inline void set_socket_node_list(int index, const char* value);
  inline void set_socket_node_list(int index, const char* value, size_t size);
  inline ::std::string* add_socket_node_list();
  inline void add_socket_node_list(const ::std::string& value);
  inline void add_socket_node_list(const char* value);
  inline void add_socket_node_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& socket_node_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_socket_node_list();

  // @@protoc_insertion_point(class_scope:maker.CMD)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_window_x();
  inline void clear_has_window_x();
  inline void set_has_window_y();
  inline void clear_has_window_y();
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_viewer_event_id();
  inline void clear_has_viewer_event_id();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_update_to_cmd_id();
  inline void clear_has_update_to_cmd_id();
  inline void set_has_dont_append_history();
  inline void clear_has_dont_append_history();
  inline void set_has_can_merge_prev_cmd();
  inline void clear_has_can_merge_prev_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  int type_;
  ::google::protobuf::int32 window_x_;
  ::google::protobuf::int32 window_y_;
  int event_id_;
  ::std::string* description_;
  ::google::protobuf::uint64 update_to_cmd_id_;
  int viewer_event_id_;
  bool dont_append_history_;
  bool can_merge_prev_cmd_;
  ::google::protobuf::RepeatedPtrField< ::maker::Entity > entities_;
  ::google::protobuf::RepeatedPtrField< ::maker::Entity > backup_entities_;
  ::google::protobuf::RepeatedPtrField< ::std::string> enum_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> socket_node_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_maker_2eproto();
  friend void protobuf_AssignDesc_maker_2eproto();
  friend void protobuf_ShutdownFile_maker_2eproto();

  void InitAsDefaultInstance();
  static CMD* default_instance_;
};
// ===================================================================


// ===================================================================

// COLOR

// required int32 r = 1 [default = 255];
inline bool COLOR::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void COLOR::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void COLOR::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void COLOR::clear_r() {
  r_ = 255;
  clear_has_r();
}
inline ::google::protobuf::int32 COLOR::r() const {
  return r_;
}
inline void COLOR::set_r(::google::protobuf::int32 value) {
  set_has_r();
  r_ = value;
}

// required int32 g = 2 [default = 255];
inline bool COLOR::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void COLOR::set_has_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void COLOR::clear_has_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void COLOR::clear_g() {
  g_ = 255;
  clear_has_g();
}
inline ::google::protobuf::int32 COLOR::g() const {
  return g_;
}
inline void COLOR::set_g(::google::protobuf::int32 value) {
  set_has_g();
  g_ = value;
}

// required int32 b = 3 [default = 255];
inline bool COLOR::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void COLOR::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void COLOR::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void COLOR::clear_b() {
  b_ = 255;
  clear_has_b();
}
inline ::google::protobuf::int32 COLOR::b() const {
  return b_;
}
inline void COLOR::set_b(::google::protobuf::int32 value) {
  set_has_b();
  b_ = value;
}

// -------------------------------------------------------------------

// FILE

// required string path = 1 [default = ""];
inline bool FILE::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FILE::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FILE::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FILE::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FILE::path() const {
  return *path_;
}
inline void FILE::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FILE::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FILE::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FILE::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FILE_IMAGE

// required string path = 1 [default = ""];
inline bool FILE_IMAGE::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FILE_IMAGE::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FILE_IMAGE::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FILE_IMAGE::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FILE_IMAGE::path() const {
  return *path_;
}
inline void FILE_IMAGE::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_IMAGE::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_IMAGE::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FILE_IMAGE::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FILE_IMAGE::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FILE_IMAGE::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FILE_SOUND

// required string path = 1 [default = ""];
inline bool FILE_SOUND::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FILE_SOUND::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FILE_SOUND::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FILE_SOUND::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FILE_SOUND::path() const {
  return *path_;
}
inline void FILE_SOUND::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_SOUND::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_SOUND::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FILE_SOUND::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FILE_SOUND::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FILE_SOUND::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FILE_BMFONT

// required string path = 1 [default = ""];
inline bool FILE_BMFONT::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FILE_BMFONT::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FILE_BMFONT::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FILE_BMFONT::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FILE_BMFONT::path() const {
  return *path_;
}
inline void FILE_BMFONT::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_BMFONT::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_BMFONT::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FILE_BMFONT::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FILE_BMFONT::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FILE_BMFONT::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FILE_TTF

// required string path = 1 [default = ""];
inline bool FILE_TTF::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FILE_TTF::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FILE_TTF::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FILE_TTF::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FILE_TTF::path() const {
  return *path_;
}
inline void FILE_TTF::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_TTF::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_TTF::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FILE_TTF::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FILE_TTF::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FILE_TTF::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FILE_VISUAL

// required string path = 1 [default = ""];
inline bool FILE_VISUAL::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FILE_VISUAL::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FILE_VISUAL::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FILE_VISUAL::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FILE_VISUAL::path() const {
  return *path_;
}
inline void FILE_VISUAL::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_VISUAL::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_VISUAL::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FILE_VISUAL::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FILE_VISUAL::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FILE_VISUAL::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FILE_PLIST

// required string path = 1 [default = ""];
inline bool FILE_PLIST::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FILE_PLIST::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FILE_PLIST::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FILE_PLIST::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FILE_PLIST::path() const {
  return *path_;
}
inline void FILE_PLIST::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_PLIST::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void FILE_PLIST::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FILE_PLIST::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* FILE_PLIST::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FILE_PLIST::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NAME_VISUAL_GROUP

// required string name = 1 [default = ""];
inline bool NAME_VISUAL_GROUP::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NAME_VISUAL_GROUP::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NAME_VISUAL_GROUP::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NAME_VISUAL_GROUP::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NAME_VISUAL_GROUP::name() const {
  return *name_;
}
inline void NAME_VISUAL_GROUP::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NAME_VISUAL_GROUP::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NAME_VISUAL_GROUP::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NAME_VISUAL_GROUP::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NAME_VISUAL_GROUP::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NAME_VISUAL_GROUP::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NAME_VISUAL

// required string name = 1 [default = ""];
inline bool NAME_VISUAL::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NAME_VISUAL::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NAME_VISUAL::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NAME_VISUAL::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NAME_VISUAL::name() const {
  return *name_;
}
inline void NAME_VISUAL::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NAME_VISUAL::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NAME_VISUAL::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NAME_VISUAL::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NAME_VISUAL::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NAME_VISUAL::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Node

// optional string ui_name = 1 [default = ""];
inline bool Node::has_ui_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_ui_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_ui_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_ui_name() {
  if (ui_name_ != &::google::protobuf::internal::kEmptyString) {
    ui_name_->clear();
  }
  clear_has_ui_name();
}
inline const ::std::string& Node::ui_name() const {
  return *ui_name_;
}
inline void Node::set_ui_name(const ::std::string& value) {
  set_has_ui_name();
  if (ui_name_ == &::google::protobuf::internal::kEmptyString) {
    ui_name_ = new ::std::string;
  }
  ui_name_->assign(value);
}
inline void Node::set_ui_name(const char* value) {
  set_has_ui_name();
  if (ui_name_ == &::google::protobuf::internal::kEmptyString) {
    ui_name_ = new ::std::string;
  }
  ui_name_->assign(value);
}
inline void Node::set_ui_name(const char* value, size_t size) {
  set_has_ui_name();
  if (ui_name_ == &::google::protobuf::internal::kEmptyString) {
    ui_name_ = new ::std::string;
  }
  ui_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_ui_name() {
  set_has_ui_name();
  if (ui_name_ == &::google::protobuf::internal::kEmptyString) {
    ui_name_ = new ::std::string;
  }
  return ui_name_;
}
inline ::std::string* Node::release_ui_name() {
  clear_has_ui_name();
  if (ui_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ui_name_;
    ui_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Node::set_allocated_ui_name(::std::string* ui_name) {
  if (ui_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ui_name_;
  }
  if (ui_name) {
    set_has_ui_name();
    ui_name_ = ui_name;
  } else {
    clear_has_ui_name();
    ui_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string flag = 2 [default = ""];
inline bool Node::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_flag() {
  if (flag_ != &::google::protobuf::internal::kEmptyString) {
    flag_->clear();
  }
  clear_has_flag();
}
inline const ::std::string& Node::flag() const {
  return *flag_;
}
inline void Node::set_flag(const ::std::string& value) {
  set_has_flag();
  if (flag_ == &::google::protobuf::internal::kEmptyString) {
    flag_ = new ::std::string;
  }
  flag_->assign(value);
}
inline void Node::set_flag(const char* value) {
  set_has_flag();
  if (flag_ == &::google::protobuf::internal::kEmptyString) {
    flag_ = new ::std::string;
  }
  flag_->assign(value);
}
inline void Node::set_flag(const char* value, size_t size) {
  set_has_flag();
  if (flag_ == &::google::protobuf::internal::kEmptyString) {
    flag_ = new ::std::string;
  }
  flag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_flag() {
  set_has_flag();
  if (flag_ == &::google::protobuf::internal::kEmptyString) {
    flag_ = new ::std::string;
  }
  return flag_;
}
inline ::std::string* Node::release_flag() {
  clear_has_flag();
  if (flag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flag_;
    flag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Node::set_allocated_flag(::std::string* flag) {
  if (flag_ != &::google::protobuf::internal::kEmptyString) {
    delete flag_;
  }
  if (flag) {
    set_has_flag();
    flag_ = flag;
  } else {
    clear_has_flag();
    flag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float x = 3 [default = 0];
inline bool Node::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Node::x() const {
  return x_;
}
inline void Node::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 4 [default = 0];
inline bool Node::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Node::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Node::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Node::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Node::y() const {
  return y_;
}
inline void Node::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional .maker.DOCK_POINT dock_point = 5 [default = DOCK__MIDDLE_CENTER];
inline bool Node::has_dock_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Node::set_has_dock_point() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Node::clear_has_dock_point() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Node::clear_dock_point() {
  dock_point_ = 4;
  clear_has_dock_point();
}
inline ::maker::DOCK_POINT Node::dock_point() const {
  return static_cast< ::maker::DOCK_POINT >(dock_point_);
}
inline void Node::set_dock_point(::maker::DOCK_POINT value) {
  assert(::maker::DOCK_POINT_IsValid(value));
  set_has_dock_point();
  dock_point_ = value;
}

// optional .maker.ANCHOR_POINT anchor_point = 6 [default = ANCHOR__MIDDLE_CENTER];
inline bool Node::has_anchor_point() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Node::set_has_anchor_point() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Node::clear_has_anchor_point() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Node::clear_anchor_point() {
  anchor_point_ = 4;
  clear_has_anchor_point();
}
inline ::maker::ANCHOR_POINT Node::anchor_point() const {
  return static_cast< ::maker::ANCHOR_POINT >(anchor_point_);
}
inline void Node::set_anchor_point(::maker::ANCHOR_POINT value) {
  assert(::maker::ANCHOR_POINT_IsValid(value));
  set_has_anchor_point();
  anchor_point_ = value;
}

// optional .maker.RELATIVE_SIZE_TYPE relative_size_type = 7 [default = RELATIVE_SIZE_TYPE__NONE];
inline bool Node::has_relative_size_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Node::set_has_relative_size_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Node::clear_has_relative_size_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Node::clear_relative_size_type() {
  relative_size_type_ = 0;
  clear_has_relative_size_type();
}
inline ::maker::RELATIVE_SIZE_TYPE Node::relative_size_type() const {
  return static_cast< ::maker::RELATIVE_SIZE_TYPE >(relative_size_type_);
}
inline void Node::set_relative_size_type(::maker::RELATIVE_SIZE_TYPE value) {
  assert(::maker::RELATIVE_SIZE_TYPE_IsValid(value));
  set_has_relative_size_type();
  relative_size_type_ = value;
}

// optional int32 rel_width = 8 [default = 0];
inline bool Node::has_rel_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Node::set_has_rel_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Node::clear_has_rel_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Node::clear_rel_width() {
  rel_width_ = 0;
  clear_has_rel_width();
}
inline ::google::protobuf::int32 Node::rel_width() const {
  return rel_width_;
}
inline void Node::set_rel_width(::google::protobuf::int32 value) {
  set_has_rel_width();
  rel_width_ = value;
}

// optional int32 rel_height = 9 [default = 0];
inline bool Node::has_rel_height() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Node::set_has_rel_height() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Node::clear_has_rel_height() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Node::clear_rel_height() {
  rel_height_ = 0;
  clear_has_rel_height();
}
inline ::google::protobuf::int32 Node::rel_height() const {
  return rel_height_;
}
inline void Node::set_rel_height(::google::protobuf::int32 value) {
  set_has_rel_height();
  rel_height_ = value;
}

// optional int32 width = 10 [default = 100];
inline bool Node::has_width() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Node::set_has_width() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Node::clear_has_width() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Node::clear_width() {
  width_ = 100;
  clear_has_width();
}
inline ::google::protobuf::int32 Node::width() const {
  return width_;
}
inline void Node::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 11 [default = 100];
inline bool Node::has_height() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Node::set_has_height() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Node::clear_has_height() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Node::clear_height() {
  height_ = 100;
  clear_has_height();
}
inline ::google::protobuf::int32 Node::height() const {
  return height_;
}
inline void Node::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional float scale_x = 12 [default = 1];
inline bool Node::has_scale_x() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Node::set_has_scale_x() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Node::clear_has_scale_x() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Node::clear_scale_x() {
  scale_x_ = 1;
  clear_has_scale_x();
}
inline float Node::scale_x() const {
  return scale_x_;
}
inline void Node::set_scale_x(float value) {
  set_has_scale_x();
  scale_x_ = value;
}

// optional float scale_y = 13 [default = 1];
inline bool Node::has_scale_y() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Node::set_has_scale_y() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Node::clear_has_scale_y() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Node::clear_scale_y() {
  scale_y_ = 1;
  clear_has_scale_y();
}
inline float Node::scale_y() const {
  return scale_y_;
}
inline void Node::set_scale_y(float value) {
  set_has_scale_y();
  scale_y_ = value;
}

// optional float skew_x = 14 [default = 0];
inline bool Node::has_skew_x() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Node::set_has_skew_x() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Node::clear_has_skew_x() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Node::clear_skew_x() {
  skew_x_ = 0;
  clear_has_skew_x();
}
inline float Node::skew_x() const {
  return skew_x_;
}
inline void Node::set_skew_x(float value) {
  set_has_skew_x();
  skew_x_ = value;
}

// optional float skew_y = 15 [default = 0];
inline bool Node::has_skew_y() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Node::set_has_skew_y() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Node::clear_has_skew_y() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Node::clear_skew_y() {
  skew_y_ = 0;
  clear_has_skew_y();
}
inline float Node::skew_y() const {
  return skew_y_;
}
inline void Node::set_skew_y(float value) {
  set_has_skew_y();
  skew_y_ = value;
}

// optional float rotation = 16 [default = 0];
inline bool Node::has_rotation() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Node::set_has_rotation() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Node::clear_has_rotation() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Node::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float Node::rotation() const {
  return rotation_;
}
inline void Node::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional bool visible = 17 [default = true];
inline bool Node::has_visible() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Node::set_has_visible() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Node::clear_has_visible() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Node::clear_visible() {
  visible_ = true;
  clear_has_visible();
}
inline bool Node::visible() const {
  return visible_;
}
inline void Node::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional .maker.NODE_ACTION_TYPE action_type = 18 [default = NODE_ACTION_TYPE__NONE];
inline bool Node::has_action_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Node::set_has_action_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Node::clear_has_action_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Node::clear_action_type() {
  action_type_ = 0;
  clear_has_action_type();
}
inline ::maker::NODE_ACTION_TYPE Node::action_type() const {
  return static_cast< ::maker::NODE_ACTION_TYPE >(action_type_);
}
inline void Node::set_action_type(::maker::NODE_ACTION_TYPE value) {
  assert(::maker::NODE_ACTION_TYPE_IsValid(value));
  set_has_action_type();
  action_type_ = value;
}

// optional float action_delay_1 = 19 [default = 0];
inline bool Node::has_action_delay_1() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Node::set_has_action_delay_1() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Node::clear_has_action_delay_1() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Node::clear_action_delay_1() {
  action_delay_1_ = 0;
  clear_has_action_delay_1();
}
inline float Node::action_delay_1() const {
  return action_delay_1_;
}
inline void Node::set_action_delay_1(float value) {
  set_has_action_delay_1();
  action_delay_1_ = value;
}

// optional float action_delay_2 = 20 [default = 0];
inline bool Node::has_action_delay_2() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Node::set_has_action_delay_2() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Node::clear_has_action_delay_2() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Node::clear_action_delay_2() {
  action_delay_2_ = 0;
  clear_has_action_delay_2();
}
inline float Node::action_delay_2() const {
  return action_delay_2_;
}
inline void Node::set_action_delay_2(float value) {
  set_has_action_delay_2();
  action_delay_2_ = value;
}

// optional float action_duration = 21 [default = 0];
inline bool Node::has_action_duration() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Node::set_has_action_duration() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Node::clear_has_action_duration() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Node::clear_action_duration() {
  action_duration_ = 0;
  clear_has_action_duration();
}
inline float Node::action_duration() const {
  return action_duration_;
}
inline void Node::set_action_duration(float value) {
  set_has_action_duration();
  action_duration_ = value;
}

// optional .maker.SCREEN_UI_TYPE screen_ui = 22 [default = SCREEN_UI_TYPE__NONE];
inline bool Node::has_screen_ui() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Node::set_has_screen_ui() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Node::clear_has_screen_ui() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Node::clear_screen_ui() {
  screen_ui_ = 0;
  clear_has_screen_ui();
}
inline ::maker::SCREEN_UI_TYPE Node::screen_ui() const {
  return static_cast< ::maker::SCREEN_UI_TYPE >(screen_ui_);
}
inline void Node::set_screen_ui(::maker::SCREEN_UI_TYPE value) {
  assert(::maker::SCREEN_UI_TYPE_IsValid(value));
  set_has_screen_ui();
  screen_ui_ = value;
}

// optional string lua_name = 23 [default = ""];
inline bool Node::has_lua_name() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Node::set_has_lua_name() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Node::clear_has_lua_name() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Node::clear_lua_name() {
  if (lua_name_ != &::google::protobuf::internal::kEmptyString) {
    lua_name_->clear();
  }
  clear_has_lua_name();
}
inline const ::std::string& Node::lua_name() const {
  return *lua_name_;
}
inline void Node::set_lua_name(const ::std::string& value) {
  set_has_lua_name();
  if (lua_name_ == &::google::protobuf::internal::kEmptyString) {
    lua_name_ = new ::std::string;
  }
  lua_name_->assign(value);
}
inline void Node::set_lua_name(const char* value) {
  set_has_lua_name();
  if (lua_name_ == &::google::protobuf::internal::kEmptyString) {
    lua_name_ = new ::std::string;
  }
  lua_name_->assign(value);
}
inline void Node::set_lua_name(const char* value, size_t size) {
  set_has_lua_name();
  if (lua_name_ == &::google::protobuf::internal::kEmptyString) {
    lua_name_ = new ::std::string;
  }
  lua_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_lua_name() {
  set_has_lua_name();
  if (lua_name_ == &::google::protobuf::internal::kEmptyString) {
    lua_name_ = new ::std::string;
  }
  return lua_name_;
}
inline ::std::string* Node::release_lua_name() {
  clear_has_lua_name();
  if (lua_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lua_name_;
    lua_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Node::set_allocated_lua_name(::std::string* lua_name) {
  if (lua_name_ != &::google::protobuf::internal::kEmptyString) {
    delete lua_name_;
  }
  if (lua_name) {
    set_has_lua_name();
    lua_name_ = lua_name;
  } else {
    clear_has_lua_name();
    lua_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClippingNode

// optional .maker.STENCIL_TYPE stencil_type = 1 [default = SQUARE];
inline bool ClippingNode::has_stencil_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClippingNode::set_has_stencil_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClippingNode::clear_has_stencil_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClippingNode::clear_stencil_type() {
  stencil_type_ = 0;
  clear_has_stencil_type();
}
inline ::maker::STENCIL_TYPE ClippingNode::stencil_type() const {
  return static_cast< ::maker::STENCIL_TYPE >(stencil_type_);
}
inline void ClippingNode::set_stencil_type(::maker::STENCIL_TYPE value) {
  assert(::maker::STENCIL_TYPE_IsValid(value));
  set_has_stencil_type();
  stencil_type_ = value;
}

// optional .maker.FILE_IMAGE stencil_img = 2;
inline bool ClippingNode::has_stencil_img() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClippingNode::set_has_stencil_img() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClippingNode::clear_has_stencil_img() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClippingNode::clear_stencil_img() {
  if (stencil_img_ != NULL) stencil_img_->::maker::FILE_IMAGE::Clear();
  clear_has_stencil_img();
}
inline const ::maker::FILE_IMAGE& ClippingNode::stencil_img() const {
  return stencil_img_ != NULL ? *stencil_img_ : *default_instance_->stencil_img_;
}
inline ::maker::FILE_IMAGE* ClippingNode::mutable_stencil_img() {
  set_has_stencil_img();
  if (stencil_img_ == NULL) stencil_img_ = new ::maker::FILE_IMAGE;
  return stencil_img_;
}
inline ::maker::FILE_IMAGE* ClippingNode::release_stencil_img() {
  clear_has_stencil_img();
  ::maker::FILE_IMAGE* temp = stencil_img_;
  stencil_img_ = NULL;
  return temp;
}
inline void ClippingNode::set_allocated_stencil_img(::maker::FILE_IMAGE* stencil_img) {
  delete stencil_img_;
  stencil_img_ = stencil_img;
  if (stencil_img) {
    set_has_stencil_img();
  } else {
    clear_has_stencil_img();
  }
}

// optional float alpha_threshold = 3 [default = 1];
inline bool ClippingNode::has_alpha_threshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClippingNode::set_has_alpha_threshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClippingNode::clear_has_alpha_threshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClippingNode::clear_alpha_threshold() {
  alpha_threshold_ = 1;
  clear_has_alpha_threshold();
}
inline float ClippingNode::alpha_threshold() const {
  return alpha_threshold_;
}
inline void ClippingNode::set_alpha_threshold(float value) {
  set_has_alpha_threshold();
  alpha_threshold_ = value;
}

// optional bool is_invert = 4 [default = false];
inline bool ClippingNode::has_is_invert() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClippingNode::set_has_is_invert() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClippingNode::clear_has_is_invert() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClippingNode::clear_is_invert() {
  is_invert_ = false;
  clear_has_is_invert();
}
inline bool ClippingNode::is_invert() const {
  return is_invert_;
}
inline void ClippingNode::set_is_invert(bool value) {
  set_has_is_invert();
  is_invert_ = value;
}

// -------------------------------------------------------------------

// LayerColor

// optional .maker.COLOR color = 1;
inline bool LayerColor::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerColor::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerColor::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerColor::clear_color() {
  if (color_ != NULL) color_->::maker::COLOR::Clear();
  clear_has_color();
}
inline const ::maker::COLOR& LayerColor::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::maker::COLOR* LayerColor::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::maker::COLOR;
  return color_;
}
inline ::maker::COLOR* LayerColor::release_color() {
  clear_has_color();
  ::maker::COLOR* temp = color_;
  color_ = NULL;
  return temp;
}
inline void LayerColor::set_allocated_color(::maker::COLOR* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional int32 opacity = 2 [default = 255];
inline bool LayerColor::has_opacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerColor::set_has_opacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerColor::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerColor::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 LayerColor::opacity() const {
  return opacity_;
}
inline void LayerColor::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional .maker.BLEND_FUNCTION src_blend = 3 [default = BLEND__GL_SRC_ALPHA];
inline bool LayerColor::has_src_blend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerColor::set_has_src_blend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerColor::clear_has_src_blend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerColor::clear_src_blend() {
  src_blend_ = 770;
  clear_has_src_blend();
}
inline ::maker::BLEND_FUNCTION LayerColor::src_blend() const {
  return static_cast< ::maker::BLEND_FUNCTION >(src_blend_);
}
inline void LayerColor::set_src_blend(::maker::BLEND_FUNCTION value) {
  assert(::maker::BLEND_FUNCTION_IsValid(value));
  set_has_src_blend();
  src_blend_ = value;
}

// optional .maker.BLEND_FUNCTION dest_blend = 4 [default = BLEND__GL_ONE_MINUS_SRC_ALPHA];
inline bool LayerColor::has_dest_blend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerColor::set_has_dest_blend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayerColor::clear_has_dest_blend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayerColor::clear_dest_blend() {
  dest_blend_ = 771;
  clear_has_dest_blend();
}
inline ::maker::BLEND_FUNCTION LayerColor::dest_blend() const {
  return static_cast< ::maker::BLEND_FUNCTION >(dest_blend_);
}
inline void LayerColor::set_dest_blend(::maker::BLEND_FUNCTION value) {
  assert(::maker::BLEND_FUNCTION_IsValid(value));
  set_has_dest_blend();
  dest_blend_ = value;
}

// -------------------------------------------------------------------

// LayerGradient

// optional .maker.COLOR color = 1;
inline bool LayerGradient::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerGradient::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerGradient::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerGradient::clear_color() {
  if (color_ != NULL) color_->::maker::COLOR::Clear();
  clear_has_color();
}
inline const ::maker::COLOR& LayerGradient::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::maker::COLOR* LayerGradient::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::maker::COLOR;
  return color_;
}
inline ::maker::COLOR* LayerGradient::release_color() {
  clear_has_color();
  ::maker::COLOR* temp = color_;
  color_ = NULL;
  return temp;
}
inline void LayerGradient::set_allocated_color(::maker::COLOR* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional int32 opacity = 2 [default = 255];
inline bool LayerGradient::has_opacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerGradient::set_has_opacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerGradient::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerGradient::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 LayerGradient::opacity() const {
  return opacity_;
}
inline void LayerGradient::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional .maker.BLEND_FUNCTION src_blend = 3 [default = BLEND__GL_SRC_ALPHA];
inline bool LayerGradient::has_src_blend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerGradient::set_has_src_blend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerGradient::clear_has_src_blend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerGradient::clear_src_blend() {
  src_blend_ = 770;
  clear_has_src_blend();
}
inline ::maker::BLEND_FUNCTION LayerGradient::src_blend() const {
  return static_cast< ::maker::BLEND_FUNCTION >(src_blend_);
}
inline void LayerGradient::set_src_blend(::maker::BLEND_FUNCTION value) {
  assert(::maker::BLEND_FUNCTION_IsValid(value));
  set_has_src_blend();
  src_blend_ = value;
}

// optional .maker.BLEND_FUNCTION dest_blend = 4 [default = BLEND__GL_ONE_MINUS_SRC_ALPHA];
inline bool LayerGradient::has_dest_blend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerGradient::set_has_dest_blend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayerGradient::clear_has_dest_blend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayerGradient::clear_dest_blend() {
  dest_blend_ = 771;
  clear_has_dest_blend();
}
inline ::maker::BLEND_FUNCTION LayerGradient::dest_blend() const {
  return static_cast< ::maker::BLEND_FUNCTION >(dest_blend_);
}
inline void LayerGradient::set_dest_blend(::maker::BLEND_FUNCTION value) {
  assert(::maker::BLEND_FUNCTION_IsValid(value));
  set_has_dest_blend();
  dest_blend_ = value;
}

// optional .maker.COLOR start_color = 5;
inline bool LayerGradient::has_start_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LayerGradient::set_has_start_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LayerGradient::clear_has_start_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LayerGradient::clear_start_color() {
  if (start_color_ != NULL) start_color_->::maker::COLOR::Clear();
  clear_has_start_color();
}
inline const ::maker::COLOR& LayerGradient::start_color() const {
  return start_color_ != NULL ? *start_color_ : *default_instance_->start_color_;
}
inline ::maker::COLOR* LayerGradient::mutable_start_color() {
  set_has_start_color();
  if (start_color_ == NULL) start_color_ = new ::maker::COLOR;
  return start_color_;
}
inline ::maker::COLOR* LayerGradient::release_start_color() {
  clear_has_start_color();
  ::maker::COLOR* temp = start_color_;
  start_color_ = NULL;
  return temp;
}
inline void LayerGradient::set_allocated_start_color(::maker::COLOR* start_color) {
  delete start_color_;
  start_color_ = start_color;
  if (start_color) {
    set_has_start_color();
  } else {
    clear_has_start_color();
  }
}

// optional .maker.COLOR end_color = 6;
inline bool LayerGradient::has_end_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LayerGradient::set_has_end_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LayerGradient::clear_has_end_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LayerGradient::clear_end_color() {
  if (end_color_ != NULL) end_color_->::maker::COLOR::Clear();
  clear_has_end_color();
}
inline const ::maker::COLOR& LayerGradient::end_color() const {
  return end_color_ != NULL ? *end_color_ : *default_instance_->end_color_;
}
inline ::maker::COLOR* LayerGradient::mutable_end_color() {
  set_has_end_color();
  if (end_color_ == NULL) end_color_ = new ::maker::COLOR;
  return end_color_;
}
inline ::maker::COLOR* LayerGradient::release_end_color() {
  clear_has_end_color();
  ::maker::COLOR* temp = end_color_;
  end_color_ = NULL;
  return temp;
}
inline void LayerGradient::set_allocated_end_color(::maker::COLOR* end_color) {
  delete end_color_;
  end_color_ = end_color;
  if (end_color) {
    set_has_end_color();
  } else {
    clear_has_end_color();
  }
}

// optional int32 start_opacity = 7 [default = 255];
inline bool LayerGradient::has_start_opacity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayerGradient::set_has_start_opacity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LayerGradient::clear_has_start_opacity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LayerGradient::clear_start_opacity() {
  start_opacity_ = 255;
  clear_has_start_opacity();
}
inline ::google::protobuf::int32 LayerGradient::start_opacity() const {
  return start_opacity_;
}
inline void LayerGradient::set_start_opacity(::google::protobuf::int32 value) {
  set_has_start_opacity();
  start_opacity_ = value;
}

// optional int32 end_opacity = 8 [default = 255];
inline bool LayerGradient::has_end_opacity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LayerGradient::set_has_end_opacity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LayerGradient::clear_has_end_opacity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LayerGradient::clear_end_opacity() {
  end_opacity_ = 255;
  clear_has_end_opacity();
}
inline ::google::protobuf::int32 LayerGradient::end_opacity() const {
  return end_opacity_;
}
inline void LayerGradient::set_end_opacity(::google::protobuf::int32 value) {
  set_has_end_opacity();
  end_opacity_ = value;
}

// optional float angle = 9 [default = 0];
inline bool LayerGradient::has_angle() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LayerGradient::set_has_angle() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LayerGradient::clear_has_angle() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LayerGradient::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float LayerGradient::angle() const {
  return angle_;
}
inline void LayerGradient::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// -------------------------------------------------------------------

// LabelSystemFont

// optional string font_name = 1 [default = "Helvetica"];
inline bool LabelSystemFont::has_font_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LabelSystemFont::set_has_font_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LabelSystemFont::clear_has_font_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LabelSystemFont::clear_font_name() {
  if (font_name_ != _default_font_name_) {
    font_name_->assign(*_default_font_name_);
  }
  clear_has_font_name();
}
inline const ::std::string& LabelSystemFont::font_name() const {
  return *font_name_;
}
inline void LabelSystemFont::set_font_name(const ::std::string& value) {
  set_has_font_name();
  if (font_name_ == _default_font_name_) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void LabelSystemFont::set_font_name(const char* value) {
  set_has_font_name();
  if (font_name_ == _default_font_name_) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void LabelSystemFont::set_font_name(const char* value, size_t size) {
  set_has_font_name();
  if (font_name_ == _default_font_name_) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LabelSystemFont::mutable_font_name() {
  set_has_font_name();
  if (font_name_ == _default_font_name_) {
    font_name_ = new ::std::string(*_default_font_name_);
  }
  return font_name_;
}
inline ::std::string* LabelSystemFont::release_font_name() {
  clear_has_font_name();
  if (font_name_ == _default_font_name_) {
    return NULL;
  } else {
    ::std::string* temp = font_name_;
    font_name_ = const_cast< ::std::string*>(_default_font_name_);
    return temp;
  }
}
inline void LabelSystemFont::set_allocated_font_name(::std::string* font_name) {
  if (font_name_ != _default_font_name_) {
    delete font_name_;
  }
  if (font_name) {
    set_has_font_name();
    font_name_ = font_name;
  } else {
    clear_has_font_name();
    font_name_ = const_cast< ::std::string*>(_default_font_name_);
  }
}

// optional int32 font_size = 2 [default = 10];
inline bool LabelSystemFont::has_font_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LabelSystemFont::set_has_font_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LabelSystemFont::clear_has_font_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LabelSystemFont::clear_font_size() {
  font_size_ = 10;
  clear_has_font_size();
}
inline ::google::protobuf::int32 LabelSystemFont::font_size() const {
  return font_size_;
}
inline void LabelSystemFont::set_font_size(::google::protobuf::int32 value) {
  set_has_font_size();
  font_size_ = value;
}

// optional string text = 3 [default = "New Label System Font"];
inline bool LabelSystemFont::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LabelSystemFont::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LabelSystemFont::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LabelSystemFont::clear_text() {
  if (text_ != _default_text_) {
    text_->assign(*_default_text_);
  }
  clear_has_text();
}
inline const ::std::string& LabelSystemFont::text() const {
  return *text_;
}
inline void LabelSystemFont::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LabelSystemFont::set_text(const char* value) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LabelSystemFont::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LabelSystemFont::mutable_text() {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string(*_default_text_);
  }
  return text_;
}
inline ::std::string* LabelSystemFont::release_text() {
  clear_has_text();
  if (text_ == _default_text_) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(_default_text_);
    return temp;
  }
}
inline void LabelSystemFont::set_allocated_text(::std::string* text) {
  if (text_ != _default_text_) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(_default_text_);
  }
}

// optional .maker.TEXT_ALIGNMENT_H h_alignment = 4 [default = TEXT_ALIGN_H__CENTER];
inline bool LabelSystemFont::has_h_alignment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LabelSystemFont::set_has_h_alignment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LabelSystemFont::clear_has_h_alignment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LabelSystemFont::clear_h_alignment() {
  h_alignment_ = 1;
  clear_has_h_alignment();
}
inline ::maker::TEXT_ALIGNMENT_H LabelSystemFont::h_alignment() const {
  return static_cast< ::maker::TEXT_ALIGNMENT_H >(h_alignment_);
}
inline void LabelSystemFont::set_h_alignment(::maker::TEXT_ALIGNMENT_H value) {
  assert(::maker::TEXT_ALIGNMENT_H_IsValid(value));
  set_has_h_alignment();
  h_alignment_ = value;
}

// optional .maker.TEXT_ALIGNMENT_V v_alignment = 5 [default = TEXT_ALIGN_V__CENTER];
inline bool LabelSystemFont::has_v_alignment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LabelSystemFont::set_has_v_alignment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LabelSystemFont::clear_has_v_alignment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LabelSystemFont::clear_v_alignment() {
  v_alignment_ = 1;
  clear_has_v_alignment();
}
inline ::maker::TEXT_ALIGNMENT_V LabelSystemFont::v_alignment() const {
  return static_cast< ::maker::TEXT_ALIGNMENT_V >(v_alignment_);
}
inline void LabelSystemFont::set_v_alignment(::maker::TEXT_ALIGNMENT_V value) {
  assert(::maker::TEXT_ALIGNMENT_V_IsValid(value));
  set_has_v_alignment();
  v_alignment_ = value;
}

// optional .maker.COLOR color = 6;
inline bool LabelSystemFont::has_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LabelSystemFont::set_has_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LabelSystemFont::clear_has_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LabelSystemFont::clear_color() {
  if (color_ != NULL) color_->::maker::COLOR::Clear();
  clear_has_color();
}
inline const ::maker::COLOR& LabelSystemFont::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::maker::COLOR* LabelSystemFont::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::maker::COLOR;
  return color_;
}
inline ::maker::COLOR* LabelSystemFont::release_color() {
  clear_has_color();
  ::maker::COLOR* temp = color_;
  color_ = NULL;
  return temp;
}
inline void LabelSystemFont::set_allocated_color(::maker::COLOR* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional int32 opacity = 7 [default = 255];
inline bool LabelSystemFont::has_opacity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LabelSystemFont::set_has_opacity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LabelSystemFont::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LabelSystemFont::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 LabelSystemFont::opacity() const {
  return opacity_;
}
inline void LabelSystemFont::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional int32 dimension_width = 8 [default = 0];
inline bool LabelSystemFont::has_dimension_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LabelSystemFont::set_has_dimension_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LabelSystemFont::clear_has_dimension_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LabelSystemFont::clear_dimension_width() {
  dimension_width_ = 0;
  clear_has_dimension_width();
}
inline ::google::protobuf::int32 LabelSystemFont::dimension_width() const {
  return dimension_width_;
}
inline void LabelSystemFont::set_dimension_width(::google::protobuf::int32 value) {
  set_has_dimension_width();
  dimension_width_ = value;
}

// optional int32 dimension_height = 9 [default = 0];
inline bool LabelSystemFont::has_dimension_height() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LabelSystemFont::set_has_dimension_height() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LabelSystemFont::clear_has_dimension_height() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LabelSystemFont::clear_dimension_height() {
  dimension_height_ = 0;
  clear_has_dimension_height();
}
inline ::google::protobuf::int32 LabelSystemFont::dimension_height() const {
  return dimension_height_;
}
inline void LabelSystemFont::set_dimension_height(::google::protobuf::int32 value) {
  set_has_dimension_height();
  dimension_height_ = value;
}

// optional bool has_shadow = 31 [default = false];
inline bool LabelSystemFont::has_has_shadow() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LabelSystemFont::set_has_has_shadow() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LabelSystemFont::clear_has_has_shadow() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LabelSystemFont::clear_has_shadow() {
  has_shadow_ = false;
  clear_has_has_shadow();
}
inline bool LabelSystemFont::has_shadow() const {
  return has_shadow_;
}
inline void LabelSystemFont::set_has_shadow(bool value) {
  set_has_has_shadow();
  has_shadow_ = value;
}

// optional .maker.COLOR shadow_color = 32;
inline bool LabelSystemFont::has_shadow_color() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LabelSystemFont::set_has_shadow_color() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LabelSystemFont::clear_has_shadow_color() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LabelSystemFont::clear_shadow_color() {
  if (shadow_color_ != NULL) shadow_color_->::maker::COLOR::Clear();
  clear_has_shadow_color();
}
inline const ::maker::COLOR& LabelSystemFont::shadow_color() const {
  return shadow_color_ != NULL ? *shadow_color_ : *default_instance_->shadow_color_;
}
inline ::maker::COLOR* LabelSystemFont::mutable_shadow_color() {
  set_has_shadow_color();
  if (shadow_color_ == NULL) shadow_color_ = new ::maker::COLOR;
  return shadow_color_;
}
inline ::maker::COLOR* LabelSystemFont::release_shadow_color() {
  clear_has_shadow_color();
  ::maker::COLOR* temp = shadow_color_;
  shadow_color_ = NULL;
  return temp;
}
inline void LabelSystemFont::set_allocated_shadow_color(::maker::COLOR* shadow_color) {
  delete shadow_color_;
  shadow_color_ = shadow_color;
  if (shadow_color) {
    set_has_shadow_color();
  } else {
    clear_has_shadow_color();
  }
}

// optional int32 shadow_opacity = 33 [default = 255];
inline bool LabelSystemFont::has_shadow_opacity() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LabelSystemFont::set_has_shadow_opacity() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LabelSystemFont::clear_has_shadow_opacity() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LabelSystemFont::clear_shadow_opacity() {
  shadow_opacity_ = 255;
  clear_has_shadow_opacity();
}
inline ::google::protobuf::int32 LabelSystemFont::shadow_opacity() const {
  return shadow_opacity_;
}
inline void LabelSystemFont::set_shadow_opacity(::google::protobuf::int32 value) {
  set_has_shadow_opacity();
  shadow_opacity_ = value;
}

// optional .maker.SHADOW_DIRECTION shadow_direction = 34 [default = SHADOW_DIR_90];
inline bool LabelSystemFont::has_shadow_direction() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LabelSystemFont::set_has_shadow_direction() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LabelSystemFont::clear_has_shadow_direction() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LabelSystemFont::clear_shadow_direction() {
  shadow_direction_ = 0;
  clear_has_shadow_direction();
}
inline ::maker::SHADOW_DIRECTION LabelSystemFont::shadow_direction() const {
  return static_cast< ::maker::SHADOW_DIRECTION >(shadow_direction_);
}
inline void LabelSystemFont::set_shadow_direction(::maker::SHADOW_DIRECTION value) {
  assert(::maker::SHADOW_DIRECTION_IsValid(value));
  set_has_shadow_direction();
  shadow_direction_ = value;
}

// optional float shadow_distance = 35 [default = 5];
inline bool LabelSystemFont::has_shadow_distance() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LabelSystemFont::set_has_shadow_distance() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LabelSystemFont::clear_has_shadow_distance() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LabelSystemFont::clear_shadow_distance() {
  shadow_distance_ = 5;
  clear_has_shadow_distance();
}
inline float LabelSystemFont::shadow_distance() const {
  return shadow_distance_;
}
inline void LabelSystemFont::set_shadow_distance(float value) {
  set_has_shadow_distance();
  shadow_distance_ = value;
}

// -------------------------------------------------------------------

// LabelTTF

// optional .maker.FILE_TTF font_name = 1;
inline bool LabelTTF::has_font_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LabelTTF::set_has_font_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LabelTTF::clear_has_font_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LabelTTF::clear_font_name() {
  if (font_name_ != NULL) font_name_->::maker::FILE_TTF::Clear();
  clear_has_font_name();
}
inline const ::maker::FILE_TTF& LabelTTF::font_name() const {
  return font_name_ != NULL ? *font_name_ : *default_instance_->font_name_;
}
inline ::maker::FILE_TTF* LabelTTF::mutable_font_name() {
  set_has_font_name();
  if (font_name_ == NULL) font_name_ = new ::maker::FILE_TTF;
  return font_name_;
}
inline ::maker::FILE_TTF* LabelTTF::release_font_name() {
  clear_has_font_name();
  ::maker::FILE_TTF* temp = font_name_;
  font_name_ = NULL;
  return temp;
}
inline void LabelTTF::set_allocated_font_name(::maker::FILE_TTF* font_name) {
  delete font_name_;
  font_name_ = font_name;
  if (font_name) {
    set_has_font_name();
  } else {
    clear_has_font_name();
  }
}

// optional int32 font_size = 2 [default = 10];
inline bool LabelTTF::has_font_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LabelTTF::set_has_font_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LabelTTF::clear_has_font_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LabelTTF::clear_font_size() {
  font_size_ = 10;
  clear_has_font_size();
}
inline ::google::protobuf::int32 LabelTTF::font_size() const {
  return font_size_;
}
inline void LabelTTF::set_font_size(::google::protobuf::int32 value) {
  set_has_font_size();
  font_size_ = value;
}

// optional string text = 3 [default = "New Label TTF"];
inline bool LabelTTF::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LabelTTF::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LabelTTF::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LabelTTF::clear_text() {
  if (text_ != _default_text_) {
    text_->assign(*_default_text_);
  }
  clear_has_text();
}
inline const ::std::string& LabelTTF::text() const {
  return *text_;
}
inline void LabelTTF::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LabelTTF::set_text(const char* value) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LabelTTF::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LabelTTF::mutable_text() {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string(*_default_text_);
  }
  return text_;
}
inline ::std::string* LabelTTF::release_text() {
  clear_has_text();
  if (text_ == _default_text_) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(_default_text_);
    return temp;
  }
}
inline void LabelTTF::set_allocated_text(::std::string* text) {
  if (text_ != _default_text_) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(_default_text_);
  }
}

// optional .maker.TEXT_ALIGNMENT_H h_alignment = 4 [default = TEXT_ALIGN_H__CENTER];
inline bool LabelTTF::has_h_alignment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LabelTTF::set_has_h_alignment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LabelTTF::clear_has_h_alignment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LabelTTF::clear_h_alignment() {
  h_alignment_ = 1;
  clear_has_h_alignment();
}
inline ::maker::TEXT_ALIGNMENT_H LabelTTF::h_alignment() const {
  return static_cast< ::maker::TEXT_ALIGNMENT_H >(h_alignment_);
}
inline void LabelTTF::set_h_alignment(::maker::TEXT_ALIGNMENT_H value) {
  assert(::maker::TEXT_ALIGNMENT_H_IsValid(value));
  set_has_h_alignment();
  h_alignment_ = value;
}

// optional .maker.TEXT_ALIGNMENT_V v_alignment = 5 [default = TEXT_ALIGN_V__CENTER];
inline bool LabelTTF::has_v_alignment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LabelTTF::set_has_v_alignment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LabelTTF::clear_has_v_alignment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LabelTTF::clear_v_alignment() {
  v_alignment_ = 1;
  clear_has_v_alignment();
}
inline ::maker::TEXT_ALIGNMENT_V LabelTTF::v_alignment() const {
  return static_cast< ::maker::TEXT_ALIGNMENT_V >(v_alignment_);
}
inline void LabelTTF::set_v_alignment(::maker::TEXT_ALIGNMENT_V value) {
  assert(::maker::TEXT_ALIGNMENT_V_IsValid(value));
  set_has_v_alignment();
  v_alignment_ = value;
}

// optional .maker.COLOR color = 6;
inline bool LabelTTF::has_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LabelTTF::set_has_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LabelTTF::clear_has_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LabelTTF::clear_color() {
  if (color_ != NULL) color_->::maker::COLOR::Clear();
  clear_has_color();
}
inline const ::maker::COLOR& LabelTTF::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::maker::COLOR* LabelTTF::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::maker::COLOR;
  return color_;
}
inline ::maker::COLOR* LabelTTF::release_color() {
  clear_has_color();
  ::maker::COLOR* temp = color_;
  color_ = NULL;
  return temp;
}
inline void LabelTTF::set_allocated_color(::maker::COLOR* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional int32 opacity = 7 [default = 255];
inline bool LabelTTF::has_opacity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LabelTTF::set_has_opacity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LabelTTF::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LabelTTF::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 LabelTTF::opacity() const {
  return opacity_;
}
inline void LabelTTF::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional int32 dimension_width = 8 [default = 0];
inline bool LabelTTF::has_dimension_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LabelTTF::set_has_dimension_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LabelTTF::clear_has_dimension_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LabelTTF::clear_dimension_width() {
  dimension_width_ = 0;
  clear_has_dimension_width();
}
inline ::google::protobuf::int32 LabelTTF::dimension_width() const {
  return dimension_width_;
}
inline void LabelTTF::set_dimension_width(::google::protobuf::int32 value) {
  set_has_dimension_width();
  dimension_width_ = value;
}

// optional int32 dimension_height = 9 [default = 0];
inline bool LabelTTF::has_dimension_height() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LabelTTF::set_has_dimension_height() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LabelTTF::clear_has_dimension_height() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LabelTTF::clear_dimension_height() {
  dimension_height_ = 0;
  clear_has_dimension_height();
}
inline ::google::protobuf::int32 LabelTTF::dimension_height() const {
  return dimension_height_;
}
inline void LabelTTF::set_dimension_height(::google::protobuf::int32 value) {
  set_has_dimension_height();
  dimension_height_ = value;
}

// optional float letter_spacing = 10 [default = 0];
inline bool LabelTTF::has_letter_spacing() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LabelTTF::set_has_letter_spacing() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LabelTTF::clear_has_letter_spacing() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LabelTTF::clear_letter_spacing() {
  letter_spacing_ = 0;
  clear_has_letter_spacing();
}
inline float LabelTTF::letter_spacing() const {
  return letter_spacing_;
}
inline void LabelTTF::set_letter_spacing(float value) {
  set_has_letter_spacing();
  letter_spacing_ = value;
}

// optional bool has_stroke = 21 [default = false];
inline bool LabelTTF::has_has_stroke() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LabelTTF::set_has_has_stroke() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LabelTTF::clear_has_has_stroke() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LabelTTF::clear_has_stroke() {
  has_stroke_ = false;
  clear_has_has_stroke();
}
inline bool LabelTTF::has_stroke() const {
  return has_stroke_;
}
inline void LabelTTF::set_has_stroke(bool value) {
  set_has_has_stroke();
  has_stroke_ = value;
}

// optional .maker.STROKE_TYPE stroke_type = 22 [default = STROKE_TYPE__NORMAL];
inline bool LabelTTF::has_stroke_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LabelTTF::set_has_stroke_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LabelTTF::clear_has_stroke_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LabelTTF::clear_stroke_type() {
  stroke_type_ = 0;
  clear_has_stroke_type();
}
inline ::maker::STROKE_TYPE LabelTTF::stroke_type() const {
  return static_cast< ::maker::STROKE_TYPE >(stroke_type_);
}
inline void LabelTTF::set_stroke_type(::maker::STROKE_TYPE value) {
  assert(::maker::STROKE_TYPE_IsValid(value));
  set_has_stroke_type();
  stroke_type_ = value;
}

// optional int32 stroke_detail_level = 23 [default = 0];
inline bool LabelTTF::has_stroke_detail_level() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LabelTTF::set_has_stroke_detail_level() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LabelTTF::clear_has_stroke_detail_level() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LabelTTF::clear_stroke_detail_level() {
  stroke_detail_level_ = 0;
  clear_has_stroke_detail_level();
}
inline ::google::protobuf::int32 LabelTTF::stroke_detail_level() const {
  return stroke_detail_level_;
}
inline void LabelTTF::set_stroke_detail_level(::google::protobuf::int32 value) {
  set_has_stroke_detail_level();
  stroke_detail_level_ = value;
}

// optional bool is_sharp_text = 24 [default = true];
inline bool LabelTTF::has_is_sharp_text() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LabelTTF::set_has_is_sharp_text() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LabelTTF::clear_has_is_sharp_text() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LabelTTF::clear_is_sharp_text() {
  is_sharp_text_ = true;
  clear_has_is_sharp_text();
}
inline bool LabelTTF::is_sharp_text() const {
  return is_sharp_text_;
}
inline void LabelTTF::set_is_sharp_text(bool value) {
  set_has_is_sharp_text();
  is_sharp_text_ = value;
}

// optional float stroke_tickness = 25 [default = 1];
inline bool LabelTTF::has_stroke_tickness() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LabelTTF::set_has_stroke_tickness() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LabelTTF::clear_has_stroke_tickness() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LabelTTF::clear_stroke_tickness() {
  stroke_tickness_ = 1;
  clear_has_stroke_tickness();
}
inline float LabelTTF::stroke_tickness() const {
  return stroke_tickness_;
}
inline void LabelTTF::set_stroke_tickness(float value) {
  set_has_stroke_tickness();
  stroke_tickness_ = value;
}

// optional .maker.COLOR stroke_color = 26;
inline bool LabelTTF::has_stroke_color() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LabelTTF::set_has_stroke_color() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LabelTTF::clear_has_stroke_color() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LabelTTF::clear_stroke_color() {
  if (stroke_color_ != NULL) stroke_color_->::maker::COLOR::Clear();
  clear_has_stroke_color();
}
inline const ::maker::COLOR& LabelTTF::stroke_color() const {
  return stroke_color_ != NULL ? *stroke_color_ : *default_instance_->stroke_color_;
}
inline ::maker::COLOR* LabelTTF::mutable_stroke_color() {
  set_has_stroke_color();
  if (stroke_color_ == NULL) stroke_color_ = new ::maker::COLOR;
  return stroke_color_;
}
inline ::maker::COLOR* LabelTTF::release_stroke_color() {
  clear_has_stroke_color();
  ::maker::COLOR* temp = stroke_color_;
  stroke_color_ = NULL;
  return temp;
}
inline void LabelTTF::set_allocated_stroke_color(::maker::COLOR* stroke_color) {
  delete stroke_color_;
  stroke_color_ = stroke_color;
  if (stroke_color) {
    set_has_stroke_color();
  } else {
    clear_has_stroke_color();
  }
}

// optional bool has_shadow = 31 [default = false];
inline bool LabelTTF::has_has_shadow() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LabelTTF::set_has_has_shadow() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LabelTTF::clear_has_has_shadow() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LabelTTF::clear_has_shadow() {
  has_shadow_ = false;
  clear_has_has_shadow();
}
inline bool LabelTTF::has_shadow() const {
  return has_shadow_;
}
inline void LabelTTF::set_has_shadow(bool value) {
  set_has_has_shadow();
  has_shadow_ = value;
}

// optional .maker.COLOR shadow_color = 32;
inline bool LabelTTF::has_shadow_color() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LabelTTF::set_has_shadow_color() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LabelTTF::clear_has_shadow_color() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LabelTTF::clear_shadow_color() {
  if (shadow_color_ != NULL) shadow_color_->::maker::COLOR::Clear();
  clear_has_shadow_color();
}
inline const ::maker::COLOR& LabelTTF::shadow_color() const {
  return shadow_color_ != NULL ? *shadow_color_ : *default_instance_->shadow_color_;
}
inline ::maker::COLOR* LabelTTF::mutable_shadow_color() {
  set_has_shadow_color();
  if (shadow_color_ == NULL) shadow_color_ = new ::maker::COLOR;
  return shadow_color_;
}
inline ::maker::COLOR* LabelTTF::release_shadow_color() {
  clear_has_shadow_color();
  ::maker::COLOR* temp = shadow_color_;
  shadow_color_ = NULL;
  return temp;
}
inline void LabelTTF::set_allocated_shadow_color(::maker::COLOR* shadow_color) {
  delete shadow_color_;
  shadow_color_ = shadow_color;
  if (shadow_color) {
    set_has_shadow_color();
  } else {
    clear_has_shadow_color();
  }
}

// optional int32 shadow_opacity = 33 [default = 255];
inline bool LabelTTF::has_shadow_opacity() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LabelTTF::set_has_shadow_opacity() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LabelTTF::clear_has_shadow_opacity() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LabelTTF::clear_shadow_opacity() {
  shadow_opacity_ = 255;
  clear_has_shadow_opacity();
}
inline ::google::protobuf::int32 LabelTTF::shadow_opacity() const {
  return shadow_opacity_;
}
inline void LabelTTF::set_shadow_opacity(::google::protobuf::int32 value) {
  set_has_shadow_opacity();
  shadow_opacity_ = value;
}

// optional .maker.SHADOW_DIRECTION shadow_direction = 34 [default = SHADOW_DIR_90];
inline bool LabelTTF::has_shadow_direction() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LabelTTF::set_has_shadow_direction() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LabelTTF::clear_has_shadow_direction() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LabelTTF::clear_shadow_direction() {
  shadow_direction_ = 0;
  clear_has_shadow_direction();
}
inline ::maker::SHADOW_DIRECTION LabelTTF::shadow_direction() const {
  return static_cast< ::maker::SHADOW_DIRECTION >(shadow_direction_);
}
inline void LabelTTF::set_shadow_direction(::maker::SHADOW_DIRECTION value) {
  assert(::maker::SHADOW_DIRECTION_IsValid(value));
  set_has_shadow_direction();
  shadow_direction_ = value;
}

// optional float shadow_distance = 35 [default = 5];
inline bool LabelTTF::has_shadow_distance() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LabelTTF::set_has_shadow_distance() {
  _has_bits_[0] |= 0x00100000u;
}
inline void LabelTTF::clear_has_shadow_distance() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void LabelTTF::clear_shadow_distance() {
  shadow_distance_ = 5;
  clear_has_shadow_distance();
}
inline float LabelTTF::shadow_distance() const {
  return shadow_distance_;
}
inline void LabelTTF::set_shadow_distance(float value) {
  set_has_shadow_distance();
  shadow_distance_ = value;
}

// optional bool use_auto_fontsize = 41 [default = false];
inline bool LabelTTF::has_use_auto_fontsize() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LabelTTF::set_has_use_auto_fontsize() {
  _has_bits_[0] |= 0x00200000u;
}
inline void LabelTTF::clear_has_use_auto_fontsize() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void LabelTTF::clear_use_auto_fontsize() {
  use_auto_fontsize_ = false;
  clear_has_use_auto_fontsize();
}
inline bool LabelTTF::use_auto_fontsize() const {
  return use_auto_fontsize_;
}
inline void LabelTTF::set_use_auto_fontsize(bool value) {
  set_has_use_auto_fontsize();
  use_auto_fontsize_ = value;
}

// optional bool has_bold = 42 [default = false];
inline bool LabelTTF::has_has_bold() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void LabelTTF::set_has_has_bold() {
  _has_bits_[0] |= 0x00400000u;
}
inline void LabelTTF::clear_has_has_bold() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void LabelTTF::clear_has_bold() {
  has_bold_ = false;
  clear_has_has_bold();
}
inline bool LabelTTF::has_bold() const {
  return has_bold_;
}
inline void LabelTTF::set_has_bold(bool value) {
  set_has_has_bold();
  has_bold_ = value;
}

// -------------------------------------------------------------------

// LabelBMFont

// optional .maker.FILE_BMFONT font_name = 1;
inline bool LabelBMFont::has_font_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LabelBMFont::set_has_font_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LabelBMFont::clear_has_font_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LabelBMFont::clear_font_name() {
  if (font_name_ != NULL) font_name_->::maker::FILE_BMFONT::Clear();
  clear_has_font_name();
}
inline const ::maker::FILE_BMFONT& LabelBMFont::font_name() const {
  return font_name_ != NULL ? *font_name_ : *default_instance_->font_name_;
}
inline ::maker::FILE_BMFONT* LabelBMFont::mutable_font_name() {
  set_has_font_name();
  if (font_name_ == NULL) font_name_ = new ::maker::FILE_BMFONT;
  return font_name_;
}
inline ::maker::FILE_BMFONT* LabelBMFont::release_font_name() {
  clear_has_font_name();
  ::maker::FILE_BMFONT* temp = font_name_;
  font_name_ = NULL;
  return temp;
}
inline void LabelBMFont::set_allocated_font_name(::maker::FILE_BMFONT* font_name) {
  delete font_name_;
  font_name_ = font_name;
  if (font_name) {
    set_has_font_name();
  } else {
    clear_has_font_name();
  }
}

// optional int32 font_size = 2 [default = 10];
inline bool LabelBMFont::has_font_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LabelBMFont::set_has_font_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LabelBMFont::clear_has_font_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LabelBMFont::clear_font_size() {
  font_size_ = 10;
  clear_has_font_size();
}
inline ::google::protobuf::int32 LabelBMFont::font_size() const {
  return font_size_;
}
inline void LabelBMFont::set_font_size(::google::protobuf::int32 value) {
  set_has_font_size();
  font_size_ = value;
}

// optional string text = 3 [default = "New Label BMFont"];
inline bool LabelBMFont::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LabelBMFont::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LabelBMFont::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LabelBMFont::clear_text() {
  if (text_ != _default_text_) {
    text_->assign(*_default_text_);
  }
  clear_has_text();
}
inline const ::std::string& LabelBMFont::text() const {
  return *text_;
}
inline void LabelBMFont::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LabelBMFont::set_text(const char* value) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LabelBMFont::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LabelBMFont::mutable_text() {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string(*_default_text_);
  }
  return text_;
}
inline ::std::string* LabelBMFont::release_text() {
  clear_has_text();
  if (text_ == _default_text_) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(_default_text_);
    return temp;
  }
}
inline void LabelBMFont::set_allocated_text(::std::string* text) {
  if (text_ != _default_text_) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(_default_text_);
  }
}

// optional .maker.TEXT_ALIGNMENT_H h_alignment = 4 [default = TEXT_ALIGN_H__CENTER];
inline bool LabelBMFont::has_h_alignment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LabelBMFont::set_has_h_alignment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LabelBMFont::clear_has_h_alignment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LabelBMFont::clear_h_alignment() {
  h_alignment_ = 1;
  clear_has_h_alignment();
}
inline ::maker::TEXT_ALIGNMENT_H LabelBMFont::h_alignment() const {
  return static_cast< ::maker::TEXT_ALIGNMENT_H >(h_alignment_);
}
inline void LabelBMFont::set_h_alignment(::maker::TEXT_ALIGNMENT_H value) {
  assert(::maker::TEXT_ALIGNMENT_H_IsValid(value));
  set_has_h_alignment();
  h_alignment_ = value;
}

// optional .maker.TEXT_ALIGNMENT_V v_alignment = 5 [default = TEXT_ALIGN_V__CENTER];
inline bool LabelBMFont::has_v_alignment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LabelBMFont::set_has_v_alignment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LabelBMFont::clear_has_v_alignment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LabelBMFont::clear_v_alignment() {
  v_alignment_ = 1;
  clear_has_v_alignment();
}
inline ::maker::TEXT_ALIGNMENT_V LabelBMFont::v_alignment() const {
  return static_cast< ::maker::TEXT_ALIGNMENT_V >(v_alignment_);
}
inline void LabelBMFont::set_v_alignment(::maker::TEXT_ALIGNMENT_V value) {
  assert(::maker::TEXT_ALIGNMENT_V_IsValid(value));
  set_has_v_alignment();
  v_alignment_ = value;
}

// optional .maker.COLOR color = 6;
inline bool LabelBMFont::has_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LabelBMFont::set_has_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LabelBMFont::clear_has_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LabelBMFont::clear_color() {
  if (color_ != NULL) color_->::maker::COLOR::Clear();
  clear_has_color();
}
inline const ::maker::COLOR& LabelBMFont::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::maker::COLOR* LabelBMFont::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::maker::COLOR;
  return color_;
}
inline ::maker::COLOR* LabelBMFont::release_color() {
  clear_has_color();
  ::maker::COLOR* temp = color_;
  color_ = NULL;
  return temp;
}
inline void LabelBMFont::set_allocated_color(::maker::COLOR* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional int32 opacity = 7 [default = 255];
inline bool LabelBMFont::has_opacity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LabelBMFont::set_has_opacity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LabelBMFont::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LabelBMFont::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 LabelBMFont::opacity() const {
  return opacity_;
}
inline void LabelBMFont::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional int32 dimension_width = 8 [default = 0];
inline bool LabelBMFont::has_dimension_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LabelBMFont::set_has_dimension_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LabelBMFont::clear_has_dimension_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LabelBMFont::clear_dimension_width() {
  dimension_width_ = 0;
  clear_has_dimension_width();
}
inline ::google::protobuf::int32 LabelBMFont::dimension_width() const {
  return dimension_width_;
}
inline void LabelBMFont::set_dimension_width(::google::protobuf::int32 value) {
  set_has_dimension_width();
  dimension_width_ = value;
}

// optional int32 dimension_height = 9 [default = 0];
inline bool LabelBMFont::has_dimension_height() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LabelBMFont::set_has_dimension_height() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LabelBMFont::clear_has_dimension_height() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LabelBMFont::clear_dimension_height() {
  dimension_height_ = 0;
  clear_has_dimension_height();
}
inline ::google::protobuf::int32 LabelBMFont::dimension_height() const {
  return dimension_height_;
}
inline void LabelBMFont::set_dimension_height(::google::protobuf::int32 value) {
  set_has_dimension_height();
  dimension_height_ = value;
}

// -------------------------------------------------------------------

// TextFieldTTF

// optional .maker.FILE_TTF font_name = 1;
inline bool TextFieldTTF::has_font_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextFieldTTF::set_has_font_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextFieldTTF::clear_has_font_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextFieldTTF::clear_font_name() {
  if (font_name_ != NULL) font_name_->::maker::FILE_TTF::Clear();
  clear_has_font_name();
}
inline const ::maker::FILE_TTF& TextFieldTTF::font_name() const {
  return font_name_ != NULL ? *font_name_ : *default_instance_->font_name_;
}
inline ::maker::FILE_TTF* TextFieldTTF::mutable_font_name() {
  set_has_font_name();
  if (font_name_ == NULL) font_name_ = new ::maker::FILE_TTF;
  return font_name_;
}
inline ::maker::FILE_TTF* TextFieldTTF::release_font_name() {
  clear_has_font_name();
  ::maker::FILE_TTF* temp = font_name_;
  font_name_ = NULL;
  return temp;
}
inline void TextFieldTTF::set_allocated_font_name(::maker::FILE_TTF* font_name) {
  delete font_name_;
  font_name_ = font_name;
  if (font_name) {
    set_has_font_name();
  } else {
    clear_has_font_name();
  }
}

// optional int32 font_size = 2 [default = 10];
inline bool TextFieldTTF::has_font_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextFieldTTF::set_has_font_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextFieldTTF::clear_has_font_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextFieldTTF::clear_font_size() {
  font_size_ = 10;
  clear_has_font_size();
}
inline ::google::protobuf::int32 TextFieldTTF::font_size() const {
  return font_size_;
}
inline void TextFieldTTF::set_font_size(::google::protobuf::int32 value) {
  set_has_font_size();
  font_size_ = value;
}

// optional string text = 3 [default = "New TextField"];
inline bool TextFieldTTF::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextFieldTTF::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextFieldTTF::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextFieldTTF::clear_text() {
  if (text_ != _default_text_) {
    text_->assign(*_default_text_);
  }
  clear_has_text();
}
inline const ::std::string& TextFieldTTF::text() const {
  return *text_;
}
inline void TextFieldTTF::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextFieldTTF::set_text(const char* value) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextFieldTTF::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextFieldTTF::mutable_text() {
  set_has_text();
  if (text_ == _default_text_) {
    text_ = new ::std::string(*_default_text_);
  }
  return text_;
}
inline ::std::string* TextFieldTTF::release_text() {
  clear_has_text();
  if (text_ == _default_text_) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(_default_text_);
    return temp;
  }
}
inline void TextFieldTTF::set_allocated_text(::std::string* text) {
  if (text_ != _default_text_) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(_default_text_);
  }
}

// optional .maker.TEXT_ALIGNMENT_H h_alignment = 4 [default = TEXT_ALIGN_H__CENTER];
inline bool TextFieldTTF::has_h_alignment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TextFieldTTF::set_has_h_alignment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TextFieldTTF::clear_has_h_alignment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TextFieldTTF::clear_h_alignment() {
  h_alignment_ = 1;
  clear_has_h_alignment();
}
inline ::maker::TEXT_ALIGNMENT_H TextFieldTTF::h_alignment() const {
  return static_cast< ::maker::TEXT_ALIGNMENT_H >(h_alignment_);
}
inline void TextFieldTTF::set_h_alignment(::maker::TEXT_ALIGNMENT_H value) {
  assert(::maker::TEXT_ALIGNMENT_H_IsValid(value));
  set_has_h_alignment();
  h_alignment_ = value;
}

// optional .maker.TEXT_ALIGNMENT_V v_alignment = 5 [default = TEXT_ALIGN_V__CENTER];
inline bool TextFieldTTF::has_v_alignment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TextFieldTTF::set_has_v_alignment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TextFieldTTF::clear_has_v_alignment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TextFieldTTF::clear_v_alignment() {
  v_alignment_ = 1;
  clear_has_v_alignment();
}
inline ::maker::TEXT_ALIGNMENT_V TextFieldTTF::v_alignment() const {
  return static_cast< ::maker::TEXT_ALIGNMENT_V >(v_alignment_);
}
inline void TextFieldTTF::set_v_alignment(::maker::TEXT_ALIGNMENT_V value) {
  assert(::maker::TEXT_ALIGNMENT_V_IsValid(value));
  set_has_v_alignment();
  v_alignment_ = value;
}

// optional .maker.COLOR color = 6;
inline bool TextFieldTTF::has_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TextFieldTTF::set_has_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TextFieldTTF::clear_has_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TextFieldTTF::clear_color() {
  if (color_ != NULL) color_->::maker::COLOR::Clear();
  clear_has_color();
}
inline const ::maker::COLOR& TextFieldTTF::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::maker::COLOR* TextFieldTTF::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::maker::COLOR;
  return color_;
}
inline ::maker::COLOR* TextFieldTTF::release_color() {
  clear_has_color();
  ::maker::COLOR* temp = color_;
  color_ = NULL;
  return temp;
}
inline void TextFieldTTF::set_allocated_color(::maker::COLOR* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional int32 opacity = 7 [default = 255];
inline bool TextFieldTTF::has_opacity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TextFieldTTF::set_has_opacity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TextFieldTTF::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TextFieldTTF::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 TextFieldTTF::opacity() const {
  return opacity_;
}
inline void TextFieldTTF::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional int32 dimension_width = 8 [default = 0];
inline bool TextFieldTTF::has_dimension_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TextFieldTTF::set_has_dimension_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TextFieldTTF::clear_has_dimension_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TextFieldTTF::clear_dimension_width() {
  dimension_width_ = 0;
  clear_has_dimension_width();
}
inline ::google::protobuf::int32 TextFieldTTF::dimension_width() const {
  return dimension_width_;
}
inline void TextFieldTTF::set_dimension_width(::google::protobuf::int32 value) {
  set_has_dimension_width();
  dimension_width_ = value;
}

// optional int32 dimension_height = 9 [default = 0];
inline bool TextFieldTTF::has_dimension_height() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TextFieldTTF::set_has_dimension_height() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TextFieldTTF::clear_has_dimension_height() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TextFieldTTF::clear_dimension_height() {
  dimension_height_ = 0;
  clear_has_dimension_height();
}
inline ::google::protobuf::int32 TextFieldTTF::dimension_height() const {
  return dimension_height_;
}
inline void TextFieldTTF::set_dimension_height(::google::protobuf::int32 value) {
  set_has_dimension_height();
  dimension_height_ = value;
}

// optional bool has_stroke = 10 [default = false];
inline bool TextFieldTTF::has_has_stroke() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TextFieldTTF::set_has_has_stroke() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TextFieldTTF::clear_has_has_stroke() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TextFieldTTF::clear_has_stroke() {
  has_stroke_ = false;
  clear_has_has_stroke();
}
inline bool TextFieldTTF::has_stroke() const {
  return has_stroke_;
}
inline void TextFieldTTF::set_has_stroke(bool value) {
  set_has_has_stroke();
  has_stroke_ = value;
}

// optional float stroke_tickness = 11 [default = 1];
inline bool TextFieldTTF::has_stroke_tickness() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TextFieldTTF::set_has_stroke_tickness() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TextFieldTTF::clear_has_stroke_tickness() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TextFieldTTF::clear_stroke_tickness() {
  stroke_tickness_ = 1;
  clear_has_stroke_tickness();
}
inline float TextFieldTTF::stroke_tickness() const {
  return stroke_tickness_;
}
inline void TextFieldTTF::set_stroke_tickness(float value) {
  set_has_stroke_tickness();
  stroke_tickness_ = value;
}

// optional .maker.COLOR stroke_color = 12;
inline bool TextFieldTTF::has_stroke_color() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TextFieldTTF::set_has_stroke_color() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TextFieldTTF::clear_has_stroke_color() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TextFieldTTF::clear_stroke_color() {
  if (stroke_color_ != NULL) stroke_color_->::maker::COLOR::Clear();
  clear_has_stroke_color();
}
inline const ::maker::COLOR& TextFieldTTF::stroke_color() const {
  return stroke_color_ != NULL ? *stroke_color_ : *default_instance_->stroke_color_;
}
inline ::maker::COLOR* TextFieldTTF::mutable_stroke_color() {
  set_has_stroke_color();
  if (stroke_color_ == NULL) stroke_color_ = new ::maker::COLOR;
  return stroke_color_;
}
inline ::maker::COLOR* TextFieldTTF::release_stroke_color() {
  clear_has_stroke_color();
  ::maker::COLOR* temp = stroke_color_;
  stroke_color_ = NULL;
  return temp;
}
inline void TextFieldTTF::set_allocated_stroke_color(::maker::COLOR* stroke_color) {
  delete stroke_color_;
  stroke_color_ = stroke_color;
  if (stroke_color) {
    set_has_stroke_color();
  } else {
    clear_has_stroke_color();
  }
}

// -------------------------------------------------------------------

// EditBox

// optional bool enable = 1 [default = false];
inline bool EditBox::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EditBox::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EditBox::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EditBox::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool EditBox::enable() const {
  return enable_;
}
inline void EditBox::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional .maker.EDITBOX_INPUT_MODE input_mode = 2 [default = EDITBOX_INPUT_MODE__SINGLE_LINE];
inline bool EditBox::has_input_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EditBox::set_has_input_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EditBox::clear_has_input_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EditBox::clear_input_mode() {
  input_mode_ = 6;
  clear_has_input_mode();
}
inline ::maker::EDITBOX_INPUT_MODE EditBox::input_mode() const {
  return static_cast< ::maker::EDITBOX_INPUT_MODE >(input_mode_);
}
inline void EditBox::set_input_mode(::maker::EDITBOX_INPUT_MODE value) {
  assert(::maker::EDITBOX_INPUT_MODE_IsValid(value));
  set_has_input_mode();
  input_mode_ = value;
}

// optional .maker.EDITBOX_INPUT_FLAG input_flag = 3 [default = EDITBOX_INPUT_FLAG__INTIAL_CAPS_ALL_CHARACTERS];
inline bool EditBox::has_input_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EditBox::set_has_input_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EditBox::clear_has_input_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EditBox::clear_input_flag() {
  input_flag_ = 4;
  clear_has_input_flag();
}
inline ::maker::EDITBOX_INPUT_FLAG EditBox::input_flag() const {
  return static_cast< ::maker::EDITBOX_INPUT_FLAG >(input_flag_);
}
inline void EditBox::set_input_flag(::maker::EDITBOX_INPUT_FLAG value) {
  assert(::maker::EDITBOX_INPUT_FLAG_IsValid(value));
  set_has_input_flag();
  input_flag_ = value;
}

// optional .maker.EDITBOX_RETURN_TYPE return_type = 4 [default = EDITBOX_RETURN_TYPE__DONE];
inline bool EditBox::has_return_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EditBox::set_has_return_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EditBox::clear_has_return_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EditBox::clear_return_type() {
  return_type_ = 1;
  clear_has_return_type();
}
inline ::maker::EDITBOX_RETURN_TYPE EditBox::return_type() const {
  return static_cast< ::maker::EDITBOX_RETURN_TYPE >(return_type_);
}
inline void EditBox::set_return_type(::maker::EDITBOX_RETURN_TYPE value) {
  assert(::maker::EDITBOX_RETURN_TYPE_IsValid(value));
  set_has_return_type();
  return_type_ = value;
}

// optional int32 max_length = 5 [default = 0];
inline bool EditBox::has_max_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EditBox::set_has_max_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EditBox::clear_has_max_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EditBox::clear_max_length() {
  max_length_ = 0;
  clear_has_max_length();
}
inline ::google::protobuf::int32 EditBox::max_length() const {
  return max_length_;
}
inline void EditBox::set_max_length(::google::protobuf::int32 value) {
  set_has_max_length();
  max_length_ = value;
}

// optional string text = 6 [default = ""];
inline bool EditBox::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EditBox::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EditBox::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EditBox::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& EditBox::text() const {
  return *text_;
}
inline void EditBox::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void EditBox::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void EditBox::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* EditBox::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string font_name = 7 [default = "Helvetica"];
inline bool EditBox::has_font_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EditBox::set_has_font_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EditBox::clear_has_font_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EditBox::clear_font_name() {
  if (font_name_ != _default_font_name_) {
    font_name_->assign(*_default_font_name_);
  }
  clear_has_font_name();
}
inline const ::std::string& EditBox::font_name() const {
  return *font_name_;
}
inline void EditBox::set_font_name(const ::std::string& value) {
  set_has_font_name();
  if (font_name_ == _default_font_name_) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void EditBox::set_font_name(const char* value) {
  set_has_font_name();
  if (font_name_ == _default_font_name_) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void EditBox::set_font_name(const char* value, size_t size) {
  set_has_font_name();
  if (font_name_ == _default_font_name_) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_font_name() {
  set_has_font_name();
  if (font_name_ == _default_font_name_) {
    font_name_ = new ::std::string(*_default_font_name_);
  }
  return font_name_;
}
inline ::std::string* EditBox::release_font_name() {
  clear_has_font_name();
  if (font_name_ == _default_font_name_) {
    return NULL;
  } else {
    ::std::string* temp = font_name_;
    font_name_ = const_cast< ::std::string*>(_default_font_name_);
    return temp;
  }
}
inline void EditBox::set_allocated_font_name(::std::string* font_name) {
  if (font_name_ != _default_font_name_) {
    delete font_name_;
  }
  if (font_name) {
    set_has_font_name();
    font_name_ = font_name;
  } else {
    clear_has_font_name();
    font_name_ = const_cast< ::std::string*>(_default_font_name_);
  }
}

// optional int32 font_size = 8 [default = 20];
inline bool EditBox::has_font_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EditBox::set_has_font_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EditBox::clear_has_font_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EditBox::clear_font_size() {
  font_size_ = 20;
  clear_has_font_size();
}
inline ::google::protobuf::int32 EditBox::font_size() const {
  return font_size_;
}
inline void EditBox::set_font_size(::google::protobuf::int32 value) {
  set_has_font_size();
  font_size_ = value;
}

// optional .maker.COLOR font_color = 9;
inline bool EditBox::has_font_color() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EditBox::set_has_font_color() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EditBox::clear_has_font_color() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EditBox::clear_font_color() {
  if (font_color_ != NULL) font_color_->::maker::COLOR::Clear();
  clear_has_font_color();
}
inline const ::maker::COLOR& EditBox::font_color() const {
  return font_color_ != NULL ? *font_color_ : *default_instance_->font_color_;
}
inline ::maker::COLOR* EditBox::mutable_font_color() {
  set_has_font_color();
  if (font_color_ == NULL) font_color_ = new ::maker::COLOR;
  return font_color_;
}
inline ::maker::COLOR* EditBox::release_font_color() {
  clear_has_font_color();
  ::maker::COLOR* temp = font_color_;
  font_color_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_font_color(::maker::COLOR* font_color) {
  delete font_color_;
  font_color_ = font_color;
  if (font_color) {
    set_has_font_color();
  } else {
    clear_has_font_color();
  }
}

// optional string placeholder = 10 [default = "\355\205\215\354\212\244\355\212\270\353\245\274 \354\236\205\353\240\245\355\225\230\354\204\270\354\232\224."];
inline bool EditBox::has_placeholder() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EditBox::set_has_placeholder() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EditBox::clear_has_placeholder() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EditBox::clear_placeholder() {
  if (placeholder_ != _default_placeholder_) {
    placeholder_->assign(*_default_placeholder_);
  }
  clear_has_placeholder();
}
inline const ::std::string& EditBox::placeholder() const {
  return *placeholder_;
}
inline void EditBox::set_placeholder(const ::std::string& value) {
  set_has_placeholder();
  if (placeholder_ == _default_placeholder_) {
    placeholder_ = new ::std::string;
  }
  placeholder_->assign(value);
}
inline void EditBox::set_placeholder(const char* value) {
  set_has_placeholder();
  if (placeholder_ == _default_placeholder_) {
    placeholder_ = new ::std::string;
  }
  placeholder_->assign(value);
}
inline void EditBox::set_placeholder(const char* value, size_t size) {
  set_has_placeholder();
  if (placeholder_ == _default_placeholder_) {
    placeholder_ = new ::std::string;
  }
  placeholder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_placeholder() {
  set_has_placeholder();
  if (placeholder_ == _default_placeholder_) {
    placeholder_ = new ::std::string(*_default_placeholder_);
  }
  return placeholder_;
}
inline ::std::string* EditBox::release_placeholder() {
  clear_has_placeholder();
  if (placeholder_ == _default_placeholder_) {
    return NULL;
  } else {
    ::std::string* temp = placeholder_;
    placeholder_ = const_cast< ::std::string*>(_default_placeholder_);
    return temp;
  }
}
inline void EditBox::set_allocated_placeholder(::std::string* placeholder) {
  if (placeholder_ != _default_placeholder_) {
    delete placeholder_;
  }
  if (placeholder) {
    set_has_placeholder();
    placeholder_ = placeholder;
  } else {
    clear_has_placeholder();
    placeholder_ = const_cast< ::std::string*>(_default_placeholder_);
  }
}

// optional string placeholder_font_name = 11 [default = "Helvetica"];
inline bool EditBox::has_placeholder_font_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EditBox::set_has_placeholder_font_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EditBox::clear_has_placeholder_font_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EditBox::clear_placeholder_font_name() {
  if (placeholder_font_name_ != _default_placeholder_font_name_) {
    placeholder_font_name_->assign(*_default_placeholder_font_name_);
  }
  clear_has_placeholder_font_name();
}
inline const ::std::string& EditBox::placeholder_font_name() const {
  return *placeholder_font_name_;
}
inline void EditBox::set_placeholder_font_name(const ::std::string& value) {
  set_has_placeholder_font_name();
  if (placeholder_font_name_ == _default_placeholder_font_name_) {
    placeholder_font_name_ = new ::std::string;
  }
  placeholder_font_name_->assign(value);
}
inline void EditBox::set_placeholder_font_name(const char* value) {
  set_has_placeholder_font_name();
  if (placeholder_font_name_ == _default_placeholder_font_name_) {
    placeholder_font_name_ = new ::std::string;
  }
  placeholder_font_name_->assign(value);
}
inline void EditBox::set_placeholder_font_name(const char* value, size_t size) {
  set_has_placeholder_font_name();
  if (placeholder_font_name_ == _default_placeholder_font_name_) {
    placeholder_font_name_ = new ::std::string;
  }
  placeholder_font_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_placeholder_font_name() {
  set_has_placeholder_font_name();
  if (placeholder_font_name_ == _default_placeholder_font_name_) {
    placeholder_font_name_ = new ::std::string(*_default_placeholder_font_name_);
  }
  return placeholder_font_name_;
}
inline ::std::string* EditBox::release_placeholder_font_name() {
  clear_has_placeholder_font_name();
  if (placeholder_font_name_ == _default_placeholder_font_name_) {
    return NULL;
  } else {
    ::std::string* temp = placeholder_font_name_;
    placeholder_font_name_ = const_cast< ::std::string*>(_default_placeholder_font_name_);
    return temp;
  }
}
inline void EditBox::set_allocated_placeholder_font_name(::std::string* placeholder_font_name) {
  if (placeholder_font_name_ != _default_placeholder_font_name_) {
    delete placeholder_font_name_;
  }
  if (placeholder_font_name) {
    set_has_placeholder_font_name();
    placeholder_font_name_ = placeholder_font_name;
  } else {
    clear_has_placeholder_font_name();
    placeholder_font_name_ = const_cast< ::std::string*>(_default_placeholder_font_name_);
  }
}

// optional int32 placeholder_font_size = 12 [default = 20];
inline bool EditBox::has_placeholder_font_size() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EditBox::set_has_placeholder_font_size() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EditBox::clear_has_placeholder_font_size() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EditBox::clear_placeholder_font_size() {
  placeholder_font_size_ = 20;
  clear_has_placeholder_font_size();
}
inline ::google::protobuf::int32 EditBox::placeholder_font_size() const {
  return placeholder_font_size_;
}
inline void EditBox::set_placeholder_font_size(::google::protobuf::int32 value) {
  set_has_placeholder_font_size();
  placeholder_font_size_ = value;
}

// optional .maker.COLOR placeholder_font_color = 13;
inline bool EditBox::has_placeholder_font_color() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EditBox::set_has_placeholder_font_color() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EditBox::clear_has_placeholder_font_color() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EditBox::clear_placeholder_font_color() {
  if (placeholder_font_color_ != NULL) placeholder_font_color_->::maker::COLOR::Clear();
  clear_has_placeholder_font_color();
}
inline const ::maker::COLOR& EditBox::placeholder_font_color() const {
  return placeholder_font_color_ != NULL ? *placeholder_font_color_ : *default_instance_->placeholder_font_color_;
}
inline ::maker::COLOR* EditBox::mutable_placeholder_font_color() {
  set_has_placeholder_font_color();
  if (placeholder_font_color_ == NULL) placeholder_font_color_ = new ::maker::COLOR;
  return placeholder_font_color_;
}
inline ::maker::COLOR* EditBox::release_placeholder_font_color() {
  clear_has_placeholder_font_color();
  ::maker::COLOR* temp = placeholder_font_color_;
  placeholder_font_color_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_placeholder_font_color(::maker::COLOR* placeholder_font_color) {
  delete placeholder_font_color_;
  placeholder_font_color_ = placeholder_font_color;
  if (placeholder_font_color) {
    set_has_placeholder_font_color();
  } else {
    clear_has_placeholder_font_color();
  }
}

// optional .maker.FILE_IMAGE normal_bg = 14;
inline bool EditBox::has_normal_bg() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EditBox::set_has_normal_bg() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EditBox::clear_has_normal_bg() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EditBox::clear_normal_bg() {
  if (normal_bg_ != NULL) normal_bg_->::maker::FILE_IMAGE::Clear();
  clear_has_normal_bg();
}
inline const ::maker::FILE_IMAGE& EditBox::normal_bg() const {
  return normal_bg_ != NULL ? *normal_bg_ : *default_instance_->normal_bg_;
}
inline ::maker::FILE_IMAGE* EditBox::mutable_normal_bg() {
  set_has_normal_bg();
  if (normal_bg_ == NULL) normal_bg_ = new ::maker::FILE_IMAGE;
  return normal_bg_;
}
inline ::maker::FILE_IMAGE* EditBox::release_normal_bg() {
  clear_has_normal_bg();
  ::maker::FILE_IMAGE* temp = normal_bg_;
  normal_bg_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_normal_bg(::maker::FILE_IMAGE* normal_bg) {
  delete normal_bg_;
  normal_bg_ = normal_bg;
  if (normal_bg) {
    set_has_normal_bg();
  } else {
    clear_has_normal_bg();
  }
}

// optional .maker.FILE_IMAGE pressed_bg = 15;
inline bool EditBox::has_pressed_bg() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EditBox::set_has_pressed_bg() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EditBox::clear_has_pressed_bg() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EditBox::clear_pressed_bg() {
  if (pressed_bg_ != NULL) pressed_bg_->::maker::FILE_IMAGE::Clear();
  clear_has_pressed_bg();
}
inline const ::maker::FILE_IMAGE& EditBox::pressed_bg() const {
  return pressed_bg_ != NULL ? *pressed_bg_ : *default_instance_->pressed_bg_;
}
inline ::maker::FILE_IMAGE* EditBox::mutable_pressed_bg() {
  set_has_pressed_bg();
  if (pressed_bg_ == NULL) pressed_bg_ = new ::maker::FILE_IMAGE;
  return pressed_bg_;
}
inline ::maker::FILE_IMAGE* EditBox::release_pressed_bg() {
  clear_has_pressed_bg();
  ::maker::FILE_IMAGE* temp = pressed_bg_;
  pressed_bg_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_pressed_bg(::maker::FILE_IMAGE* pressed_bg) {
  delete pressed_bg_;
  pressed_bg_ = pressed_bg;
  if (pressed_bg) {
    set_has_pressed_bg();
  } else {
    clear_has_pressed_bg();
  }
}

// optional .maker.FILE_IMAGE disabled_bg = 16;
inline bool EditBox::has_disabled_bg() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EditBox::set_has_disabled_bg() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EditBox::clear_has_disabled_bg() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EditBox::clear_disabled_bg() {
  if (disabled_bg_ != NULL) disabled_bg_->::maker::FILE_IMAGE::Clear();
  clear_has_disabled_bg();
}
inline const ::maker::FILE_IMAGE& EditBox::disabled_bg() const {
  return disabled_bg_ != NULL ? *disabled_bg_ : *default_instance_->disabled_bg_;
}
inline ::maker::FILE_IMAGE* EditBox::mutable_disabled_bg() {
  set_has_disabled_bg();
  if (disabled_bg_ == NULL) disabled_bg_ = new ::maker::FILE_IMAGE;
  return disabled_bg_;
}
inline ::maker::FILE_IMAGE* EditBox::release_disabled_bg() {
  clear_has_disabled_bg();
  ::maker::FILE_IMAGE* temp = disabled_bg_;
  disabled_bg_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_disabled_bg(::maker::FILE_IMAGE* disabled_bg) {
  delete disabled_bg_;
  disabled_bg_ = disabled_bg;
  if (disabled_bg) {
    set_has_disabled_bg();
  } else {
    clear_has_disabled_bg();
  }
}

// -------------------------------------------------------------------

// Button

// optional bool enable = 1 [default = true];
inline bool Button::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Button::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Button::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Button::clear_enable() {
  enable_ = true;
  clear_has_enable();
}
inline bool Button::enable() const {
  return enable_;
}
inline void Button::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional .maker.FILE_IMAGE normal = 2;
inline bool Button::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Button::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Button::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Button::clear_normal() {
  if (normal_ != NULL) normal_->::maker::FILE_IMAGE::Clear();
  clear_has_normal();
}
inline const ::maker::FILE_IMAGE& Button::normal() const {
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
inline ::maker::FILE_IMAGE* Button::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) normal_ = new ::maker::FILE_IMAGE;
  return normal_;
}
inline ::maker::FILE_IMAGE* Button::release_normal() {
  clear_has_normal();
  ::maker::FILE_IMAGE* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void Button::set_allocated_normal(::maker::FILE_IMAGE* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
}

// optional .maker.FILE_IMAGE selected = 3;
inline bool Button::has_selected() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Button::set_has_selected() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Button::clear_has_selected() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Button::clear_selected() {
  if (selected_ != NULL) selected_->::maker::FILE_IMAGE::Clear();
  clear_has_selected();
}
inline const ::maker::FILE_IMAGE& Button::selected() const {
  return selected_ != NULL ? *selected_ : *default_instance_->selected_;
}
inline ::maker::FILE_IMAGE* Button::mutable_selected() {
  set_has_selected();
  if (selected_ == NULL) selected_ = new ::maker::FILE_IMAGE;
  return selected_;
}
inline ::maker::FILE_IMAGE* Button::release_selected() {
  clear_has_selected();
  ::maker::FILE_IMAGE* temp = selected_;
  selected_ = NULL;
  return temp;
}
inline void Button::set_allocated_selected(::maker::FILE_IMAGE* selected) {
  delete selected_;
  selected_ = selected;
  if (selected) {
    set_has_selected();
  } else {
    clear_has_selected();
  }
}

// optional .maker.FILE_IMAGE disable = 4;
inline bool Button::has_disable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Button::set_has_disable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Button::clear_has_disable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Button::clear_disable() {
  if (disable_ != NULL) disable_->::maker::FILE_IMAGE::Clear();
  clear_has_disable();
}
inline const ::maker::FILE_IMAGE& Button::disable() const {
  return disable_ != NULL ? *disable_ : *default_instance_->disable_;
}
inline ::maker::FILE_IMAGE* Button::mutable_disable() {
  set_has_disable();
  if (disable_ == NULL) disable_ = new ::maker::FILE_IMAGE;
  return disable_;
}
inline ::maker::FILE_IMAGE* Button::release_disable() {
  clear_has_disable();
  ::maker::FILE_IMAGE* temp = disable_;
  disable_ = NULL;
  return temp;
}
inline void Button::set_allocated_disable(::maker::FILE_IMAGE* disable) {
  delete disable_;
  disable_ = disable;
  if (disable) {
    set_has_disable();
  } else {
    clear_has_disable();
  }
}

// optional .maker.BUTTON_IMAGE_TYPE image_type = 5 [default = BUTTON_IMAGE_TYPE__SPRITE];
inline bool Button::has_image_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Button::set_has_image_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Button::clear_has_image_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Button::clear_image_type() {
  image_type_ = 0;
  clear_has_image_type();
}
inline ::maker::BUTTON_IMAGE_TYPE Button::image_type() const {
  return static_cast< ::maker::BUTTON_IMAGE_TYPE >(image_type_);
}
inline void Button::set_image_type(::maker::BUTTON_IMAGE_TYPE value) {
  assert(::maker::BUTTON_IMAGE_TYPE_IsValid(value));
  set_has_image_type();
  image_type_ = value;
}

// -------------------------------------------------------------------

// Sprite

// optional .maker.FILE_IMAGE file_name = 1;
inline bool Sprite::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sprite::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sprite::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sprite::clear_file_name() {
  if (file_name_ != NULL) file_name_->::maker::FILE_IMAGE::Clear();
  clear_has_file_name();
}
inline const ::maker::FILE_IMAGE& Sprite::file_name() const {
  return file_name_ != NULL ? *file_name_ : *default_instance_->file_name_;
}
inline ::maker::FILE_IMAGE* Sprite::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == NULL) file_name_ = new ::maker::FILE_IMAGE;
  return file_name_;
}
inline ::maker::FILE_IMAGE* Sprite::release_file_name() {
  clear_has_file_name();
  ::maker::FILE_IMAGE* temp = file_name_;
  file_name_ = NULL;
  return temp;
}
inline void Sprite::set_allocated_file_name(::maker::FILE_IMAGE* file_name) {
  delete file_name_;
  file_name_ = file_name;
  if (file_name) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
}

// optional .maker.COLOR color = 2;
inline bool Sprite::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sprite::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sprite::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sprite::clear_color() {
  if (color_ != NULL) color_->::maker::COLOR::Clear();
  clear_has_color();
}
inline const ::maker::COLOR& Sprite::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::maker::COLOR* Sprite::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::maker::COLOR;
  return color_;
}
inline ::maker::COLOR* Sprite::release_color() {
  clear_has_color();
  ::maker::COLOR* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Sprite::set_allocated_color(::maker::COLOR* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional int32 opacity = 3 [default = 255];
inline bool Sprite::has_opacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sprite::set_has_opacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sprite::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sprite::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 Sprite::opacity() const {
  return opacity_;
}
inline void Sprite::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional bool flip_x = 4 [default = false];
inline bool Sprite::has_flip_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sprite::set_has_flip_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Sprite::clear_has_flip_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Sprite::clear_flip_x() {
  flip_x_ = false;
  clear_has_flip_x();
}
inline bool Sprite::flip_x() const {
  return flip_x_;
}
inline void Sprite::set_flip_x(bool value) {
  set_has_flip_x();
  flip_x_ = value;
}

// optional bool flip_y = 5 [default = false];
inline bool Sprite::has_flip_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Sprite::set_has_flip_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Sprite::clear_has_flip_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Sprite::clear_flip_y() {
  flip_y_ = false;
  clear_has_flip_y();
}
inline bool Sprite::flip_y() const {
  return flip_y_;
}
inline void Sprite::set_flip_y(bool value) {
  set_has_flip_y();
  flip_y_ = value;
}

// optional .maker.BLEND_FUNCTION src_blend = 6 [default = BLEND__GL_SRC_ALPHA];
inline bool Sprite::has_src_blend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Sprite::set_has_src_blend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Sprite::clear_has_src_blend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Sprite::clear_src_blend() {
  src_blend_ = 770;
  clear_has_src_blend();
}
inline ::maker::BLEND_FUNCTION Sprite::src_blend() const {
  return static_cast< ::maker::BLEND_FUNCTION >(src_blend_);
}
inline void Sprite::set_src_blend(::maker::BLEND_FUNCTION value) {
  assert(::maker::BLEND_FUNCTION_IsValid(value));
  set_has_src_blend();
  src_blend_ = value;
}

// optional .maker.BLEND_FUNCTION dest_blend = 7 [default = BLEND__GL_ONE_MINUS_SRC_ALPHA];
inline bool Sprite::has_dest_blend() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Sprite::set_has_dest_blend() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Sprite::clear_has_dest_blend() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Sprite::clear_dest_blend() {
  dest_blend_ = 771;
  clear_has_dest_blend();
}
inline ::maker::BLEND_FUNCTION Sprite::dest_blend() const {
  return static_cast< ::maker::BLEND_FUNCTION >(dest_blend_);
}
inline void Sprite::set_dest_blend(::maker::BLEND_FUNCTION value) {
  assert(::maker::BLEND_FUNCTION_IsValid(value));
  set_has_dest_blend();
  dest_blend_ = value;
}

// -------------------------------------------------------------------

// Scale9Sprite

// optional .maker.FILE_IMAGE file_name = 1;
inline bool Scale9Sprite::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scale9Sprite::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scale9Sprite::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scale9Sprite::clear_file_name() {
  if (file_name_ != NULL) file_name_->::maker::FILE_IMAGE::Clear();
  clear_has_file_name();
}
inline const ::maker::FILE_IMAGE& Scale9Sprite::file_name() const {
  return file_name_ != NULL ? *file_name_ : *default_instance_->file_name_;
}
inline ::maker::FILE_IMAGE* Scale9Sprite::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == NULL) file_name_ = new ::maker::FILE_IMAGE;
  return file_name_;
}
inline ::maker::FILE_IMAGE* Scale9Sprite::release_file_name() {
  clear_has_file_name();
  ::maker::FILE_IMAGE* temp = file_name_;
  file_name_ = NULL;
  return temp;
}
inline void Scale9Sprite::set_allocated_file_name(::maker::FILE_IMAGE* file_name) {
  delete file_name_;
  file_name_ = file_name;
  if (file_name) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
}

// optional .maker.COLOR color = 2;
inline bool Scale9Sprite::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Scale9Sprite::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Scale9Sprite::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Scale9Sprite::clear_color() {
  if (color_ != NULL) color_->::maker::COLOR::Clear();
  clear_has_color();
}
inline const ::maker::COLOR& Scale9Sprite::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::maker::COLOR* Scale9Sprite::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::maker::COLOR;
  return color_;
}
inline ::maker::COLOR* Scale9Sprite::release_color() {
  clear_has_color();
  ::maker::COLOR* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Scale9Sprite::set_allocated_color(::maker::COLOR* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional int32 opacity = 3 [default = 255];
inline bool Scale9Sprite::has_opacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Scale9Sprite::set_has_opacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Scale9Sprite::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Scale9Sprite::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 Scale9Sprite::opacity() const {
  return opacity_;
}
inline void Scale9Sprite::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional int32 center_rect_x = 4 [default = 0];
inline bool Scale9Sprite::has_center_rect_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Scale9Sprite::set_has_center_rect_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Scale9Sprite::clear_has_center_rect_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Scale9Sprite::clear_center_rect_x() {
  center_rect_x_ = 0;
  clear_has_center_rect_x();
}
inline ::google::protobuf::int32 Scale9Sprite::center_rect_x() const {
  return center_rect_x_;
}
inline void Scale9Sprite::set_center_rect_x(::google::protobuf::int32 value) {
  set_has_center_rect_x();
  center_rect_x_ = value;
}

// optional int32 center_rect_y = 5 [default = 0];
inline bool Scale9Sprite::has_center_rect_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Scale9Sprite::set_has_center_rect_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Scale9Sprite::clear_has_center_rect_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Scale9Sprite::clear_center_rect_y() {
  center_rect_y_ = 0;
  clear_has_center_rect_y();
}
inline ::google::protobuf::int32 Scale9Sprite::center_rect_y() const {
  return center_rect_y_;
}
inline void Scale9Sprite::set_center_rect_y(::google::protobuf::int32 value) {
  set_has_center_rect_y();
  center_rect_y_ = value;
}

// optional int32 center_rect_width = 6 [default = 0];
inline bool Scale9Sprite::has_center_rect_width() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Scale9Sprite::set_has_center_rect_width() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Scale9Sprite::clear_has_center_rect_width() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Scale9Sprite::clear_center_rect_width() {
  center_rect_width_ = 0;
  clear_has_center_rect_width();
}
inline ::google::protobuf::int32 Scale9Sprite::center_rect_width() const {
  return center_rect_width_;
}
inline void Scale9Sprite::set_center_rect_width(::google::protobuf::int32 value) {
  set_has_center_rect_width();
  center_rect_width_ = value;
}

// optional int32 center_rect_height = 7 [default = 0];
inline bool Scale9Sprite::has_center_rect_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Scale9Sprite::set_has_center_rect_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Scale9Sprite::clear_has_center_rect_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Scale9Sprite::clear_center_rect_height() {
  center_rect_height_ = 0;
  clear_has_center_rect_height();
}
inline ::google::protobuf::int32 Scale9Sprite::center_rect_height() const {
  return center_rect_height_;
}
inline void Scale9Sprite::set_center_rect_height(::google::protobuf::int32 value) {
  set_has_center_rect_height();
  center_rect_height_ = value;
}

// -------------------------------------------------------------------

// TableView

// optional .maker.SCROLL_TYPE scroll = 1 [default = SCROLL__BOTH];
inline bool TableView::has_scroll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableView::set_has_scroll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableView::clear_has_scroll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableView::clear_scroll() {
  scroll_ = 3;
  clear_has_scroll();
}
inline ::maker::SCROLL_TYPE TableView::scroll() const {
  return static_cast< ::maker::SCROLL_TYPE >(scroll_);
}
inline void TableView::set_scroll(::maker::SCROLL_TYPE value) {
  assert(::maker::SCROLL_TYPE_IsValid(value));
  set_has_scroll();
  scroll_ = value;
}

// optional bool bounce = 2 [default = true];
inline bool TableView::has_bounce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableView::set_has_bounce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableView::clear_has_bounce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableView::clear_bounce() {
  bounce_ = true;
  clear_has_bounce();
}
inline bool TableView::bounce() const {
  return bounce_;
}
inline void TableView::set_bounce(bool value) {
  set_has_bounce();
  bounce_ = value;
}

// optional int32 view_width = 3 [default = 200];
inline bool TableView::has_view_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableView::set_has_view_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableView::clear_has_view_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableView::clear_view_width() {
  view_width_ = 200;
  clear_has_view_width();
}
inline ::google::protobuf::int32 TableView::view_width() const {
  return view_width_;
}
inline void TableView::set_view_width(::google::protobuf::int32 value) {
  set_has_view_width();
  view_width_ = value;
}

// optional int32 view_height = 4 [default = 200];
inline bool TableView::has_view_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableView::set_has_view_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableView::clear_has_view_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableView::clear_view_height() {
  view_height_ = 200;
  clear_has_view_height();
}
inline ::google::protobuf::int32 TableView::view_height() const {
  return view_height_;
}
inline void TableView::set_view_height(::google::protobuf::int32 value) {
  set_has_view_height();
  view_height_ = value;
}

// optional int32 cell_width = 5 [default = 60];
inline bool TableView::has_cell_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TableView::set_has_cell_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TableView::clear_has_cell_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TableView::clear_cell_width() {
  cell_width_ = 60;
  clear_has_cell_width();
}
inline ::google::protobuf::int32 TableView::cell_width() const {
  return cell_width_;
}
inline void TableView::set_cell_width(::google::protobuf::int32 value) {
  set_has_cell_width();
  cell_width_ = value;
}

// optional int32 cell_height = 6 [default = 60];
inline bool TableView::has_cell_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TableView::set_has_cell_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TableView::clear_has_cell_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TableView::clear_cell_height() {
  cell_height_ = 60;
  clear_has_cell_height();
}
inline ::google::protobuf::int32 TableView::cell_height() const {
  return cell_height_;
}
inline void TableView::set_cell_height(::google::protobuf::int32 value) {
  set_has_cell_height();
  cell_height_ = value;
}

// -------------------------------------------------------------------

// ProgressTimer

// optional .maker.FILE_IMAGE file_name = 1;
inline bool ProgressTimer::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProgressTimer::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProgressTimer::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProgressTimer::clear_file_name() {
  if (file_name_ != NULL) file_name_->::maker::FILE_IMAGE::Clear();
  clear_has_file_name();
}
inline const ::maker::FILE_IMAGE& ProgressTimer::file_name() const {
  return file_name_ != NULL ? *file_name_ : *default_instance_->file_name_;
}
inline ::maker::FILE_IMAGE* ProgressTimer::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == NULL) file_name_ = new ::maker::FILE_IMAGE;
  return file_name_;
}
inline ::maker::FILE_IMAGE* ProgressTimer::release_file_name() {
  clear_has_file_name();
  ::maker::FILE_IMAGE* temp = file_name_;
  file_name_ = NULL;
  return temp;
}
inline void ProgressTimer::set_allocated_file_name(::maker::FILE_IMAGE* file_name) {
  delete file_name_;
  file_name_ = file_name;
  if (file_name) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
}

// optional .maker.COLOR color = 2;
inline bool ProgressTimer::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProgressTimer::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProgressTimer::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProgressTimer::clear_color() {
  if (color_ != NULL) color_->::maker::COLOR::Clear();
  clear_has_color();
}
inline const ::maker::COLOR& ProgressTimer::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::maker::COLOR* ProgressTimer::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::maker::COLOR;
  return color_;
}
inline ::maker::COLOR* ProgressTimer::release_color() {
  clear_has_color();
  ::maker::COLOR* temp = color_;
  color_ = NULL;
  return temp;
}
inline void ProgressTimer::set_allocated_color(::maker::COLOR* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional int32 opacity = 3 [default = 255];
inline bool ProgressTimer::has_opacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProgressTimer::set_has_opacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProgressTimer::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProgressTimer::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 ProgressTimer::opacity() const {
  return opacity_;
}
inline void ProgressTimer::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional bool flip_x = 4 [default = false];
inline bool ProgressTimer::has_flip_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProgressTimer::set_has_flip_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProgressTimer::clear_has_flip_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProgressTimer::clear_flip_x() {
  flip_x_ = false;
  clear_has_flip_x();
}
inline bool ProgressTimer::flip_x() const {
  return flip_x_;
}
inline void ProgressTimer::set_flip_x(bool value) {
  set_has_flip_x();
  flip_x_ = value;
}

// optional bool flip_y = 5 [default = false];
inline bool ProgressTimer::has_flip_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProgressTimer::set_has_flip_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProgressTimer::clear_has_flip_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProgressTimer::clear_flip_y() {
  flip_y_ = false;
  clear_has_flip_y();
}
inline bool ProgressTimer::flip_y() const {
  return flip_y_;
}
inline void ProgressTimer::set_flip_y(bool value) {
  set_has_flip_y();
  flip_y_ = value;
}

// optional .maker.BLEND_FUNCTION src_blend = 6 [default = BLEND__GL_SRC_ALPHA];
inline bool ProgressTimer::has_src_blend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProgressTimer::set_has_src_blend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProgressTimer::clear_has_src_blend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProgressTimer::clear_src_blend() {
  src_blend_ = 770;
  clear_has_src_blend();
}
inline ::maker::BLEND_FUNCTION ProgressTimer::src_blend() const {
  return static_cast< ::maker::BLEND_FUNCTION >(src_blend_);
}
inline void ProgressTimer::set_src_blend(::maker::BLEND_FUNCTION value) {
  assert(::maker::BLEND_FUNCTION_IsValid(value));
  set_has_src_blend();
  src_blend_ = value;
}

// optional .maker.BLEND_FUNCTION dest_blend = 7 [default = BLEND__GL_ONE_MINUS_SRC_ALPHA];
inline bool ProgressTimer::has_dest_blend() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProgressTimer::set_has_dest_blend() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProgressTimer::clear_has_dest_blend() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProgressTimer::clear_dest_blend() {
  dest_blend_ = 771;
  clear_has_dest_blend();
}
inline ::maker::BLEND_FUNCTION ProgressTimer::dest_blend() const {
  return static_cast< ::maker::BLEND_FUNCTION >(dest_blend_);
}
inline void ProgressTimer::set_dest_blend(::maker::BLEND_FUNCTION value) {
  assert(::maker::BLEND_FUNCTION_IsValid(value));
  set_has_dest_blend();
  dest_blend_ = value;
}

// optional .maker.PROGRESS_TYPE progress_type = 8 [default = PROGRESS__RADIAL_CW];
inline bool ProgressTimer::has_progress_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProgressTimer::set_has_progress_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProgressTimer::clear_has_progress_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProgressTimer::clear_progress_type() {
  progress_type_ = 0;
  clear_has_progress_type();
}
inline ::maker::PROGRESS_TYPE ProgressTimer::progress_type() const {
  return static_cast< ::maker::PROGRESS_TYPE >(progress_type_);
}
inline void ProgressTimer::set_progress_type(::maker::PROGRESS_TYPE value) {
  assert(::maker::PROGRESS_TYPE_IsValid(value));
  set_has_progress_type();
  progress_type_ = value;
}

// optional float mid_point_x = 9 [default = 0.5];
inline bool ProgressTimer::has_mid_point_x() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProgressTimer::set_has_mid_point_x() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProgressTimer::clear_has_mid_point_x() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProgressTimer::clear_mid_point_x() {
  mid_point_x_ = 0.5f;
  clear_has_mid_point_x();
}
inline float ProgressTimer::mid_point_x() const {
  return mid_point_x_;
}
inline void ProgressTimer::set_mid_point_x(float value) {
  set_has_mid_point_x();
  mid_point_x_ = value;
}

// optional float mid_point_y = 10 [default = 0.5];
inline bool ProgressTimer::has_mid_point_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProgressTimer::set_has_mid_point_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProgressTimer::clear_has_mid_point_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProgressTimer::clear_mid_point_y() {
  mid_point_y_ = 0.5f;
  clear_has_mid_point_y();
}
inline float ProgressTimer::mid_point_y() const {
  return mid_point_y_;
}
inline void ProgressTimer::set_mid_point_y(float value) {
  set_has_mid_point_y();
  mid_point_y_ = value;
}

// optional int32 percentage = 11 [default = 75];
inline bool ProgressTimer::has_percentage() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProgressTimer::set_has_percentage() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProgressTimer::clear_has_percentage() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProgressTimer::clear_percentage() {
  percentage_ = 75;
  clear_has_percentage();
}
inline ::google::protobuf::int32 ProgressTimer::percentage() const {
  return percentage_;
}
inline void ProgressTimer::set_percentage(::google::protobuf::int32 value) {
  set_has_percentage();
  percentage_ = value;
}

// -------------------------------------------------------------------

// Visual

// optional .maker.FILE_VISUAL file_name = 1;
inline bool Visual::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Visual::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Visual::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Visual::clear_file_name() {
  if (file_name_ != NULL) file_name_->::maker::FILE_VISUAL::Clear();
  clear_has_file_name();
}
inline const ::maker::FILE_VISUAL& Visual::file_name() const {
  return file_name_ != NULL ? *file_name_ : *default_instance_->file_name_;
}
inline ::maker::FILE_VISUAL* Visual::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == NULL) file_name_ = new ::maker::FILE_VISUAL;
  return file_name_;
}
inline ::maker::FILE_VISUAL* Visual::release_file_name() {
  clear_has_file_name();
  ::maker::FILE_VISUAL* temp = file_name_;
  file_name_ = NULL;
  return temp;
}
inline void Visual::set_allocated_file_name(::maker::FILE_VISUAL* file_name) {
  delete file_name_;
  file_name_ = file_name;
  if (file_name) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
}

// optional bool auto_play = 2 [default = true];
inline bool Visual::has_auto_play() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Visual::set_has_auto_play() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Visual::clear_has_auto_play() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Visual::clear_auto_play() {
  auto_play_ = true;
  clear_has_auto_play();
}
inline bool Visual::auto_play() const {
  return auto_play_;
}
inline void Visual::set_auto_play(bool value) {
  set_has_auto_play();
  auto_play_ = value;
}

// optional bool is_repeat = 3 [default = true];
inline bool Visual::has_is_repeat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Visual::set_has_is_repeat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Visual::clear_has_is_repeat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Visual::clear_is_repeat() {
  is_repeat_ = true;
  clear_has_is_repeat();
}
inline bool Visual::is_repeat() const {
  return is_repeat_;
}
inline void Visual::set_is_repeat(bool value) {
  set_has_is_repeat();
  is_repeat_ = value;
}

// optional .maker.NAME_VISUAL visual_id = 4;
inline bool Visual::has_visual_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Visual::set_has_visual_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Visual::clear_has_visual_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Visual::clear_visual_id() {
  if (visual_id_ != NULL) visual_id_->::maker::NAME_VISUAL::Clear();
  clear_has_visual_id();
}
inline const ::maker::NAME_VISUAL& Visual::visual_id() const {
  return visual_id_ != NULL ? *visual_id_ : *default_instance_->visual_id_;
}
inline ::maker::NAME_VISUAL* Visual::mutable_visual_id() {
  set_has_visual_id();
  if (visual_id_ == NULL) visual_id_ = new ::maker::NAME_VISUAL;
  return visual_id_;
}
inline ::maker::NAME_VISUAL* Visual::release_visual_id() {
  clear_has_visual_id();
  ::maker::NAME_VISUAL* temp = visual_id_;
  visual_id_ = NULL;
  return temp;
}
inline void Visual::set_allocated_visual_id(::maker::NAME_VISUAL* visual_id) {
  delete visual_id_;
  visual_id_ = visual_id;
  if (visual_id) {
    set_has_visual_id();
  } else {
    clear_has_visual_id();
  }
}

// optional .maker.COLOR color = 6;
inline bool Visual::has_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Visual::set_has_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Visual::clear_has_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Visual::clear_color() {
  if (color_ != NULL) color_->::maker::COLOR::Clear();
  clear_has_color();
}
inline const ::maker::COLOR& Visual::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::maker::COLOR* Visual::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::maker::COLOR;
  return color_;
}
inline ::maker::COLOR* Visual::release_color() {
  clear_has_color();
  ::maker::COLOR* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Visual::set_allocated_color(::maker::COLOR* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional int32 opacity = 7 [default = 255];
inline bool Visual::has_opacity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Visual::set_has_opacity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Visual::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Visual::clear_opacity() {
  opacity_ = 255;
  clear_has_opacity();
}
inline ::google::protobuf::int32 Visual::opacity() const {
  return opacity_;
}
inline void Visual::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// -------------------------------------------------------------------

// SocketNode

// optional string socket_name = 1;
inline bool SocketNode::has_socket_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketNode::set_has_socket_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketNode::clear_has_socket_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketNode::clear_socket_name() {
  if (socket_name_ != &::google::protobuf::internal::kEmptyString) {
    socket_name_->clear();
  }
  clear_has_socket_name();
}
inline const ::std::string& SocketNode::socket_name() const {
  return *socket_name_;
}
inline void SocketNode::set_socket_name(const ::std::string& value) {
  set_has_socket_name();
  if (socket_name_ == &::google::protobuf::internal::kEmptyString) {
    socket_name_ = new ::std::string;
  }
  socket_name_->assign(value);
}
inline void SocketNode::set_socket_name(const char* value) {
  set_has_socket_name();
  if (socket_name_ == &::google::protobuf::internal::kEmptyString) {
    socket_name_ = new ::std::string;
  }
  socket_name_->assign(value);
}
inline void SocketNode::set_socket_name(const char* value, size_t size) {
  set_has_socket_name();
  if (socket_name_ == &::google::protobuf::internal::kEmptyString) {
    socket_name_ = new ::std::string;
  }
  socket_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SocketNode::mutable_socket_name() {
  set_has_socket_name();
  if (socket_name_ == &::google::protobuf::internal::kEmptyString) {
    socket_name_ = new ::std::string;
  }
  return socket_name_;
}
inline ::std::string* SocketNode::release_socket_name() {
  clear_has_socket_name();
  if (socket_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = socket_name_;
    socket_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SocketNode::set_allocated_socket_name(::std::string* socket_name) {
  if (socket_name_ != &::google::protobuf::internal::kEmptyString) {
    delete socket_name_;
  }
  if (socket_name) {
    set_has_socket_name();
    socket_name_ = socket_name;
  } else {
    clear_has_socket_name();
    socket_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Particle

// optional .maker.FILE_PLIST file_name = 1;
inline bool Particle::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Particle::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Particle::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Particle::clear_file_name() {
  if (file_name_ != NULL) file_name_->::maker::FILE_PLIST::Clear();
  clear_has_file_name();
}
inline const ::maker::FILE_PLIST& Particle::file_name() const {
  return file_name_ != NULL ? *file_name_ : *default_instance_->file_name_;
}
inline ::maker::FILE_PLIST* Particle::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == NULL) file_name_ = new ::maker::FILE_PLIST;
  return file_name_;
}
inline ::maker::FILE_PLIST* Particle::release_file_name() {
  clear_has_file_name();
  ::maker::FILE_PLIST* temp = file_name_;
  file_name_ = NULL;
  return temp;
}
inline void Particle::set_allocated_file_name(::maker::FILE_PLIST* file_name) {
  delete file_name_;
  file_name_ = file_name;
  if (file_name) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
}

// -------------------------------------------------------------------

// RotatePlate

// optional float radius_x = 1 [default = 100];
inline bool RotatePlate::has_radius_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotatePlate::set_has_radius_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotatePlate::clear_has_radius_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotatePlate::clear_radius_x() {
  radius_x_ = 100;
  clear_has_radius_x();
}
inline float RotatePlate::radius_x() const {
  return radius_x_;
}
inline void RotatePlate::set_radius_x(float value) {
  set_has_radius_x();
  radius_x_ = value;
}

// optional float radius_y = 2 [default = 50];
inline bool RotatePlate::has_radius_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotatePlate::set_has_radius_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotatePlate::clear_has_radius_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotatePlate::clear_radius_y() {
  radius_y_ = 50;
  clear_has_radius_y();
}
inline float RotatePlate::radius_y() const {
  return radius_y_;
}
inline void RotatePlate::set_radius_y(float value) {
  set_has_radius_y();
  radius_y_ = value;
}

// optional float min_scale = 3 [default = 0.5];
inline bool RotatePlate::has_min_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotatePlate::set_has_min_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotatePlate::clear_has_min_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotatePlate::clear_min_scale() {
  min_scale_ = 0.5f;
  clear_has_min_scale();
}
inline float RotatePlate::min_scale() const {
  return min_scale_;
}
inline void RotatePlate::set_min_scale(float value) {
  set_has_min_scale();
  min_scale_ = value;
}

// optional float max_scale = 4 [default = 1];
inline bool RotatePlate::has_max_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotatePlate::set_has_max_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotatePlate::clear_has_max_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotatePlate::clear_max_scale() {
  max_scale_ = 1;
  clear_has_max_scale();
}
inline float RotatePlate::max_scale() const {
  return max_scale_;
}
inline void RotatePlate::set_max_scale(float value) {
  set_has_max_scale();
  max_scale_ = value;
}

// optional .maker.ROTATE_PLATE_ORIGIN_DIR origin_dir = 5 [default = ROTATE_PLATE_ORIGIN_DIR__DOWN];
inline bool RotatePlate::has_origin_dir() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotatePlate::set_has_origin_dir() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotatePlate::clear_has_origin_dir() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotatePlate::clear_origin_dir() {
  origin_dir_ = 0;
  clear_has_origin_dir();
}
inline ::maker::ROTATE_PLATE_ORIGIN_DIR RotatePlate::origin_dir() const {
  return static_cast< ::maker::ROTATE_PLATE_ORIGIN_DIR >(origin_dir_);
}
inline void RotatePlate::set_origin_dir(::maker::ROTATE_PLATE_ORIGIN_DIR value) {
  assert(::maker::ROTATE_PLATE_ORIGIN_DIR_IsValid(value));
  set_has_origin_dir();
  origin_dir_ = value;
}

// -------------------------------------------------------------------

// Properties

// required .maker.ENTITY_TYPE type = 1 [default = ENTITY__Node];
inline bool Properties::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Properties::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Properties::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Properties::clear_type() {
  type_ = 10;
  clear_has_type();
}
inline ::maker::ENTITY_TYPE Properties::type() const {
  return static_cast< ::maker::ENTITY_TYPE >(type_);
}
inline void Properties::set_type(::maker::ENTITY_TYPE value) {
  assert(::maker::ENTITY_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .maker.Node node = 10;
inline bool Properties::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Properties::set_has_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Properties::clear_has_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Properties::clear_node() {
  if (node_ != NULL) node_->::maker::Node::Clear();
  clear_has_node();
}
inline const ::maker::Node& Properties::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::maker::Node* Properties::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::maker::Node;
  return node_;
}
inline ::maker::Node* Properties::release_node() {
  clear_has_node();
  ::maker::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void Properties::set_allocated_node(::maker::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
}

// optional .maker.LayerColor layer_color = 11;
inline bool Properties::has_layer_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Properties::set_has_layer_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Properties::clear_has_layer_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Properties::clear_layer_color() {
  if (layer_color_ != NULL) layer_color_->::maker::LayerColor::Clear();
  clear_has_layer_color();
}
inline const ::maker::LayerColor& Properties::layer_color() const {
  return layer_color_ != NULL ? *layer_color_ : *default_instance_->layer_color_;
}
inline ::maker::LayerColor* Properties::mutable_layer_color() {
  set_has_layer_color();
  if (layer_color_ == NULL) layer_color_ = new ::maker::LayerColor;
  return layer_color_;
}
inline ::maker::LayerColor* Properties::release_layer_color() {
  clear_has_layer_color();
  ::maker::LayerColor* temp = layer_color_;
  layer_color_ = NULL;
  return temp;
}
inline void Properties::set_allocated_layer_color(::maker::LayerColor* layer_color) {
  delete layer_color_;
  layer_color_ = layer_color;
  if (layer_color) {
    set_has_layer_color();
  } else {
    clear_has_layer_color();
  }
}

// optional .maker.LayerGradient layer_gradient = 12;
inline bool Properties::has_layer_gradient() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Properties::set_has_layer_gradient() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Properties::clear_has_layer_gradient() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Properties::clear_layer_gradient() {
  if (layer_gradient_ != NULL) layer_gradient_->::maker::LayerGradient::Clear();
  clear_has_layer_gradient();
}
inline const ::maker::LayerGradient& Properties::layer_gradient() const {
  return layer_gradient_ != NULL ? *layer_gradient_ : *default_instance_->layer_gradient_;
}
inline ::maker::LayerGradient* Properties::mutable_layer_gradient() {
  set_has_layer_gradient();
  if (layer_gradient_ == NULL) layer_gradient_ = new ::maker::LayerGradient;
  return layer_gradient_;
}
inline ::maker::LayerGradient* Properties::release_layer_gradient() {
  clear_has_layer_gradient();
  ::maker::LayerGradient* temp = layer_gradient_;
  layer_gradient_ = NULL;
  return temp;
}
inline void Properties::set_allocated_layer_gradient(::maker::LayerGradient* layer_gradient) {
  delete layer_gradient_;
  layer_gradient_ = layer_gradient;
  if (layer_gradient) {
    set_has_layer_gradient();
  } else {
    clear_has_layer_gradient();
  }
}

// optional .maker.LabelSystemFont label_syatem_font = 13;
inline bool Properties::has_label_syatem_font() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Properties::set_has_label_syatem_font() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Properties::clear_has_label_syatem_font() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Properties::clear_label_syatem_font() {
  if (label_syatem_font_ != NULL) label_syatem_font_->::maker::LabelSystemFont::Clear();
  clear_has_label_syatem_font();
}
inline const ::maker::LabelSystemFont& Properties::label_syatem_font() const {
  return label_syatem_font_ != NULL ? *label_syatem_font_ : *default_instance_->label_syatem_font_;
}
inline ::maker::LabelSystemFont* Properties::mutable_label_syatem_font() {
  set_has_label_syatem_font();
  if (label_syatem_font_ == NULL) label_syatem_font_ = new ::maker::LabelSystemFont;
  return label_syatem_font_;
}
inline ::maker::LabelSystemFont* Properties::release_label_syatem_font() {
  clear_has_label_syatem_font();
  ::maker::LabelSystemFont* temp = label_syatem_font_;
  label_syatem_font_ = NULL;
  return temp;
}
inline void Properties::set_allocated_label_syatem_font(::maker::LabelSystemFont* label_syatem_font) {
  delete label_syatem_font_;
  label_syatem_font_ = label_syatem_font;
  if (label_syatem_font) {
    set_has_label_syatem_font();
  } else {
    clear_has_label_syatem_font();
  }
}

// optional .maker.LabelTTF label_ttf = 14;
inline bool Properties::has_label_ttf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Properties::set_has_label_ttf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Properties::clear_has_label_ttf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Properties::clear_label_ttf() {
  if (label_ttf_ != NULL) label_ttf_->::maker::LabelTTF::Clear();
  clear_has_label_ttf();
}
inline const ::maker::LabelTTF& Properties::label_ttf() const {
  return label_ttf_ != NULL ? *label_ttf_ : *default_instance_->label_ttf_;
}
inline ::maker::LabelTTF* Properties::mutable_label_ttf() {
  set_has_label_ttf();
  if (label_ttf_ == NULL) label_ttf_ = new ::maker::LabelTTF;
  return label_ttf_;
}
inline ::maker::LabelTTF* Properties::release_label_ttf() {
  clear_has_label_ttf();
  ::maker::LabelTTF* temp = label_ttf_;
  label_ttf_ = NULL;
  return temp;
}
inline void Properties::set_allocated_label_ttf(::maker::LabelTTF* label_ttf) {
  delete label_ttf_;
  label_ttf_ = label_ttf;
  if (label_ttf) {
    set_has_label_ttf();
  } else {
    clear_has_label_ttf();
  }
}

// optional .maker.TextFieldTTF text_field_ttf = 15;
inline bool Properties::has_text_field_ttf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Properties::set_has_text_field_ttf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Properties::clear_has_text_field_ttf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Properties::clear_text_field_ttf() {
  if (text_field_ttf_ != NULL) text_field_ttf_->::maker::TextFieldTTF::Clear();
  clear_has_text_field_ttf();
}
inline const ::maker::TextFieldTTF& Properties::text_field_ttf() const {
  return text_field_ttf_ != NULL ? *text_field_ttf_ : *default_instance_->text_field_ttf_;
}
inline ::maker::TextFieldTTF* Properties::mutable_text_field_ttf() {
  set_has_text_field_ttf();
  if (text_field_ttf_ == NULL) text_field_ttf_ = new ::maker::TextFieldTTF;
  return text_field_ttf_;
}
inline ::maker::TextFieldTTF* Properties::release_text_field_ttf() {
  clear_has_text_field_ttf();
  ::maker::TextFieldTTF* temp = text_field_ttf_;
  text_field_ttf_ = NULL;
  return temp;
}
inline void Properties::set_allocated_text_field_ttf(::maker::TextFieldTTF* text_field_ttf) {
  delete text_field_ttf_;
  text_field_ttf_ = text_field_ttf;
  if (text_field_ttf) {
    set_has_text_field_ttf();
  } else {
    clear_has_text_field_ttf();
  }
}

// optional .maker.EditBox edit_box = 16;
inline bool Properties::has_edit_box() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Properties::set_has_edit_box() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Properties::clear_has_edit_box() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Properties::clear_edit_box() {
  if (edit_box_ != NULL) edit_box_->::maker::EditBox::Clear();
  clear_has_edit_box();
}
inline const ::maker::EditBox& Properties::edit_box() const {
  return edit_box_ != NULL ? *edit_box_ : *default_instance_->edit_box_;
}
inline ::maker::EditBox* Properties::mutable_edit_box() {
  set_has_edit_box();
  if (edit_box_ == NULL) edit_box_ = new ::maker::EditBox;
  return edit_box_;
}
inline ::maker::EditBox* Properties::release_edit_box() {
  clear_has_edit_box();
  ::maker::EditBox* temp = edit_box_;
  edit_box_ = NULL;
  return temp;
}
inline void Properties::set_allocated_edit_box(::maker::EditBox* edit_box) {
  delete edit_box_;
  edit_box_ = edit_box;
  if (edit_box) {
    set_has_edit_box();
  } else {
    clear_has_edit_box();
  }
}

// optional .maker.TableView table_view = 17;
inline bool Properties::has_table_view() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Properties::set_has_table_view() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Properties::clear_has_table_view() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Properties::clear_table_view() {
  if (table_view_ != NULL) table_view_->::maker::TableView::Clear();
  clear_has_table_view();
}
inline const ::maker::TableView& Properties::table_view() const {
  return table_view_ != NULL ? *table_view_ : *default_instance_->table_view_;
}
inline ::maker::TableView* Properties::mutable_table_view() {
  set_has_table_view();
  if (table_view_ == NULL) table_view_ = new ::maker::TableView;
  return table_view_;
}
inline ::maker::TableView* Properties::release_table_view() {
  clear_has_table_view();
  ::maker::TableView* temp = table_view_;
  table_view_ = NULL;
  return temp;
}
inline void Properties::set_allocated_table_view(::maker::TableView* table_view) {
  delete table_view_;
  table_view_ = table_view;
  if (table_view) {
    set_has_table_view();
  } else {
    clear_has_table_view();
  }
}

// optional .maker.RotatePlate rotate_plate = 18;
inline bool Properties::has_rotate_plate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Properties::set_has_rotate_plate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Properties::clear_has_rotate_plate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Properties::clear_rotate_plate() {
  if (rotate_plate_ != NULL) rotate_plate_->::maker::RotatePlate::Clear();
  clear_has_rotate_plate();
}
inline const ::maker::RotatePlate& Properties::rotate_plate() const {
  return rotate_plate_ != NULL ? *rotate_plate_ : *default_instance_->rotate_plate_;
}
inline ::maker::RotatePlate* Properties::mutable_rotate_plate() {
  set_has_rotate_plate();
  if (rotate_plate_ == NULL) rotate_plate_ = new ::maker::RotatePlate;
  return rotate_plate_;
}
inline ::maker::RotatePlate* Properties::release_rotate_plate() {
  clear_has_rotate_plate();
  ::maker::RotatePlate* temp = rotate_plate_;
  rotate_plate_ = NULL;
  return temp;
}
inline void Properties::set_allocated_rotate_plate(::maker::RotatePlate* rotate_plate) {
  delete rotate_plate_;
  rotate_plate_ = rotate_plate;
  if (rotate_plate) {
    set_has_rotate_plate();
  } else {
    clear_has_rotate_plate();
  }
}

// optional .maker.Button button = 19;
inline bool Properties::has_button() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Properties::set_has_button() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Properties::clear_has_button() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Properties::clear_button() {
  if (button_ != NULL) button_->::maker::Button::Clear();
  clear_has_button();
}
inline const ::maker::Button& Properties::button() const {
  return button_ != NULL ? *button_ : *default_instance_->button_;
}
inline ::maker::Button* Properties::mutable_button() {
  set_has_button();
  if (button_ == NULL) button_ = new ::maker::Button;
  return button_;
}
inline ::maker::Button* Properties::release_button() {
  clear_has_button();
  ::maker::Button* temp = button_;
  button_ = NULL;
  return temp;
}
inline void Properties::set_allocated_button(::maker::Button* button) {
  delete button_;
  button_ = button;
  if (button) {
    set_has_button();
  } else {
    clear_has_button();
  }
}

// optional .maker.Sprite sprite = 20;
inline bool Properties::has_sprite() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Properties::set_has_sprite() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Properties::clear_has_sprite() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Properties::clear_sprite() {
  if (sprite_ != NULL) sprite_->::maker::Sprite::Clear();
  clear_has_sprite();
}
inline const ::maker::Sprite& Properties::sprite() const {
  return sprite_ != NULL ? *sprite_ : *default_instance_->sprite_;
}
inline ::maker::Sprite* Properties::mutable_sprite() {
  set_has_sprite();
  if (sprite_ == NULL) sprite_ = new ::maker::Sprite;
  return sprite_;
}
inline ::maker::Sprite* Properties::release_sprite() {
  clear_has_sprite();
  ::maker::Sprite* temp = sprite_;
  sprite_ = NULL;
  return temp;
}
inline void Properties::set_allocated_sprite(::maker::Sprite* sprite) {
  delete sprite_;
  sprite_ = sprite;
  if (sprite) {
    set_has_sprite();
  } else {
    clear_has_sprite();
  }
}

// optional .maker.Scale9Sprite scale_9_sprite = 21;
inline bool Properties::has_scale_9_sprite() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Properties::set_has_scale_9_sprite() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Properties::clear_has_scale_9_sprite() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Properties::clear_scale_9_sprite() {
  if (scale_9_sprite_ != NULL) scale_9_sprite_->::maker::Scale9Sprite::Clear();
  clear_has_scale_9_sprite();
}
inline const ::maker::Scale9Sprite& Properties::scale_9_sprite() const {
  return scale_9_sprite_ != NULL ? *scale_9_sprite_ : *default_instance_->scale_9_sprite_;
}
inline ::maker::Scale9Sprite* Properties::mutable_scale_9_sprite() {
  set_has_scale_9_sprite();
  if (scale_9_sprite_ == NULL) scale_9_sprite_ = new ::maker::Scale9Sprite;
  return scale_9_sprite_;
}
inline ::maker::Scale9Sprite* Properties::release_scale_9_sprite() {
  clear_has_scale_9_sprite();
  ::maker::Scale9Sprite* temp = scale_9_sprite_;
  scale_9_sprite_ = NULL;
  return temp;
}
inline void Properties::set_allocated_scale_9_sprite(::maker::Scale9Sprite* scale_9_sprite) {
  delete scale_9_sprite_;
  scale_9_sprite_ = scale_9_sprite;
  if (scale_9_sprite) {
    set_has_scale_9_sprite();
  } else {
    clear_has_scale_9_sprite();
  }
}

// optional .maker.ProgressTimer progress_timer = 22;
inline bool Properties::has_progress_timer() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Properties::set_has_progress_timer() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Properties::clear_has_progress_timer() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Properties::clear_progress_timer() {
  if (progress_timer_ != NULL) progress_timer_->::maker::ProgressTimer::Clear();
  clear_has_progress_timer();
}
inline const ::maker::ProgressTimer& Properties::progress_timer() const {
  return progress_timer_ != NULL ? *progress_timer_ : *default_instance_->progress_timer_;
}
inline ::maker::ProgressTimer* Properties::mutable_progress_timer() {
  set_has_progress_timer();
  if (progress_timer_ == NULL) progress_timer_ = new ::maker::ProgressTimer;
  return progress_timer_;
}
inline ::maker::ProgressTimer* Properties::release_progress_timer() {
  clear_has_progress_timer();
  ::maker::ProgressTimer* temp = progress_timer_;
  progress_timer_ = NULL;
  return temp;
}
inline void Properties::set_allocated_progress_timer(::maker::ProgressTimer* progress_timer) {
  delete progress_timer_;
  progress_timer_ = progress_timer;
  if (progress_timer) {
    set_has_progress_timer();
  } else {
    clear_has_progress_timer();
  }
}

// optional .maker.Visual visual = 23;
inline bool Properties::has_visual() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Properties::set_has_visual() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Properties::clear_has_visual() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Properties::clear_visual() {
  if (visual_ != NULL) visual_->::maker::Visual::Clear();
  clear_has_visual();
}
inline const ::maker::Visual& Properties::visual() const {
  return visual_ != NULL ? *visual_ : *default_instance_->visual_;
}
inline ::maker::Visual* Properties::mutable_visual() {
  set_has_visual();
  if (visual_ == NULL) visual_ = new ::maker::Visual;
  return visual_;
}
inline ::maker::Visual* Properties::release_visual() {
  clear_has_visual();
  ::maker::Visual* temp = visual_;
  visual_ = NULL;
  return temp;
}
inline void Properties::set_allocated_visual(::maker::Visual* visual) {
  delete visual_;
  visual_ = visual;
  if (visual) {
    set_has_visual();
  } else {
    clear_has_visual();
  }
}

// optional .maker.Particle particle = 24;
inline bool Properties::has_particle() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Properties::set_has_particle() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Properties::clear_has_particle() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Properties::clear_particle() {
  if (particle_ != NULL) particle_->::maker::Particle::Clear();
  clear_has_particle();
}
inline const ::maker::Particle& Properties::particle() const {
  return particle_ != NULL ? *particle_ : *default_instance_->particle_;
}
inline ::maker::Particle* Properties::mutable_particle() {
  set_has_particle();
  if (particle_ == NULL) particle_ = new ::maker::Particle;
  return particle_;
}
inline ::maker::Particle* Properties::release_particle() {
  clear_has_particle();
  ::maker::Particle* temp = particle_;
  particle_ = NULL;
  return temp;
}
inline void Properties::set_allocated_particle(::maker::Particle* particle) {
  delete particle_;
  particle_ = particle;
  if (particle) {
    set_has_particle();
  } else {
    clear_has_particle();
  }
}

// optional .maker.ClippingNode clipping_node = 25;
inline bool Properties::has_clipping_node() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Properties::set_has_clipping_node() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Properties::clear_has_clipping_node() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Properties::clear_clipping_node() {
  if (clipping_node_ != NULL) clipping_node_->::maker::ClippingNode::Clear();
  clear_has_clipping_node();
}
inline const ::maker::ClippingNode& Properties::clipping_node() const {
  return clipping_node_ != NULL ? *clipping_node_ : *default_instance_->clipping_node_;
}
inline ::maker::ClippingNode* Properties::mutable_clipping_node() {
  set_has_clipping_node();
  if (clipping_node_ == NULL) clipping_node_ = new ::maker::ClippingNode;
  return clipping_node_;
}
inline ::maker::ClippingNode* Properties::release_clipping_node() {
  clear_has_clipping_node();
  ::maker::ClippingNode* temp = clipping_node_;
  clipping_node_ = NULL;
  return temp;
}
inline void Properties::set_allocated_clipping_node(::maker::ClippingNode* clipping_node) {
  delete clipping_node_;
  clipping_node_ = clipping_node;
  if (clipping_node) {
    set_has_clipping_node();
  } else {
    clear_has_clipping_node();
  }
}

// optional .maker.SocketNode socket_node = 100;
inline bool Properties::has_socket_node() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Properties::set_has_socket_node() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Properties::clear_has_socket_node() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Properties::clear_socket_node() {
  if (socket_node_ != NULL) socket_node_->::maker::SocketNode::Clear();
  clear_has_socket_node();
}
inline const ::maker::SocketNode& Properties::socket_node() const {
  return socket_node_ != NULL ? *socket_node_ : *default_instance_->socket_node_;
}
inline ::maker::SocketNode* Properties::mutable_socket_node() {
  set_has_socket_node();
  if (socket_node_ == NULL) socket_node_ = new ::maker::SocketNode;
  return socket_node_;
}
inline ::maker::SocketNode* Properties::release_socket_node() {
  clear_has_socket_node();
  ::maker::SocketNode* temp = socket_node_;
  socket_node_ = NULL;
  return temp;
}
inline void Properties::set_allocated_socket_node(::maker::SocketNode* socket_node) {
  delete socket_node_;
  socket_node_ = socket_node;
  if (socket_node) {
    set_has_socket_node();
  } else {
    clear_has_socket_node();
  }
}

// -------------------------------------------------------------------

// Entity

// required uint64 id = 1 [default = 0];
inline bool Entity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entity::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Entity::id() const {
  return id_;
}
inline void Entity::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required bool expand = 2 [default = true];
inline bool Entity::has_expand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entity::set_has_expand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entity::clear_has_expand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entity::clear_expand() {
  expand_ = true;
  clear_has_expand();
}
inline bool Entity::expand() const {
  return expand_;
}
inline void Entity::set_expand(bool value) {
  set_has_expand();
  expand_ = value;
}

// optional bool selected = 3 [default = false];
inline bool Entity::has_selected() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entity::set_has_selected() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entity::clear_has_selected() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entity::clear_selected() {
  selected_ = false;
  clear_has_selected();
}
inline bool Entity::selected() const {
  return selected_;
}
inline void Entity::set_selected(bool value) {
  set_has_selected();
  selected_ = value;
}

// optional bool parent_selected = 4 [default = false];
inline bool Entity::has_parent_selected() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Entity::set_has_parent_selected() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Entity::clear_has_parent_selected() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Entity::clear_parent_selected() {
  parent_selected_ = false;
  clear_has_parent_selected();
}
inline bool Entity::parent_selected() const {
  return parent_selected_;
}
inline void Entity::set_parent_selected(bool value) {
  set_has_parent_selected();
  parent_selected_ = value;
}

// optional uint64 parent_id = 6 [default = 0];
inline bool Entity::has_parent_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Entity::set_has_parent_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Entity::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Entity::clear_parent_id() {
  parent_id_ = GOOGLE_ULONGLONG(0);
  clear_has_parent_id();
}
inline ::google::protobuf::uint64 Entity::parent_id() const {
  return parent_id_;
}
inline void Entity::set_parent_id(::google::protobuf::uint64 value) {
  set_has_parent_id();
  parent_id_ = value;
}

// required uint64 prev_id = 7 [default = 0];
inline bool Entity::has_prev_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Entity::set_has_prev_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Entity::clear_has_prev_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Entity::clear_prev_id() {
  prev_id_ = GOOGLE_ULONGLONG(0);
  clear_has_prev_id();
}
inline ::google::protobuf::uint64 Entity::prev_id() const {
  return prev_id_;
}
inline void Entity::set_prev_id(::google::protobuf::uint64 value) {
  set_has_prev_id();
  prev_id_ = value;
}

// optional uint64 dest_id = 8 [default = 0];
inline bool Entity::has_dest_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Entity::set_has_dest_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Entity::clear_has_dest_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Entity::clear_dest_id() {
  dest_id_ = GOOGLE_ULONGLONG(0);
  clear_has_dest_id();
}
inline ::google::protobuf::uint64 Entity::dest_id() const {
  return dest_id_;
}
inline void Entity::set_dest_id(::google::protobuf::uint64 value) {
  set_has_dest_id();
  dest_id_ = value;
}

// optional uint64 dest_parent_id = 9 [default = 0];
inline bool Entity::has_dest_parent_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Entity::set_has_dest_parent_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Entity::clear_has_dest_parent_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Entity::clear_dest_parent_id() {
  dest_parent_id_ = GOOGLE_ULONGLONG(0);
  clear_has_dest_parent_id();
}
inline ::google::protobuf::uint64 Entity::dest_parent_id() const {
  return dest_parent_id_;
}
inline void Entity::set_dest_parent_id(::google::protobuf::uint64 value) {
  set_has_dest_parent_id();
  dest_parent_id_ = value;
}

// optional bool lua_name_duplicated = 10 [default = false];
inline bool Entity::has_lua_name_duplicated() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Entity::set_has_lua_name_duplicated() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Entity::clear_has_lua_name_duplicated() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Entity::clear_lua_name_duplicated() {
  lua_name_duplicated_ = false;
  clear_has_lua_name_duplicated();
}
inline bool Entity::lua_name_duplicated() const {
  return lua_name_duplicated_;
}
inline void Entity::set_lua_name_duplicated(bool value) {
  set_has_lua_name_duplicated();
  lua_name_duplicated_ = value;
}

// optional .maker.Properties properties = 20;
inline bool Entity::has_properties() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Entity::set_has_properties() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Entity::clear_has_properties() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Entity::clear_properties() {
  if (properties_ != NULL) properties_->::maker::Properties::Clear();
  clear_has_properties();
}
inline const ::maker::Properties& Entity::properties() const {
  return properties_ != NULL ? *properties_ : *default_instance_->properties_;
}
inline ::maker::Properties* Entity::mutable_properties() {
  set_has_properties();
  if (properties_ == NULL) properties_ = new ::maker::Properties;
  return properties_;
}
inline ::maker::Properties* Entity::release_properties() {
  clear_has_properties();
  ::maker::Properties* temp = properties_;
  properties_ = NULL;
  return temp;
}
inline void Entity::set_allocated_properties(::maker::Properties* properties) {
  delete properties_;
  properties_ = properties;
  if (properties) {
    set_has_properties();
  } else {
    clear_has_properties();
  }
}

// repeated .maker.Entity children = 30;
inline int Entity::children_size() const {
  return children_.size();
}
inline void Entity::clear_children() {
  children_.Clear();
}
inline const ::maker::Entity& Entity::children(int index) const {
  return children_.Get(index);
}
inline ::maker::Entity* Entity::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::maker::Entity* Entity::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::maker::Entity >&
Entity::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::maker::Entity >*
Entity::mutable_children() {
  return &children_;
}

// -------------------------------------------------------------------

// CMD

// required uint64 id = 1 [default = 0];
inline bool CMD::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 CMD::id() const {
  return id_;
}
inline void CMD::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required .maker.CMD_TYPE type = 2 [default = CMD__Create];
inline bool CMD::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::maker::CMD_TYPE CMD::type() const {
  return static_cast< ::maker::CMD_TYPE >(type_);
}
inline void CMD::set_type(::maker::CMD_TYPE value) {
  assert(::maker::CMD_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 window_x = 10 [default = 0];
inline bool CMD::has_window_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMD::set_has_window_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMD::clear_has_window_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMD::clear_window_x() {
  window_x_ = 0;
  clear_has_window_x();
}
inline ::google::protobuf::int32 CMD::window_x() const {
  return window_x_;
}
inline void CMD::set_window_x(::google::protobuf::int32 value) {
  set_has_window_x();
  window_x_ = value;
}

// optional int32 window_y = 11 [default = 0];
inline bool CMD::has_window_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMD::set_has_window_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMD::clear_has_window_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMD::clear_window_y() {
  window_y_ = 0;
  clear_has_window_y();
}
inline ::google::protobuf::int32 CMD::window_y() const {
  return window_y_;
}
inline void CMD::set_window_y(::google::protobuf::int32 value) {
  set_has_window_y();
  window_y_ = value;
}

// optional .maker.EVENT_TO_TOOL event_id = 14 [default = EVENT__None];
inline bool CMD::has_event_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMD::set_has_event_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMD::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMD::clear_event_id() {
  event_id_ = 1;
  clear_has_event_id();
}
inline ::maker::EVENT_TO_TOOL CMD::event_id() const {
  return static_cast< ::maker::EVENT_TO_TOOL >(event_id_);
}
inline void CMD::set_event_id(::maker::EVENT_TO_TOOL value) {
  assert(::maker::EVENT_TO_TOOL_IsValid(value));
  set_has_event_id();
  event_id_ = value;
}

// optional .maker.EVENT_TO_VIEWER viewer_event_id = 15 [default = VIEWER_EVENT__None];
inline bool CMD::has_viewer_event_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMD::set_has_viewer_event_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMD::clear_has_viewer_event_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMD::clear_viewer_event_id() {
  viewer_event_id_ = 1;
  clear_has_viewer_event_id();
}
inline ::maker::EVENT_TO_VIEWER CMD::viewer_event_id() const {
  return static_cast< ::maker::EVENT_TO_VIEWER >(viewer_event_id_);
}
inline void CMD::set_viewer_event_id(::maker::EVENT_TO_VIEWER value) {
  assert(::maker::EVENT_TO_VIEWER_IsValid(value));
  set_has_viewer_event_id();
  viewer_event_id_ = value;
}

// optional string description = 16 [default = ""];
inline bool CMD::has_description() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMD::set_has_description() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMD::clear_has_description() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMD::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CMD::description() const {
  return *description_;
}
inline void CMD::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CMD::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CMD::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMD::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CMD::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMD::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 update_to_cmd_id = 17 [default = 0];
inline bool CMD::has_update_to_cmd_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMD::set_has_update_to_cmd_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMD::clear_has_update_to_cmd_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMD::clear_update_to_cmd_id() {
  update_to_cmd_id_ = GOOGLE_ULONGLONG(0);
  clear_has_update_to_cmd_id();
}
inline ::google::protobuf::uint64 CMD::update_to_cmd_id() const {
  return update_to_cmd_id_;
}
inline void CMD::set_update_to_cmd_id(::google::protobuf::uint64 value) {
  set_has_update_to_cmd_id();
  update_to_cmd_id_ = value;
}

// optional bool dont_append_history = 18 [default = false];
inline bool CMD::has_dont_append_history() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMD::set_has_dont_append_history() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMD::clear_has_dont_append_history() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMD::clear_dont_append_history() {
  dont_append_history_ = false;
  clear_has_dont_append_history();
}
inline bool CMD::dont_append_history() const {
  return dont_append_history_;
}
inline void CMD::set_dont_append_history(bool value) {
  set_has_dont_append_history();
  dont_append_history_ = value;
}

// optional bool can_merge_prev_cmd = 19 [default = false];
inline bool CMD::has_can_merge_prev_cmd() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMD::set_has_can_merge_prev_cmd() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMD::clear_has_can_merge_prev_cmd() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMD::clear_can_merge_prev_cmd() {
  can_merge_prev_cmd_ = false;
  clear_has_can_merge_prev_cmd();
}
inline bool CMD::can_merge_prev_cmd() const {
  return can_merge_prev_cmd_;
}
inline void CMD::set_can_merge_prev_cmd(bool value) {
  set_has_can_merge_prev_cmd();
  can_merge_prev_cmd_ = value;
}

// repeated .maker.Entity entities = 20;
inline int CMD::entities_size() const {
  return entities_.size();
}
inline void CMD::clear_entities() {
  entities_.Clear();
}
inline const ::maker::Entity& CMD::entities(int index) const {
  return entities_.Get(index);
}
inline ::maker::Entity* CMD::mutable_entities(int index) {
  return entities_.Mutable(index);
}
inline ::maker::Entity* CMD::add_entities() {
  return entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::maker::Entity >&
CMD::entities() const {
  return entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::maker::Entity >*
CMD::mutable_entities() {
  return &entities_;
}

// repeated .maker.Entity backup_entities = 21;
inline int CMD::backup_entities_size() const {
  return backup_entities_.size();
}
inline void CMD::clear_backup_entities() {
  backup_entities_.Clear();
}
inline const ::maker::Entity& CMD::backup_entities(int index) const {
  return backup_entities_.Get(index);
}
inline ::maker::Entity* CMD::mutable_backup_entities(int index) {
  return backup_entities_.Mutable(index);
}
inline ::maker::Entity* CMD::add_backup_entities() {
  return backup_entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::maker::Entity >&
CMD::backup_entities() const {
  return backup_entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::maker::Entity >*
CMD::mutable_backup_entities() {
  return &backup_entities_;
}

// repeated string enum_list = 30;
inline int CMD::enum_list_size() const {
  return enum_list_.size();
}
inline void CMD::clear_enum_list() {
  enum_list_.Clear();
}
inline const ::std::string& CMD::enum_list(int index) const {
  return enum_list_.Get(index);
}
inline ::std::string* CMD::mutable_enum_list(int index) {
  return enum_list_.Mutable(index);
}
inline void CMD::set_enum_list(int index, const ::std::string& value) {
  enum_list_.Mutable(index)->assign(value);
}
inline void CMD::set_enum_list(int index, const char* value) {
  enum_list_.Mutable(index)->assign(value);
}
inline void CMD::set_enum_list(int index, const char* value, size_t size) {
  enum_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMD::add_enum_list() {
  return enum_list_.Add();
}
inline void CMD::add_enum_list(const ::std::string& value) {
  enum_list_.Add()->assign(value);
}
inline void CMD::add_enum_list(const char* value) {
  enum_list_.Add()->assign(value);
}
inline void CMD::add_enum_list(const char* value, size_t size) {
  enum_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMD::enum_list() const {
  return enum_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMD::mutable_enum_list() {
  return &enum_list_;
}

// repeated string socket_node_list = 31;
inline int CMD::socket_node_list_size() const {
  return socket_node_list_.size();
}
inline void CMD::clear_socket_node_list() {
  socket_node_list_.Clear();
}
inline const ::std::string& CMD::socket_node_list(int index) const {
  return socket_node_list_.Get(index);
}
inline ::std::string* CMD::mutable_socket_node_list(int index) {
  return socket_node_list_.Mutable(index);
}
inline void CMD::set_socket_node_list(int index, const ::std::string& value) {
  socket_node_list_.Mutable(index)->assign(value);
}
inline void CMD::set_socket_node_list(int index, const char* value) {
  socket_node_list_.Mutable(index)->assign(value);
}
inline void CMD::set_socket_node_list(int index, const char* value, size_t size) {
  socket_node_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMD::add_socket_node_list() {
  return socket_node_list_.Add();
}
inline void CMD::add_socket_node_list(const ::std::string& value) {
  socket_node_list_.Add()->assign(value);
}
inline void CMD::add_socket_node_list(const char* value) {
  socket_node_list_.Add()->assign(value);
}
inline void CMD::add_socket_node_list(const char* value, size_t size) {
  socket_node_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CMD::socket_node_list() const {
  return socket_node_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CMD::mutable_socket_node_list() {
  return &socket_node_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace maker

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::DOCK_POINT>() {
  return ::maker::DOCK_POINT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::ANCHOR_POINT>() {
  return ::maker::ANCHOR_POINT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::BLEND_FUNCTION>() {
  return ::maker::BLEND_FUNCTION_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::TEXT_ALIGNMENT_H>() {
  return ::maker::TEXT_ALIGNMENT_H_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::TEXT_ALIGNMENT_V>() {
  return ::maker::TEXT_ALIGNMENT_V_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::FILL_TYPE>() {
  return ::maker::FILL_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::PROGRESS_TYPE>() {
  return ::maker::PROGRESS_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::SCROLL_TYPE>() {
  return ::maker::SCROLL_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::PICK_PART>() {
  return ::maker::PICK_PART_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::STROKE_TYPE>() {
  return ::maker::STROKE_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::SHADOW_DIRECTION>() {
  return ::maker::SHADOW_DIRECTION_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::BUTTON_IMAGE_TYPE>() {
  return ::maker::BUTTON_IMAGE_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::EDITBOX_INPUT_MODE>() {
  return ::maker::EDITBOX_INPUT_MODE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::EDITBOX_INPUT_FLAG>() {
  return ::maker::EDITBOX_INPUT_FLAG_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::EDITBOX_RETURN_TYPE>() {
  return ::maker::EDITBOX_RETURN_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::NODE_ACTION_TYPE>() {
  return ::maker::NODE_ACTION_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::ROTATE_PLATE_ORIGIN_DIR>() {
  return ::maker::ROTATE_PLATE_ORIGIN_DIR_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::RELATIVE_SIZE_TYPE>() {
  return ::maker::RELATIVE_SIZE_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::STENCIL_TYPE>() {
  return ::maker::STENCIL_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::SCREEN_UI_TYPE>() {
  return ::maker::SCREEN_UI_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::ENTITY_TYPE>() {
  return ::maker::ENTITY_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::CMD_TYPE>() {
  return ::maker::CMD_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::EVENT_TO_TOOL>() {
  return ::maker::EVENT_TO_TOOL_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maker::EVENT_TO_VIEWER>() {
  return ::maker::EVENT_TO_VIEWER_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_maker_2eproto__INCLUDED
