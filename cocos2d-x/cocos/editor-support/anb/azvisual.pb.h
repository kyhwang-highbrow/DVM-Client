// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: azvisual.proto

#ifndef PROTOBUF_azvisual_2eproto__INCLUDED
#define PROTOBUF_azvisual_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "azmodel.pb.h"
// @@protoc_insertion_point(includes)

namespace azVisual {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_azvisual_2eproto();
void protobuf_AssignDesc_azvisual_2eproto();
void protobuf_ShutdownFile_azvisual_2eproto();

class Key;
class Layer;
class Visual;
class VisualGroup;
class Socket;
class SocketGroup;
class EventShape;
class EventShapeGroup;
class Particle;
class ParticleGroup;
class Font;
class Project;

// ===================================================================

class Key : public ::google::protobuf::Message {
 public:
  Key();
  virtual ~Key();

  Key(const Key& from);

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Key& default_instance();

  void Swap(Key* other);

  // implements Message ----------------------------------------------

  Key* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  // optional float frame = 2;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 2;
  inline float frame() const;
  inline void set_frame(float value);

  // optional bool blank = 3 [default = false];
  inline bool has_blank() const;
  inline void clear_blank();
  static const int kBlankFieldNumber = 3;
  inline bool blank() const;
  inline void set_blank(bool value);

  // optional .azModel.Transform2D transform = 4;
  inline bool has_transform() const;
  inline void clear_transform();
  static const int kTransformFieldNumber = 4;
  inline const ::azModel::Transform2D& transform() const;
  inline ::azModel::Transform2D* mutable_transform();
  inline ::azModel::Transform2D* release_transform();
  inline void set_allocated_transform(::azModel::Transform2D* transform);

  // optional float alpha = 5 [default = 1];
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 5;
  inline float alpha() const;
  inline void set_alpha(float value);

  // optional float color_r = 6 [default = 1];
  inline bool has_color_r() const;
  inline void clear_color_r();
  static const int kColorRFieldNumber = 6;
  inline float color_r() const;
  inline void set_color_r(float value);

  // optional float color_g = 7 [default = 1];
  inline bool has_color_g() const;
  inline void clear_color_g();
  static const int kColorGFieldNumber = 7;
  inline float color_g() const;
  inline void set_color_g(float value);

  // optional float color_b = 8 [default = 1];
  inline bool has_color_b() const;
  inline void clear_color_b();
  static const int kColorBFieldNumber = 8;
  inline float color_b() const;
  inline void set_color_b(float value);

  // optional .azModel.BLEND_MODE blend_mode = 9 [default = ALPHA];
  inline bool has_blend_mode() const;
  inline void clear_blend_mode();
  static const int kBlendModeFieldNumber = 9;
  inline ::azModel::BLEND_MODE blend_mode() const;
  inline void set_blend_mode(::azModel::BLEND_MODE value);

  // optional string refrence_name = 10 [default = ""];
  inline bool has_refrence_name() const;
  inline void clear_refrence_name();
  static const int kRefrenceNameFieldNumber = 10;
  inline const ::std::string& refrence_name() const;
  inline void set_refrence_name(const ::std::string& value);
  inline void set_refrence_name(const char* value);
  inline void set_refrence_name(const char* value, size_t size);
  inline ::std::string* mutable_refrence_name();
  inline ::std::string* release_refrence_name();
  inline void set_allocated_refrence_name(::std::string* refrence_name);

  // optional .azModel.SHAPE_TYPE shape_type = 11 [default = BOX];
  inline bool has_shape_type() const;
  inline void clear_shape_type();
  static const int kShapeTypeFieldNumber = 11;
  inline ::azModel::SHAPE_TYPE shape_type() const;
  inline void set_shape_type(::azModel::SHAPE_TYPE value);

  static const int kTypeFieldNumber = 111;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Key >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.Key)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_blank();
  inline void clear_has_blank();
  inline void set_has_transform();
  inline void clear_has_transform();
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_color_r();
  inline void clear_has_color_r();
  inline void set_has_color_g();
  inline void clear_has_color_g();
  inline void set_has_color_b();
  inline void clear_has_color_b();
  inline void set_has_blend_mode();
  inline void clear_has_blend_mode();
  inline void set_has_refrence_name();
  inline void clear_has_refrence_name();
  inline void set_has_shape_type();
  inline void clear_has_shape_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;
  float frame_;
  bool blank_;
  ::azModel::Transform2D* transform_;
  float alpha_;
  float color_r_;
  float color_g_;
  float color_b_;
  ::std::string* refrence_name_;
  int blend_mode_;
  int shape_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static Key* default_instance_;
};
// -------------------------------------------------------------------

class Layer : public ::google::protobuf::Message {
 public:
  Layer();
  virtual ~Layer();

  Layer(const Layer& from);

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Layer& default_instance();

  void Swap(Layer* other);

  // implements Message ----------------------------------------------

  Layer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Layer& from);
  void MergeFrom(const Layer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  // optional uint64 reference_rtid = 2;
  inline bool has_reference_rtid() const;
  inline void clear_reference_rtid();
  static const int kReferenceRtidFieldNumber = 2;
  inline ::google::protobuf::uint64 reference_rtid() const;
  inline void set_reference_rtid(::google::protobuf::uint64 value);

  // repeated .azVisual.Key key_list = 3;
  inline int key_list_size() const;
  inline void clear_key_list();
  static const int kKeyListFieldNumber = 3;
  inline const ::azVisual::Key& key_list(int index) const;
  inline ::azVisual::Key* mutable_key_list(int index);
  inline ::azVisual::Key* add_key_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Key >&
      key_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::Key >*
      mutable_key_list();

  // repeated .azVisual.Layer layer_list = 4;
  inline int layer_list_size() const;
  inline void clear_layer_list();
  static const int kLayerListFieldNumber = 4;
  inline const ::azVisual::Layer& layer_list(int index) const;
  inline ::azVisual::Layer* mutable_layer_list(int index);
  inline ::azVisual::Layer* add_layer_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Layer >&
      layer_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::Layer >*
      mutable_layer_list();

  static const int kTypeFieldNumber = 112;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Layer >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.Layer)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_reference_rtid();
  inline void clear_has_reference_rtid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;
  ::google::protobuf::uint64 reference_rtid_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::Key > key_list_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::Layer > layer_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static Layer* default_instance_;
};
// -------------------------------------------------------------------

class Visual : public ::google::protobuf::Message {
 public:
  Visual();
  virtual ~Visual();

  Visual(const Visual& from);

  inline Visual& operator=(const Visual& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Visual& default_instance();

  void Swap(Visual* other);

  // implements Message ----------------------------------------------

  Visual* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Visual& from);
  void MergeFrom(const Visual& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  // optional float fps = 2;
  inline bool has_fps() const;
  inline void clear_fps();
  static const int kFpsFieldNumber = 2;
  inline float fps() const;
  inline void set_fps(float value);

  // optional .azVisual.Layer layer = 3;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 3;
  inline const ::azVisual::Layer& layer() const;
  inline ::azVisual::Layer* mutable_layer();
  inline ::azVisual::Layer* release_layer();
  inline void set_allocated_layer(::azVisual::Layer* layer);

  static const int kTypeFieldNumber = 113;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Visual >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.Visual)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_fps();
  inline void clear_has_fps();
  inline void set_has_layer();
  inline void clear_has_layer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;
  ::azVisual::Layer* layer_;
  float fps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static Visual* default_instance_;
};
// -------------------------------------------------------------------

class VisualGroup : public ::google::protobuf::Message {
 public:
  VisualGroup();
  virtual ~VisualGroup();

  VisualGroup(const VisualGroup& from);

  inline VisualGroup& operator=(const VisualGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VisualGroup& default_instance();

  void Swap(VisualGroup* other);

  // implements Message ----------------------------------------------

  VisualGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VisualGroup& from);
  void MergeFrom(const VisualGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  // repeated .azVisual.Visual visual_list = 2;
  inline int visual_list_size() const;
  inline void clear_visual_list();
  static const int kVisualListFieldNumber = 2;
  inline const ::azVisual::Visual& visual_list(int index) const;
  inline ::azVisual::Visual* mutable_visual_list(int index);
  inline ::azVisual::Visual* add_visual_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Visual >&
      visual_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::Visual >*
      mutable_visual_list();

  static const int kTypeFieldNumber = 114;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::VisualGroup >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.VisualGroup)
 private:
  inline void set_has_base();
  inline void clear_has_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::Visual > visual_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static VisualGroup* default_instance_;
};
// -------------------------------------------------------------------

class Socket : public ::google::protobuf::Message {
 public:
  Socket();
  virtual ~Socket();

  Socket(const Socket& from);

  inline Socket& operator=(const Socket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Socket& default_instance();

  void Swap(Socket* other);

  // implements Message ----------------------------------------------

  Socket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Socket& from);
  void MergeFrom(const Socket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  // optional uint64 reference_rtid = 2;
  inline bool has_reference_rtid() const;
  inline void clear_reference_rtid();
  static const int kReferenceRtidFieldNumber = 2;
  inline ::google::protobuf::uint64 reference_rtid() const;
  inline void set_reference_rtid(::google::protobuf::uint64 value);

  static const int kTypeFieldNumber = 121;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Socket >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.Socket)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_reference_rtid();
  inline void clear_has_reference_rtid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;
  ::google::protobuf::uint64 reference_rtid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static Socket* default_instance_;
};
// -------------------------------------------------------------------

class SocketGroup : public ::google::protobuf::Message {
 public:
  SocketGroup();
  virtual ~SocketGroup();

  SocketGroup(const SocketGroup& from);

  inline SocketGroup& operator=(const SocketGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SocketGroup& default_instance();

  void Swap(SocketGroup* other);

  // implements Message ----------------------------------------------

  SocketGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SocketGroup& from);
  void MergeFrom(const SocketGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  // repeated .azVisual.Socket socket_list = 2;
  inline int socket_list_size() const;
  inline void clear_socket_list();
  static const int kSocketListFieldNumber = 2;
  inline const ::azVisual::Socket& socket_list(int index) const;
  inline ::azVisual::Socket* mutable_socket_list(int index);
  inline ::azVisual::Socket* add_socket_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Socket >&
      socket_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::Socket >*
      mutable_socket_list();

  static const int kTypeFieldNumber = 122;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::SocketGroup >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.SocketGroup)
 private:
  inline void set_has_base();
  inline void clear_has_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::Socket > socket_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static SocketGroup* default_instance_;
};
// -------------------------------------------------------------------

class EventShape : public ::google::protobuf::Message {
 public:
  EventShape();
  virtual ~EventShape();

  EventShape(const EventShape& from);

  inline EventShape& operator=(const EventShape& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventShape& default_instance();

  void Swap(EventShape* other);

  // implements Message ----------------------------------------------

  EventShape* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventShape& from);
  void MergeFrom(const EventShape& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  static const int kTypeFieldNumber = 131;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::EventShape >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.EventShape)
 private:
  inline void set_has_base();
  inline void clear_has_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static EventShape* default_instance_;
};
// -------------------------------------------------------------------

class EventShapeGroup : public ::google::protobuf::Message {
 public:
  EventShapeGroup();
  virtual ~EventShapeGroup();

  EventShapeGroup(const EventShapeGroup& from);

  inline EventShapeGroup& operator=(const EventShapeGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventShapeGroup& default_instance();

  void Swap(EventShapeGroup* other);

  // implements Message ----------------------------------------------

  EventShapeGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventShapeGroup& from);
  void MergeFrom(const EventShapeGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  // repeated .azVisual.EventShape event_shape_list = 2;
  inline int event_shape_list_size() const;
  inline void clear_event_shape_list();
  static const int kEventShapeListFieldNumber = 2;
  inline const ::azVisual::EventShape& event_shape_list(int index) const;
  inline ::azVisual::EventShape* mutable_event_shape_list(int index);
  inline ::azVisual::EventShape* add_event_shape_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::EventShape >&
      event_shape_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::EventShape >*
      mutable_event_shape_list();

  static const int kTypeFieldNumber = 132;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::EventShapeGroup >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.EventShapeGroup)
 private:
  inline void set_has_base();
  inline void clear_has_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::EventShape > event_shape_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static EventShapeGroup* default_instance_;
};
// -------------------------------------------------------------------

class Particle : public ::google::protobuf::Message {
 public:
  Particle();
  virtual ~Particle();

  Particle(const Particle& from);

  inline Particle& operator=(const Particle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Particle& default_instance();

  void Swap(Particle* other);

  // implements Message ----------------------------------------------

  Particle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Particle& from);
  void MergeFrom(const Particle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  static const int kTypeFieldNumber = 141;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Particle >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.Particle)
 private:
  inline void set_has_base();
  inline void clear_has_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static Particle* default_instance_;
};
// -------------------------------------------------------------------

class ParticleGroup : public ::google::protobuf::Message {
 public:
  ParticleGroup();
  virtual ~ParticleGroup();

  ParticleGroup(const ParticleGroup& from);

  inline ParticleGroup& operator=(const ParticleGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParticleGroup& default_instance();

  void Swap(ParticleGroup* other);

  // implements Message ----------------------------------------------

  ParticleGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParticleGroup& from);
  void MergeFrom(const ParticleGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  // repeated .azVisual.Particle particle_list = 2;
  inline int particle_list_size() const;
  inline void clear_particle_list();
  static const int kParticleListFieldNumber = 2;
  inline const ::azVisual::Particle& particle_list(int index) const;
  inline ::azVisual::Particle* mutable_particle_list(int index);
  inline ::azVisual::Particle* add_particle_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Particle >&
      particle_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::Particle >*
      mutable_particle_list();

  static const int kTypeFieldNumber = 142;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::ParticleGroup >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.ParticleGroup)
 private:
  inline void set_has_base();
  inline void clear_has_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::Particle > particle_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static ParticleGroup* default_instance_;
};
// -------------------------------------------------------------------

class Font : public ::google::protobuf::Message {
 public:
  Font();
  virtual ~Font();

  Font(const Font& from);

  inline Font& operator=(const Font& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Font& default_instance();

  void Swap(Font* other);

  // implements Message ----------------------------------------------

  Font* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Font& from);
  void MergeFrom(const Font& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  // optional string face = 2;
  inline bool has_face() const;
  inline void clear_face();
  static const int kFaceFieldNumber = 2;
  inline const ::std::string& face() const;
  inline void set_face(const ::std::string& value);
  inline void set_face(const char* value);
  inline void set_face(const char* value, size_t size);
  inline ::std::string* mutable_face();
  inline ::std::string* release_face();
  inline void set_allocated_face(::std::string* face);

  // optional int32 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  static const int kTypeFieldNumber = 151;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::EventShape >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.Font)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_face();
  inline void clear_has_face();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;
  ::std::string* face_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static Font* default_instance_;
};
// -------------------------------------------------------------------

class Project : public ::google::protobuf::Message {
 public:
  Project();
  virtual ~Project();

  Project(const Project& from);

  inline Project& operator=(const Project& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Project& default_instance();

  void Swap(Project* other);

  // implements Message ----------------------------------------------

  Project* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Project& from);
  void MergeFrom(const Project& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .azModel.Base base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::azModel::Base& base() const;
  inline ::azModel::Base* mutable_base();
  inline ::azModel::Base* release_base();
  inline void set_allocated_base(::azModel::Base* base);

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // repeated .azModel.Bitmap bitmap_list = 3;
  inline int bitmap_list_size() const;
  inline void clear_bitmap_list();
  static const int kBitmapListFieldNumber = 3;
  inline const ::azModel::Bitmap& bitmap_list(int index) const;
  inline ::azModel::Bitmap* mutable_bitmap_list(int index);
  inline ::azModel::Bitmap* add_bitmap_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azModel::Bitmap >&
      bitmap_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azModel::Bitmap >*
      mutable_bitmap_list();

  // repeated .azVisual.SocketGroup socket_group_list = 4;
  inline int socket_group_list_size() const;
  inline void clear_socket_group_list();
  static const int kSocketGroupListFieldNumber = 4;
  inline const ::azVisual::SocketGroup& socket_group_list(int index) const;
  inline ::azVisual::SocketGroup* mutable_socket_group_list(int index);
  inline ::azVisual::SocketGroup* add_socket_group_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::SocketGroup >&
      socket_group_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::SocketGroup >*
      mutable_socket_group_list();

  // repeated .azVisual.EventShapeGroup event_shape_group_list = 5;
  inline int event_shape_group_list_size() const;
  inline void clear_event_shape_group_list();
  static const int kEventShapeGroupListFieldNumber = 5;
  inline const ::azVisual::EventShapeGroup& event_shape_group_list(int index) const;
  inline ::azVisual::EventShapeGroup* mutable_event_shape_group_list(int index);
  inline ::azVisual::EventShapeGroup* add_event_shape_group_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::EventShapeGroup >&
      event_shape_group_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::EventShapeGroup >*
      mutable_event_shape_group_list();

  // repeated .azVisual.ParticleGroup particle_group_list = 6;
  inline int particle_group_list_size() const;
  inline void clear_particle_group_list();
  static const int kParticleGroupListFieldNumber = 6;
  inline const ::azVisual::ParticleGroup& particle_group_list(int index) const;
  inline ::azVisual::ParticleGroup* mutable_particle_group_list(int index);
  inline ::azVisual::ParticleGroup* add_particle_group_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::ParticleGroup >&
      particle_group_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::ParticleGroup >*
      mutable_particle_group_list();

  // repeated .azVisual.VisualGroup visual_group_list = 7;
  inline int visual_group_list_size() const;
  inline void clear_visual_group_list();
  static const int kVisualGroupListFieldNumber = 7;
  inline const ::azVisual::VisualGroup& visual_group_list(int index) const;
  inline ::azVisual::VisualGroup* mutable_visual_group_list(int index);
  inline ::azVisual::VisualGroup* add_visual_group_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::VisualGroup >&
      visual_group_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::VisualGroup >*
      mutable_visual_group_list();

  // repeated .azVisual.Font font_list = 8;
  inline int font_list_size() const;
  inline void clear_font_list();
  static const int kFontListFieldNumber = 8;
  inline const ::azVisual::Font& font_list(int index) const;
  inline ::azVisual::Font* mutable_font_list(int index);
  inline ::azVisual::Font* add_font_list();
  inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Font >&
      font_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::azVisual::Font >*
      mutable_font_list();

  // repeated string import_project_list = 9;
  inline int import_project_list_size() const;
  inline void clear_import_project_list();
  static const int kImportProjectListFieldNumber = 9;
  inline const ::std::string& import_project_list(int index) const;
  inline ::std::string* mutable_import_project_list(int index);
  inline void set_import_project_list(int index, const ::std::string& value);
  inline void set_import_project_list(int index, const char* value);
  inline void set_import_project_list(int index, const char* value, size_t size);
  inline ::std::string* add_import_project_list();
  inline void add_import_project_list(const ::std::string& value);
  inline void add_import_project_list(const char* value);
  inline void add_import_project_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& import_project_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_import_project_list();

  static const int kTypeFieldNumber = 199;
  static ::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
      ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Project >, 11, false >
    type;
  // @@protoc_insertion_point(class_scope:azVisual.Project)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::azModel::Base* base_;
  ::std::string* version_;
  ::google::protobuf::RepeatedPtrField< ::azModel::Bitmap > bitmap_list_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::SocketGroup > socket_group_list_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::EventShapeGroup > event_shape_group_list_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::ParticleGroup > particle_group_list_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::VisualGroup > visual_group_list_;
  ::google::protobuf::RepeatedPtrField< ::azVisual::Font > font_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> import_project_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_azvisual_2eproto();
  friend void protobuf_AssignDesc_azvisual_2eproto();
  friend void protobuf_ShutdownFile_azvisual_2eproto();

  void InitAsDefaultInstance();
  static Project* default_instance_;
};
// ===================================================================


// ===================================================================

// Key

// required .azModel.Base base = 1;
inline bool Key::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Key::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Key::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Key::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& Key::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* Key::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* Key::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Key::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional float frame = 2;
inline bool Key::has_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Key::set_has_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Key::clear_has_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Key::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline float Key::frame() const {
  return frame_;
}
inline void Key::set_frame(float value) {
  set_has_frame();
  frame_ = value;
}

// optional bool blank = 3 [default = false];
inline bool Key::has_blank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Key::set_has_blank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Key::clear_has_blank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Key::clear_blank() {
  blank_ = false;
  clear_has_blank();
}
inline bool Key::blank() const {
  return blank_;
}
inline void Key::set_blank(bool value) {
  set_has_blank();
  blank_ = value;
}

// optional .azModel.Transform2D transform = 4;
inline bool Key::has_transform() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Key::set_has_transform() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Key::clear_has_transform() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Key::clear_transform() {
  if (transform_ != NULL) transform_->::azModel::Transform2D::Clear();
  clear_has_transform();
}
inline const ::azModel::Transform2D& Key::transform() const {
  return transform_ != NULL ? *transform_ : *default_instance_->transform_;
}
inline ::azModel::Transform2D* Key::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) transform_ = new ::azModel::Transform2D;
  return transform_;
}
inline ::azModel::Transform2D* Key::release_transform() {
  clear_has_transform();
  ::azModel::Transform2D* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline void Key::set_allocated_transform(::azModel::Transform2D* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    set_has_transform();
  } else {
    clear_has_transform();
  }
}

// optional float alpha = 5 [default = 1];
inline bool Key::has_alpha() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Key::set_has_alpha() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Key::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Key::clear_alpha() {
  alpha_ = 1;
  clear_has_alpha();
}
inline float Key::alpha() const {
  return alpha_;
}
inline void Key::set_alpha(float value) {
  set_has_alpha();
  alpha_ = value;
}

// optional float color_r = 6 [default = 1];
inline bool Key::has_color_r() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Key::set_has_color_r() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Key::clear_has_color_r() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Key::clear_color_r() {
  color_r_ = 1;
  clear_has_color_r();
}
inline float Key::color_r() const {
  return color_r_;
}
inline void Key::set_color_r(float value) {
  set_has_color_r();
  color_r_ = value;
}

// optional float color_g = 7 [default = 1];
inline bool Key::has_color_g() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Key::set_has_color_g() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Key::clear_has_color_g() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Key::clear_color_g() {
  color_g_ = 1;
  clear_has_color_g();
}
inline float Key::color_g() const {
  return color_g_;
}
inline void Key::set_color_g(float value) {
  set_has_color_g();
  color_g_ = value;
}

// optional float color_b = 8 [default = 1];
inline bool Key::has_color_b() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Key::set_has_color_b() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Key::clear_has_color_b() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Key::clear_color_b() {
  color_b_ = 1;
  clear_has_color_b();
}
inline float Key::color_b() const {
  return color_b_;
}
inline void Key::set_color_b(float value) {
  set_has_color_b();
  color_b_ = value;
}

// optional .azModel.BLEND_MODE blend_mode = 9 [default = ALPHA];
inline bool Key::has_blend_mode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Key::set_has_blend_mode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Key::clear_has_blend_mode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Key::clear_blend_mode() {
  blend_mode_ = 1;
  clear_has_blend_mode();
}
inline ::azModel::BLEND_MODE Key::blend_mode() const {
  return static_cast< ::azModel::BLEND_MODE >(blend_mode_);
}
inline void Key::set_blend_mode(::azModel::BLEND_MODE value) {
  assert(::azModel::BLEND_MODE_IsValid(value));
  set_has_blend_mode();
  blend_mode_ = value;
}

// optional string refrence_name = 10 [default = ""];
inline bool Key::has_refrence_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Key::set_has_refrence_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Key::clear_has_refrence_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Key::clear_refrence_name() {
  if (refrence_name_ != &::google::protobuf::internal::kEmptyString) {
    refrence_name_->clear();
  }
  clear_has_refrence_name();
}
inline const ::std::string& Key::refrence_name() const {
  return *refrence_name_;
}
inline void Key::set_refrence_name(const ::std::string& value) {
  set_has_refrence_name();
  if (refrence_name_ == &::google::protobuf::internal::kEmptyString) {
    refrence_name_ = new ::std::string;
  }
  refrence_name_->assign(value);
}
inline void Key::set_refrence_name(const char* value) {
  set_has_refrence_name();
  if (refrence_name_ == &::google::protobuf::internal::kEmptyString) {
    refrence_name_ = new ::std::string;
  }
  refrence_name_->assign(value);
}
inline void Key::set_refrence_name(const char* value, size_t size) {
  set_has_refrence_name();
  if (refrence_name_ == &::google::protobuf::internal::kEmptyString) {
    refrence_name_ = new ::std::string;
  }
  refrence_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_refrence_name() {
  set_has_refrence_name();
  if (refrence_name_ == &::google::protobuf::internal::kEmptyString) {
    refrence_name_ = new ::std::string;
  }
  return refrence_name_;
}
inline ::std::string* Key::release_refrence_name() {
  clear_has_refrence_name();
  if (refrence_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = refrence_name_;
    refrence_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Key::set_allocated_refrence_name(::std::string* refrence_name) {
  if (refrence_name_ != &::google::protobuf::internal::kEmptyString) {
    delete refrence_name_;
  }
  if (refrence_name) {
    set_has_refrence_name();
    refrence_name_ = refrence_name;
  } else {
    clear_has_refrence_name();
    refrence_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .azModel.SHAPE_TYPE shape_type = 11 [default = BOX];
inline bool Key::has_shape_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Key::set_has_shape_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Key::clear_has_shape_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Key::clear_shape_type() {
  shape_type_ = 0;
  clear_has_shape_type();
}
inline ::azModel::SHAPE_TYPE Key::shape_type() const {
  return static_cast< ::azModel::SHAPE_TYPE >(shape_type_);
}
inline void Key::set_shape_type(::azModel::SHAPE_TYPE value) {
  assert(::azModel::SHAPE_TYPE_IsValid(value));
  set_has_shape_type();
  shape_type_ = value;
}

// -------------------------------------------------------------------

// Layer

// required .azModel.Base base = 1;
inline bool Layer::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Layer::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Layer::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Layer::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& Layer::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* Layer::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* Layer::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Layer::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional uint64 reference_rtid = 2;
inline bool Layer::has_reference_rtid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Layer::set_has_reference_rtid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Layer::clear_has_reference_rtid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Layer::clear_reference_rtid() {
  reference_rtid_ = GOOGLE_ULONGLONG(0);
  clear_has_reference_rtid();
}
inline ::google::protobuf::uint64 Layer::reference_rtid() const {
  return reference_rtid_;
}
inline void Layer::set_reference_rtid(::google::protobuf::uint64 value) {
  set_has_reference_rtid();
  reference_rtid_ = value;
}

// repeated .azVisual.Key key_list = 3;
inline int Layer::key_list_size() const {
  return key_list_.size();
}
inline void Layer::clear_key_list() {
  key_list_.Clear();
}
inline const ::azVisual::Key& Layer::key_list(int index) const {
  return key_list_.Get(index);
}
inline ::azVisual::Key* Layer::mutable_key_list(int index) {
  return key_list_.Mutable(index);
}
inline ::azVisual::Key* Layer::add_key_list() {
  return key_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Key >&
Layer::key_list() const {
  return key_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::Key >*
Layer::mutable_key_list() {
  return &key_list_;
}

// repeated .azVisual.Layer layer_list = 4;
inline int Layer::layer_list_size() const {
  return layer_list_.size();
}
inline void Layer::clear_layer_list() {
  layer_list_.Clear();
}
inline const ::azVisual::Layer& Layer::layer_list(int index) const {
  return layer_list_.Get(index);
}
inline ::azVisual::Layer* Layer::mutable_layer_list(int index) {
  return layer_list_.Mutable(index);
}
inline ::azVisual::Layer* Layer::add_layer_list() {
  return layer_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Layer >&
Layer::layer_list() const {
  return layer_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::Layer >*
Layer::mutable_layer_list() {
  return &layer_list_;
}

// -------------------------------------------------------------------

// Visual

// required .azModel.Base base = 1;
inline bool Visual::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Visual::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Visual::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Visual::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& Visual::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* Visual::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* Visual::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Visual::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional float fps = 2;
inline bool Visual::has_fps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Visual::set_has_fps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Visual::clear_has_fps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Visual::clear_fps() {
  fps_ = 0;
  clear_has_fps();
}
inline float Visual::fps() const {
  return fps_;
}
inline void Visual::set_fps(float value) {
  set_has_fps();
  fps_ = value;
}

// optional .azVisual.Layer layer = 3;
inline bool Visual::has_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Visual::set_has_layer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Visual::clear_has_layer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Visual::clear_layer() {
  if (layer_ != NULL) layer_->::azVisual::Layer::Clear();
  clear_has_layer();
}
inline const ::azVisual::Layer& Visual::layer() const {
  return layer_ != NULL ? *layer_ : *default_instance_->layer_;
}
inline ::azVisual::Layer* Visual::mutable_layer() {
  set_has_layer();
  if (layer_ == NULL) layer_ = new ::azVisual::Layer;
  return layer_;
}
inline ::azVisual::Layer* Visual::release_layer() {
  clear_has_layer();
  ::azVisual::Layer* temp = layer_;
  layer_ = NULL;
  return temp;
}
inline void Visual::set_allocated_layer(::azVisual::Layer* layer) {
  delete layer_;
  layer_ = layer;
  if (layer) {
    set_has_layer();
  } else {
    clear_has_layer();
  }
}

// -------------------------------------------------------------------

// VisualGroup

// required .azModel.Base base = 1;
inline bool VisualGroup::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisualGroup::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisualGroup::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisualGroup::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& VisualGroup::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* VisualGroup::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* VisualGroup::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void VisualGroup::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// repeated .azVisual.Visual visual_list = 2;
inline int VisualGroup::visual_list_size() const {
  return visual_list_.size();
}
inline void VisualGroup::clear_visual_list() {
  visual_list_.Clear();
}
inline const ::azVisual::Visual& VisualGroup::visual_list(int index) const {
  return visual_list_.Get(index);
}
inline ::azVisual::Visual* VisualGroup::mutable_visual_list(int index) {
  return visual_list_.Mutable(index);
}
inline ::azVisual::Visual* VisualGroup::add_visual_list() {
  return visual_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Visual >&
VisualGroup::visual_list() const {
  return visual_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::Visual >*
VisualGroup::mutable_visual_list() {
  return &visual_list_;
}

// -------------------------------------------------------------------

// Socket

// required .azModel.Base base = 1;
inline bool Socket::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Socket::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Socket::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Socket::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& Socket::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* Socket::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* Socket::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Socket::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional uint64 reference_rtid = 2;
inline bool Socket::has_reference_rtid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Socket::set_has_reference_rtid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Socket::clear_has_reference_rtid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Socket::clear_reference_rtid() {
  reference_rtid_ = GOOGLE_ULONGLONG(0);
  clear_has_reference_rtid();
}
inline ::google::protobuf::uint64 Socket::reference_rtid() const {
  return reference_rtid_;
}
inline void Socket::set_reference_rtid(::google::protobuf::uint64 value) {
  set_has_reference_rtid();
  reference_rtid_ = value;
}

// -------------------------------------------------------------------

// SocketGroup

// required .azModel.Base base = 1;
inline bool SocketGroup::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketGroup::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketGroup::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketGroup::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& SocketGroup::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* SocketGroup::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* SocketGroup::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void SocketGroup::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// repeated .azVisual.Socket socket_list = 2;
inline int SocketGroup::socket_list_size() const {
  return socket_list_.size();
}
inline void SocketGroup::clear_socket_list() {
  socket_list_.Clear();
}
inline const ::azVisual::Socket& SocketGroup::socket_list(int index) const {
  return socket_list_.Get(index);
}
inline ::azVisual::Socket* SocketGroup::mutable_socket_list(int index) {
  return socket_list_.Mutable(index);
}
inline ::azVisual::Socket* SocketGroup::add_socket_list() {
  return socket_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Socket >&
SocketGroup::socket_list() const {
  return socket_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::Socket >*
SocketGroup::mutable_socket_list() {
  return &socket_list_;
}

// -------------------------------------------------------------------

// EventShape

// required .azModel.Base base = 1;
inline bool EventShape::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventShape::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventShape::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventShape::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& EventShape::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* EventShape::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* EventShape::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void EventShape::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// -------------------------------------------------------------------

// EventShapeGroup

// required .azModel.Base base = 1;
inline bool EventShapeGroup::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventShapeGroup::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventShapeGroup::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventShapeGroup::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& EventShapeGroup::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* EventShapeGroup::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* EventShapeGroup::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void EventShapeGroup::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// repeated .azVisual.EventShape event_shape_list = 2;
inline int EventShapeGroup::event_shape_list_size() const {
  return event_shape_list_.size();
}
inline void EventShapeGroup::clear_event_shape_list() {
  event_shape_list_.Clear();
}
inline const ::azVisual::EventShape& EventShapeGroup::event_shape_list(int index) const {
  return event_shape_list_.Get(index);
}
inline ::azVisual::EventShape* EventShapeGroup::mutable_event_shape_list(int index) {
  return event_shape_list_.Mutable(index);
}
inline ::azVisual::EventShape* EventShapeGroup::add_event_shape_list() {
  return event_shape_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::EventShape >&
EventShapeGroup::event_shape_list() const {
  return event_shape_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::EventShape >*
EventShapeGroup::mutable_event_shape_list() {
  return &event_shape_list_;
}

// -------------------------------------------------------------------

// Particle

// required .azModel.Base base = 1;
inline bool Particle::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Particle::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Particle::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Particle::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& Particle::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* Particle::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* Particle::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Particle::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// -------------------------------------------------------------------

// ParticleGroup

// required .azModel.Base base = 1;
inline bool ParticleGroup::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParticleGroup::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParticleGroup::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParticleGroup::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& ParticleGroup::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* ParticleGroup::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* ParticleGroup::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void ParticleGroup::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// repeated .azVisual.Particle particle_list = 2;
inline int ParticleGroup::particle_list_size() const {
  return particle_list_.size();
}
inline void ParticleGroup::clear_particle_list() {
  particle_list_.Clear();
}
inline const ::azVisual::Particle& ParticleGroup::particle_list(int index) const {
  return particle_list_.Get(index);
}
inline ::azVisual::Particle* ParticleGroup::mutable_particle_list(int index) {
  return particle_list_.Mutable(index);
}
inline ::azVisual::Particle* ParticleGroup::add_particle_list() {
  return particle_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Particle >&
ParticleGroup::particle_list() const {
  return particle_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::Particle >*
ParticleGroup::mutable_particle_list() {
  return &particle_list_;
}

// -------------------------------------------------------------------

// Font

// required .azModel.Base base = 1;
inline bool Font::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Font::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Font::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Font::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& Font::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* Font::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* Font::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Font::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional string face = 2;
inline bool Font::has_face() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Font::set_has_face() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Font::clear_has_face() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Font::clear_face() {
  if (face_ != &::google::protobuf::internal::kEmptyString) {
    face_->clear();
  }
  clear_has_face();
}
inline const ::std::string& Font::face() const {
  return *face_;
}
inline void Font::set_face(const ::std::string& value) {
  set_has_face();
  if (face_ == &::google::protobuf::internal::kEmptyString) {
    face_ = new ::std::string;
  }
  face_->assign(value);
}
inline void Font::set_face(const char* value) {
  set_has_face();
  if (face_ == &::google::protobuf::internal::kEmptyString) {
    face_ = new ::std::string;
  }
  face_->assign(value);
}
inline void Font::set_face(const char* value, size_t size) {
  set_has_face();
  if (face_ == &::google::protobuf::internal::kEmptyString) {
    face_ = new ::std::string;
  }
  face_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Font::mutable_face() {
  set_has_face();
  if (face_ == &::google::protobuf::internal::kEmptyString) {
    face_ = new ::std::string;
  }
  return face_;
}
inline ::std::string* Font::release_face() {
  clear_has_face();
  if (face_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = face_;
    face_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Font::set_allocated_face(::std::string* face) {
  if (face_ != &::google::protobuf::internal::kEmptyString) {
    delete face_;
  }
  if (face) {
    set_has_face();
    face_ = face;
  } else {
    clear_has_face();
    face_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 size = 3;
inline bool Font::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Font::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Font::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Font::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 Font::size() const {
  return size_;
}
inline void Font::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// Project

// required .azModel.Base base = 1;
inline bool Project::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Project::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Project::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Project::clear_base() {
  if (base_ != NULL) base_->::azModel::Base::Clear();
  clear_has_base();
}
inline const ::azModel::Base& Project::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::azModel::Base* Project::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::azModel::Base;
  return base_;
}
inline ::azModel::Base* Project::release_base() {
  clear_has_base();
  ::azModel::Base* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Project::set_allocated_base(::azModel::Base* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional string version = 2;
inline bool Project::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Project::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Project::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Project::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& Project::version() const {
  return *version_;
}
inline void Project::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Project::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Project::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Project::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* Project::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Project::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .azModel.Bitmap bitmap_list = 3;
inline int Project::bitmap_list_size() const {
  return bitmap_list_.size();
}
inline void Project::clear_bitmap_list() {
  bitmap_list_.Clear();
}
inline const ::azModel::Bitmap& Project::bitmap_list(int index) const {
  return bitmap_list_.Get(index);
}
inline ::azModel::Bitmap* Project::mutable_bitmap_list(int index) {
  return bitmap_list_.Mutable(index);
}
inline ::azModel::Bitmap* Project::add_bitmap_list() {
  return bitmap_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azModel::Bitmap >&
Project::bitmap_list() const {
  return bitmap_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azModel::Bitmap >*
Project::mutable_bitmap_list() {
  return &bitmap_list_;
}

// repeated .azVisual.SocketGroup socket_group_list = 4;
inline int Project::socket_group_list_size() const {
  return socket_group_list_.size();
}
inline void Project::clear_socket_group_list() {
  socket_group_list_.Clear();
}
inline const ::azVisual::SocketGroup& Project::socket_group_list(int index) const {
  return socket_group_list_.Get(index);
}
inline ::azVisual::SocketGroup* Project::mutable_socket_group_list(int index) {
  return socket_group_list_.Mutable(index);
}
inline ::azVisual::SocketGroup* Project::add_socket_group_list() {
  return socket_group_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::SocketGroup >&
Project::socket_group_list() const {
  return socket_group_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::SocketGroup >*
Project::mutable_socket_group_list() {
  return &socket_group_list_;
}

// repeated .azVisual.EventShapeGroup event_shape_group_list = 5;
inline int Project::event_shape_group_list_size() const {
  return event_shape_group_list_.size();
}
inline void Project::clear_event_shape_group_list() {
  event_shape_group_list_.Clear();
}
inline const ::azVisual::EventShapeGroup& Project::event_shape_group_list(int index) const {
  return event_shape_group_list_.Get(index);
}
inline ::azVisual::EventShapeGroup* Project::mutable_event_shape_group_list(int index) {
  return event_shape_group_list_.Mutable(index);
}
inline ::azVisual::EventShapeGroup* Project::add_event_shape_group_list() {
  return event_shape_group_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::EventShapeGroup >&
Project::event_shape_group_list() const {
  return event_shape_group_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::EventShapeGroup >*
Project::mutable_event_shape_group_list() {
  return &event_shape_group_list_;
}

// repeated .azVisual.ParticleGroup particle_group_list = 6;
inline int Project::particle_group_list_size() const {
  return particle_group_list_.size();
}
inline void Project::clear_particle_group_list() {
  particle_group_list_.Clear();
}
inline const ::azVisual::ParticleGroup& Project::particle_group_list(int index) const {
  return particle_group_list_.Get(index);
}
inline ::azVisual::ParticleGroup* Project::mutable_particle_group_list(int index) {
  return particle_group_list_.Mutable(index);
}
inline ::azVisual::ParticleGroup* Project::add_particle_group_list() {
  return particle_group_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::ParticleGroup >&
Project::particle_group_list() const {
  return particle_group_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::ParticleGroup >*
Project::mutable_particle_group_list() {
  return &particle_group_list_;
}

// repeated .azVisual.VisualGroup visual_group_list = 7;
inline int Project::visual_group_list_size() const {
  return visual_group_list_.size();
}
inline void Project::clear_visual_group_list() {
  visual_group_list_.Clear();
}
inline const ::azVisual::VisualGroup& Project::visual_group_list(int index) const {
  return visual_group_list_.Get(index);
}
inline ::azVisual::VisualGroup* Project::mutable_visual_group_list(int index) {
  return visual_group_list_.Mutable(index);
}
inline ::azVisual::VisualGroup* Project::add_visual_group_list() {
  return visual_group_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::VisualGroup >&
Project::visual_group_list() const {
  return visual_group_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::VisualGroup >*
Project::mutable_visual_group_list() {
  return &visual_group_list_;
}

// repeated .azVisual.Font font_list = 8;
inline int Project::font_list_size() const {
  return font_list_.size();
}
inline void Project::clear_font_list() {
  font_list_.Clear();
}
inline const ::azVisual::Font& Project::font_list(int index) const {
  return font_list_.Get(index);
}
inline ::azVisual::Font* Project::mutable_font_list(int index) {
  return font_list_.Mutable(index);
}
inline ::azVisual::Font* Project::add_font_list() {
  return font_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::azVisual::Font >&
Project::font_list() const {
  return font_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::azVisual::Font >*
Project::mutable_font_list() {
  return &font_list_;
}

// repeated string import_project_list = 9;
inline int Project::import_project_list_size() const {
  return import_project_list_.size();
}
inline void Project::clear_import_project_list() {
  import_project_list_.Clear();
}
inline const ::std::string& Project::import_project_list(int index) const {
  return import_project_list_.Get(index);
}
inline ::std::string* Project::mutable_import_project_list(int index) {
  return import_project_list_.Mutable(index);
}
inline void Project::set_import_project_list(int index, const ::std::string& value) {
  import_project_list_.Mutable(index)->assign(value);
}
inline void Project::set_import_project_list(int index, const char* value) {
  import_project_list_.Mutable(index)->assign(value);
}
inline void Project::set_import_project_list(int index, const char* value, size_t size) {
  import_project_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Project::add_import_project_list() {
  return import_project_list_.Add();
}
inline void Project::add_import_project_list(const ::std::string& value) {
  import_project_list_.Add()->assign(value);
}
inline void Project::add_import_project_list(const char* value) {
  import_project_list_.Add()->assign(value);
}
inline void Project::add_import_project_list(const char* value, size_t size) {
  import_project_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Project::import_project_list() const {
  return import_project_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Project::mutable_import_project_list() {
  return &import_project_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace azVisual

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_azvisual_2eproto__INCLUDED
