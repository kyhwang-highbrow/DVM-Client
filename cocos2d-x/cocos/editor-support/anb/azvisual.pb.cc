// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: azvisual.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "azvisual.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace azVisual {

namespace {

const ::google::protobuf::Descriptor* Key_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Key_reflection_ = NULL;
const ::google::protobuf::Descriptor* Layer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Layer_reflection_ = NULL;
const ::google::protobuf::Descriptor* Visual_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Visual_reflection_ = NULL;
const ::google::protobuf::Descriptor* VisualGroup_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VisualGroup_reflection_ = NULL;
const ::google::protobuf::Descriptor* Socket_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Socket_reflection_ = NULL;
const ::google::protobuf::Descriptor* SocketGroup_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SocketGroup_reflection_ = NULL;
const ::google::protobuf::Descriptor* EventShape_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EventShape_reflection_ = NULL;
const ::google::protobuf::Descriptor* EventShapeGroup_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EventShapeGroup_reflection_ = NULL;
const ::google::protobuf::Descriptor* Particle_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Particle_reflection_ = NULL;
const ::google::protobuf::Descriptor* ParticleGroup_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ParticleGroup_reflection_ = NULL;
const ::google::protobuf::Descriptor* Font_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Font_reflection_ = NULL;
const ::google::protobuf::Descriptor* Project_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Project_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_azvisual_2eproto() {
  protobuf_AddDesc_azvisual_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "azvisual.proto");
  GOOGLE_CHECK(file != NULL);
  Key_descriptor_ = file->message_type(0);
  static const int Key_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, blank_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, transform_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, alpha_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, color_r_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, color_g_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, color_b_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, blend_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, refrence_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, shape_type_),
  };
  Key_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Key_descriptor_,
      Key::default_instance_,
      Key_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Key));
  Layer_descriptor_ = file->message_type(1);
  static const int Layer_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layer, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layer, reference_rtid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layer, key_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layer, layer_list_),
  };
  Layer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Layer_descriptor_,
      Layer::default_instance_,
      Layer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Layer));
  Visual_descriptor_ = file->message_type(2);
  static const int Visual_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Visual, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Visual, fps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Visual, layer_),
  };
  Visual_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Visual_descriptor_,
      Visual::default_instance_,
      Visual_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Visual, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Visual, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Visual));
  VisualGroup_descriptor_ = file->message_type(3);
  static const int VisualGroup_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisualGroup, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisualGroup, visual_list_),
  };
  VisualGroup_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VisualGroup_descriptor_,
      VisualGroup::default_instance_,
      VisualGroup_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisualGroup, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VisualGroup, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VisualGroup));
  Socket_descriptor_ = file->message_type(4);
  static const int Socket_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Socket, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Socket, reference_rtid_),
  };
  Socket_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Socket_descriptor_,
      Socket::default_instance_,
      Socket_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Socket, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Socket, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Socket));
  SocketGroup_descriptor_ = file->message_type(5);
  static const int SocketGroup_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SocketGroup, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SocketGroup, socket_list_),
  };
  SocketGroup_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SocketGroup_descriptor_,
      SocketGroup::default_instance_,
      SocketGroup_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SocketGroup, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SocketGroup, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SocketGroup));
  EventShape_descriptor_ = file->message_type(6);
  static const int EventShape_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EventShape, base_),
  };
  EventShape_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EventShape_descriptor_,
      EventShape::default_instance_,
      EventShape_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EventShape, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EventShape, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EventShape));
  EventShapeGroup_descriptor_ = file->message_type(7);
  static const int EventShapeGroup_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EventShapeGroup, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EventShapeGroup, event_shape_list_),
  };
  EventShapeGroup_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EventShapeGroup_descriptor_,
      EventShapeGroup::default_instance_,
      EventShapeGroup_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EventShapeGroup, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EventShapeGroup, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EventShapeGroup));
  Particle_descriptor_ = file->message_type(8);
  static const int Particle_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Particle, base_),
  };
  Particle_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Particle_descriptor_,
      Particle::default_instance_,
      Particle_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Particle, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Particle, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Particle));
  ParticleGroup_descriptor_ = file->message_type(9);
  static const int ParticleGroup_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParticleGroup, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParticleGroup, particle_list_),
  };
  ParticleGroup_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ParticleGroup_descriptor_,
      ParticleGroup::default_instance_,
      ParticleGroup_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParticleGroup, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParticleGroup, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ParticleGroup));
  Font_descriptor_ = file->message_type(10);
  static const int Font_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Font, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Font, face_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Font, size_),
  };
  Font_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Font_descriptor_,
      Font::default_instance_,
      Font_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Font, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Font, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Font));
  Project_descriptor_ = file->message_type(11);
  static const int Project_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, bitmap_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, socket_group_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, event_shape_group_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, particle_group_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, visual_group_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, font_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, import_project_list_),
  };
  Project_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Project_descriptor_,
      Project::default_instance_,
      Project_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Project, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Project));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_azvisual_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Key_descriptor_, &Key::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Layer_descriptor_, &Layer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Visual_descriptor_, &Visual::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VisualGroup_descriptor_, &VisualGroup::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Socket_descriptor_, &Socket::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SocketGroup_descriptor_, &SocketGroup::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EventShape_descriptor_, &EventShape::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EventShapeGroup_descriptor_, &EventShapeGroup::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Particle_descriptor_, &Particle::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ParticleGroup_descriptor_, &ParticleGroup::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Font_descriptor_, &Font::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Project_descriptor_, &Project::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_azvisual_2eproto() {
  delete Key::default_instance_;
  delete Key_reflection_;
  delete Layer::default_instance_;
  delete Layer_reflection_;
  delete Visual::default_instance_;
  delete Visual_reflection_;
  delete VisualGroup::default_instance_;
  delete VisualGroup_reflection_;
  delete Socket::default_instance_;
  delete Socket_reflection_;
  delete SocketGroup::default_instance_;
  delete SocketGroup_reflection_;
  delete EventShape::default_instance_;
  delete EventShape_reflection_;
  delete EventShapeGroup::default_instance_;
  delete EventShapeGroup_reflection_;
  delete Particle::default_instance_;
  delete Particle_reflection_;
  delete ParticleGroup::default_instance_;
  delete ParticleGroup_reflection_;
  delete Font::default_instance_;
  delete Font_reflection_;
  delete Project::default_instance_;
  delete Project_reflection_;
}

void protobuf_AddDesc_azvisual_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::azModel::protobuf_AddDesc_azmodel_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016azvisual.proto\022\010azVisual\032\razmodel.prot"
    "o\"\341\002\n\003Key\022\033\n\004base\030\001 \002(\0132\r.azModel.Base\022\r"
    "\n\005frame\030\002 \001(\002\022\024\n\005blank\030\003 \001(\010:\005false\022\'\n\tt"
    "ransform\030\004 \001(\0132\024.azModel.Transform2D\022\020\n\005"
    "alpha\030\005 \001(\002:\0011\022\022\n\007color_r\030\006 \001(\002:\0011\022\022\n\007co"
    "lor_g\030\007 \001(\002:\0011\022\022\n\007color_b\030\010 \001(\002:\0011\022.\n\nbl"
    "end_mode\030\t \001(\0162\023.azModel.BLEND_MODE:\005ALP"
    "HA\022\027\n\rrefrence_name\030\n \001(\t:\000\022,\n\nshape_typ"
    "e\030\013 \001(\0162\023.azModel.SHAPE_TYPE:\003BOX2*\n\004typ"
    "e\022\r.azModel.Type\030o \001(\0132\r.azVisual.Key\"\260\001"
    "\n\005Layer\022\033\n\004base\030\001 \002(\0132\r.azModel.Base\022\026\n\016"
    "reference_rtid\030\002 \001(\004\022\037\n\010key_list\030\003 \003(\0132\r"
    ".azVisual.Key\022#\n\nlayer_list\030\004 \003(\0132\017.azVi"
    "sual.Layer2,\n\004type\022\r.azModel.Type\030p \001(\0132"
    "\017.azVisual.Layer\"\201\001\n\006Visual\022\033\n\004base\030\001 \002("
    "\0132\r.azModel.Base\022\013\n\003fps\030\002 \001(\002\022\036\n\005layer\030\003"
    " \001(\0132\017.azVisual.Layer2-\n\004type\022\r.azModel."
    "Type\030q \001(\0132\020.azVisual.Visual\"\205\001\n\013VisualG"
    "roup\022\033\n\004base\030\001 \002(\0132\r.azModel.Base\022%\n\013vis"
    "ual_list\030\002 \003(\0132\020.azVisual.Visual22\n\004type"
    "\022\r.azModel.Type\030r \001(\0132\025.azVisual.VisualG"
    "roup\"l\n\006Socket\022\033\n\004base\030\001 \002(\0132\r.azModel.B"
    "ase\022\026\n\016reference_rtid\030\002 \001(\0042-\n\004type\022\r.az"
    "Model.Type\030y \001(\0132\020.azVisual.Socket\"\205\001\n\013S"
    "ocketGroup\022\033\n\004base\030\001 \002(\0132\r.azModel.Base\022"
    "%\n\013socket_list\030\002 \003(\0132\020.azVisual.Socket22"
    "\n\004type\022\r.azModel.Type\030z \001(\0132\025.azVisual.S"
    "ocketGroup\"]\n\nEventShape\022\033\n\004base\030\001 \002(\0132\r"
    ".azModel.Base22\n\004type\022\r.azModel.Type\030\203\001 "
    "\001(\0132\024.azVisual.EventShape\"\227\001\n\017EventShape"
    "Group\022\033\n\004base\030\001 \002(\0132\r.azModel.Base\022.\n\020ev"
    "ent_shape_list\030\002 \003(\0132\024.azVisual.EventSha"
    "pe27\n\004type\022\r.azModel.Type\030\204\001 \001(\0132\031.azVis"
    "ual.EventShapeGroup\"Y\n\010Particle\022\033\n\004base\030"
    "\001 \002(\0132\r.azModel.Base20\n\004type\022\r.azModel.T"
    "ype\030\215\001 \001(\0132\022.azVisual.Particle\"\216\001\n\rParti"
    "cleGroup\022\033\n\004base\030\001 \002(\0132\r.azModel.Base\022)\n"
    "\rparticle_list\030\002 \003(\0132\022.azVisual.Particle"
    "25\n\004type\022\r.azModel.Type\030\216\001 \001(\0132\027.azVisua"
    "l.ParticleGroup\"s\n\004Font\022\033\n\004base\030\001 \002(\0132\r."
    "azModel.Base\022\014\n\004face\030\002 \001(\t\022\014\n\004size\030\003 \001(\005"
    "22\n\004type\022\r.azModel.Type\030\227\001 \001(\0132\024.azVisua"
    "l.EventShape\"\243\003\n\007Project\022\033\n\004base\030\001 \002(\0132\r"
    ".azModel.Base\022\017\n\007version\030\002 \001(\t\022$\n\013bitmap"
    "_list\030\003 \003(\0132\017.azModel.Bitmap\0220\n\021socket_g"
    "roup_list\030\004 \003(\0132\025.azVisual.SocketGroup\0229"
    "\n\026event_shape_group_list\030\005 \003(\0132\031.azVisua"
    "l.EventShapeGroup\0224\n\023particle_group_list"
    "\030\006 \003(\0132\027.azVisual.ParticleGroup\0220\n\021visua"
    "l_group_list\030\007 \003(\0132\025.azVisual.VisualGrou"
    "p\022!\n\tfont_list\030\010 \003(\0132\016.azVisual.Font\022\033\n\023"
    "import_project_list\030\t \003(\t2/\n\004type\022\r.azMo"
    "del.Type\030\307\001 \001(\0132\021.azVisual.Project", 2114);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "azvisual.proto", &protobuf_RegisterTypes);
  Key::default_instance_ = new Key();
  Layer::default_instance_ = new Layer();
  Visual::default_instance_ = new Visual();
  VisualGroup::default_instance_ = new VisualGroup();
  Socket::default_instance_ = new Socket();
  SocketGroup::default_instance_ = new SocketGroup();
  EventShape::default_instance_ = new EventShape();
  EventShapeGroup::default_instance_ = new EventShapeGroup();
  Particle::default_instance_ = new Particle();
  ParticleGroup::default_instance_ = new ParticleGroup();
  Font::default_instance_ = new Font();
  Project::default_instance_ = new Project();
  Key::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    111, 11, false, false,
    &::azVisual::Key::default_instance());
  Layer::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    112, 11, false, false,
    &::azVisual::Layer::default_instance());
  Visual::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    113, 11, false, false,
    &::azVisual::Visual::default_instance());
  VisualGroup::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    114, 11, false, false,
    &::azVisual::VisualGroup::default_instance());
  Socket::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    121, 11, false, false,
    &::azVisual::Socket::default_instance());
  SocketGroup::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    122, 11, false, false,
    &::azVisual::SocketGroup::default_instance());
  EventShape::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    131, 11, false, false,
    &::azVisual::EventShape::default_instance());
  EventShapeGroup::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    132, 11, false, false,
    &::azVisual::EventShapeGroup::default_instance());
  Particle::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    141, 11, false, false,
    &::azVisual::Particle::default_instance());
  ParticleGroup::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    142, 11, false, false,
    &::azVisual::ParticleGroup::default_instance());
  Font::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    151, 11, false, false,
    &::azVisual::EventShape::default_instance());
  Project::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::azModel::Type::default_instance(),
    199, 11, false, false,
    &::azVisual::Project::default_instance());
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_azvisual_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_azvisual_2eproto {
  StaticDescriptorInitializer_azvisual_2eproto() {
    protobuf_AddDesc_azvisual_2eproto();
  }
} static_descriptor_initializer_azvisual_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Key::kBaseFieldNumber;
const int Key::kFrameFieldNumber;
const int Key::kBlankFieldNumber;
const int Key::kTransformFieldNumber;
const int Key::kAlphaFieldNumber;
const int Key::kColorRFieldNumber;
const int Key::kColorGFieldNumber;
const int Key::kColorBFieldNumber;
const int Key::kBlendModeFieldNumber;
const int Key::kRefrenceNameFieldNumber;
const int Key::kShapeTypeFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int Key::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Key >, 11, false >
  Key::type(kTypeFieldNumber, ::azVisual::Key::default_instance());
Key::Key()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Key::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
  transform_ = const_cast< ::azModel::Transform2D*>(&::azModel::Transform2D::default_instance());
}

Key::Key(const Key& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Key::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  frame_ = 0;
  blank_ = false;
  transform_ = NULL;
  alpha_ = 1;
  color_r_ = 1;
  color_g_ = 1;
  color_b_ = 1;
  blend_mode_ = 1;
  refrence_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  shape_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Key::~Key() {
  SharedDtor();
}

void Key::SharedDtor() {
  if (refrence_name_ != &::google::protobuf::internal::kEmptyString) {
    delete refrence_name_;
  }
  if (this != default_instance_) {
    delete base_;
    delete transform_;
  }
}

void Key::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Key::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Key_descriptor_;
}

const Key& Key::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

Key* Key::default_instance_ = NULL;

Key* Key::New() const {
  return new Key;
}

void Key::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
    frame_ = 0;
    blank_ = false;
    if (has_transform()) {
      if (transform_ != NULL) transform_->::azModel::Transform2D::Clear();
    }
    alpha_ = 1;
    color_r_ = 1;
    color_g_ = 1;
    color_b_ = 1;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    blend_mode_ = 1;
    if (has_refrence_name()) {
      if (refrence_name_ != &::google::protobuf::internal::kEmptyString) {
        refrence_name_->clear();
      }
    }
    shape_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Key::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_frame;
        break;
      }

      // optional float frame = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &frame_)));
          set_has_frame();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_blank;
        break;
      }

      // optional bool blank = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &blank_)));
          set_has_blank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_transform;
        break;
      }

      // optional .azModel.Transform2D transform = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transform:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transform()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_alpha;
        break;
      }

      // optional float alpha = 5 [default = 1];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_alpha:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alpha_)));
          set_has_alpha();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_color_r;
        break;
      }

      // optional float color_r = 6 [default = 1];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_color_r:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &color_r_)));
          set_has_color_r();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_color_g;
        break;
      }

      // optional float color_g = 7 [default = 1];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_color_g:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &color_g_)));
          set_has_color_g();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_color_b;
        break;
      }

      // optional float color_b = 8 [default = 1];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_color_b:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &color_b_)));
          set_has_color_b();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_blend_mode;
        break;
      }

      // optional .azModel.BLEND_MODE blend_mode = 9 [default = ALPHA];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blend_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::azModel::BLEND_MODE_IsValid(value)) {
            set_blend_mode(static_cast< ::azModel::BLEND_MODE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_refrence_name;
        break;
      }

      // optional string refrence_name = 10 [default = ""];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_refrence_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_refrence_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->refrence_name().data(), this->refrence_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_shape_type;
        break;
      }

      // optional .azModel.SHAPE_TYPE shape_type = 11 [default = BOX];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shape_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::azModel::SHAPE_TYPE_IsValid(value)) {
            set_shape_type(static_cast< ::azModel::SHAPE_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(11, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Key::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  // optional float frame = 2;
  if (has_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->frame(), output);
  }

  // optional bool blank = 3 [default = false];
  if (has_blank()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->blank(), output);
  }

  // optional .azModel.Transform2D transform = 4;
  if (has_transform()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->transform(), output);
  }

  // optional float alpha = 5 [default = 1];
  if (has_alpha()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->alpha(), output);
  }

  // optional float color_r = 6 [default = 1];
  if (has_color_r()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->color_r(), output);
  }

  // optional float color_g = 7 [default = 1];
  if (has_color_g()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->color_g(), output);
  }

  // optional float color_b = 8 [default = 1];
  if (has_color_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->color_b(), output);
  }

  // optional .azModel.BLEND_MODE blend_mode = 9 [default = ALPHA];
  if (has_blend_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->blend_mode(), output);
  }

  // optional string refrence_name = 10 [default = ""];
  if (has_refrence_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->refrence_name().data(), this->refrence_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->refrence_name(), output);
  }

  // optional .azModel.SHAPE_TYPE shape_type = 11 [default = BOX];
  if (has_shape_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->shape_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Key::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  // optional float frame = 2;
  if (has_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->frame(), target);
  }

  // optional bool blank = 3 [default = false];
  if (has_blank()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->blank(), target);
  }

  // optional .azModel.Transform2D transform = 4;
  if (has_transform()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->transform(), target);
  }

  // optional float alpha = 5 [default = 1];
  if (has_alpha()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->alpha(), target);
  }

  // optional float color_r = 6 [default = 1];
  if (has_color_r()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->color_r(), target);
  }

  // optional float color_g = 7 [default = 1];
  if (has_color_g()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->color_g(), target);
  }

  // optional float color_b = 8 [default = 1];
  if (has_color_b()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->color_b(), target);
  }

  // optional .azModel.BLEND_MODE blend_mode = 9 [default = ALPHA];
  if (has_blend_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->blend_mode(), target);
  }

  // optional string refrence_name = 10 [default = ""];
  if (has_refrence_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->refrence_name().data(), this->refrence_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->refrence_name(), target);
  }

  // optional .azModel.SHAPE_TYPE shape_type = 11 [default = BOX];
  if (has_shape_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      11, this->shape_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Key::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

    // optional float frame = 2;
    if (has_frame()) {
      total_size += 1 + 4;
    }

    // optional bool blank = 3 [default = false];
    if (has_blank()) {
      total_size += 1 + 1;
    }

    // optional .azModel.Transform2D transform = 4;
    if (has_transform()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transform());
    }

    // optional float alpha = 5 [default = 1];
    if (has_alpha()) {
      total_size += 1 + 4;
    }

    // optional float color_r = 6 [default = 1];
    if (has_color_r()) {
      total_size += 1 + 4;
    }

    // optional float color_g = 7 [default = 1];
    if (has_color_g()) {
      total_size += 1 + 4;
    }

    // optional float color_b = 8 [default = 1];
    if (has_color_b()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .azModel.BLEND_MODE blend_mode = 9 [default = ALPHA];
    if (has_blend_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->blend_mode());
    }

    // optional string refrence_name = 10 [default = ""];
    if (has_refrence_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->refrence_name());
    }

    // optional .azModel.SHAPE_TYPE shape_type = 11 [default = BOX];
    if (has_shape_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->shape_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Key::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Key* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Key*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Key::MergeFrom(const Key& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
    if (from.has_frame()) {
      set_frame(from.frame());
    }
    if (from.has_blank()) {
      set_blank(from.blank());
    }
    if (from.has_transform()) {
      mutable_transform()->::azModel::Transform2D::MergeFrom(from.transform());
    }
    if (from.has_alpha()) {
      set_alpha(from.alpha());
    }
    if (from.has_color_r()) {
      set_color_r(from.color_r());
    }
    if (from.has_color_g()) {
      set_color_g(from.color_g());
    }
    if (from.has_color_b()) {
      set_color_b(from.color_b());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_blend_mode()) {
      set_blend_mode(from.blend_mode());
    }
    if (from.has_refrence_name()) {
      set_refrence_name(from.refrence_name());
    }
    if (from.has_shape_type()) {
      set_shape_type(from.shape_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Key::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Key::CopyFrom(const Key& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Key::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Key::Swap(Key* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(frame_, other->frame_);
    std::swap(blank_, other->blank_);
    std::swap(transform_, other->transform_);
    std::swap(alpha_, other->alpha_);
    std::swap(color_r_, other->color_r_);
    std::swap(color_g_, other->color_g_);
    std::swap(color_b_, other->color_b_);
    std::swap(blend_mode_, other->blend_mode_);
    std::swap(refrence_name_, other->refrence_name_);
    std::swap(shape_type_, other->shape_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Key::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Key_descriptor_;
  metadata.reflection = Key_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Layer::kBaseFieldNumber;
const int Layer::kReferenceRtidFieldNumber;
const int Layer::kKeyListFieldNumber;
const int Layer::kLayerListFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int Layer::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Layer >, 11, false >
  Layer::type(kTypeFieldNumber, ::azVisual::Layer::default_instance());
Layer::Layer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Layer::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
}

Layer::Layer(const Layer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Layer::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  reference_rtid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Layer::~Layer() {
  SharedDtor();
}

void Layer::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void Layer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Layer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Layer_descriptor_;
}

const Layer& Layer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

Layer* Layer::default_instance_ = NULL;

Layer* Layer::New() const {
  return new Layer;
}

void Layer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
    reference_rtid_ = GOOGLE_ULONGLONG(0);
  }
  key_list_.Clear();
  layer_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Layer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_reference_rtid;
        break;
      }

      // optional uint64 reference_rtid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reference_rtid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &reference_rtid_)));
          set_has_reference_rtid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key_list;
        break;
      }

      // repeated .azVisual.Key key_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key_list;
        if (input->ExpectTag(34)) goto parse_layer_list;
        break;
      }

      // repeated .azVisual.Layer layer_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_layer_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_layer_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_layer_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Layer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  // optional uint64 reference_rtid = 2;
  if (has_reference_rtid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->reference_rtid(), output);
  }

  // repeated .azVisual.Key key_list = 3;
  for (int i = 0; i < this->key_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->key_list(i), output);
  }

  // repeated .azVisual.Layer layer_list = 4;
  for (int i = 0; i < this->layer_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->layer_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Layer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  // optional uint64 reference_rtid = 2;
  if (has_reference_rtid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->reference_rtid(), target);
  }

  // repeated .azVisual.Key key_list = 3;
  for (int i = 0; i < this->key_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->key_list(i), target);
  }

  // repeated .azVisual.Layer layer_list = 4;
  for (int i = 0; i < this->layer_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->layer_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Layer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

    // optional uint64 reference_rtid = 2;
    if (has_reference_rtid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->reference_rtid());
    }

  }
  // repeated .azVisual.Key key_list = 3;
  total_size += 1 * this->key_list_size();
  for (int i = 0; i < this->key_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_list(i));
  }

  // repeated .azVisual.Layer layer_list = 4;
  total_size += 1 * this->layer_list_size();
  for (int i = 0; i < this->layer_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->layer_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Layer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Layer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Layer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Layer::MergeFrom(const Layer& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_list_.MergeFrom(from.key_list_);
  layer_list_.MergeFrom(from.layer_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
    if (from.has_reference_rtid()) {
      set_reference_rtid(from.reference_rtid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Layer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Layer::CopyFrom(const Layer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Layer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < key_list_size(); i++) {
    if (!this->key_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < layer_list_size(); i++) {
    if (!this->layer_list(i).IsInitialized()) return false;
  }
  return true;
}

void Layer::Swap(Layer* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(reference_rtid_, other->reference_rtid_);
    key_list_.Swap(&other->key_list_);
    layer_list_.Swap(&other->layer_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Layer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Layer_descriptor_;
  metadata.reflection = Layer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Visual::kBaseFieldNumber;
const int Visual::kFpsFieldNumber;
const int Visual::kLayerFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int Visual::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Visual >, 11, false >
  Visual::type(kTypeFieldNumber, ::azVisual::Visual::default_instance());
Visual::Visual()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Visual::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
  layer_ = const_cast< ::azVisual::Layer*>(&::azVisual::Layer::default_instance());
}

Visual::Visual(const Visual& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Visual::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  fps_ = 0;
  layer_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Visual::~Visual() {
  SharedDtor();
}

void Visual::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
    delete layer_;
  }
}

void Visual::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Visual::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Visual_descriptor_;
}

const Visual& Visual::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

Visual* Visual::default_instance_ = NULL;

Visual* Visual::New() const {
  return new Visual;
}

void Visual::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
    fps_ = 0;
    if (has_layer()) {
      if (layer_ != NULL) layer_->::azVisual::Layer::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Visual::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_fps;
        break;
      }

      // optional float fps = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fps_)));
          set_has_fps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_layer;
        break;
      }

      // optional .azVisual.Layer layer = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_layer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_layer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Visual::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  // optional float fps = 2;
  if (has_fps()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->fps(), output);
  }

  // optional .azVisual.Layer layer = 3;
  if (has_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->layer(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Visual::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  // optional float fps = 2;
  if (has_fps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->fps(), target);
  }

  // optional .azVisual.Layer layer = 3;
  if (has_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->layer(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Visual::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

    // optional float fps = 2;
    if (has_fps()) {
      total_size += 1 + 4;
    }

    // optional .azVisual.Layer layer = 3;
    if (has_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->layer());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Visual::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Visual* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Visual*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Visual::MergeFrom(const Visual& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
    if (from.has_fps()) {
      set_fps(from.fps());
    }
    if (from.has_layer()) {
      mutable_layer()->::azVisual::Layer::MergeFrom(from.layer());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Visual::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Visual::CopyFrom(const Visual& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Visual::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_layer()) {
    if (!this->layer().IsInitialized()) return false;
  }
  return true;
}

void Visual::Swap(Visual* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(fps_, other->fps_);
    std::swap(layer_, other->layer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Visual::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Visual_descriptor_;
  metadata.reflection = Visual_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VisualGroup::kBaseFieldNumber;
const int VisualGroup::kVisualListFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int VisualGroup::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::VisualGroup >, 11, false >
  VisualGroup::type(kTypeFieldNumber, ::azVisual::VisualGroup::default_instance());
VisualGroup::VisualGroup()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VisualGroup::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
}

VisualGroup::VisualGroup(const VisualGroup& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VisualGroup::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VisualGroup::~VisualGroup() {
  SharedDtor();
}

void VisualGroup::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void VisualGroup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VisualGroup::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VisualGroup_descriptor_;
}

const VisualGroup& VisualGroup::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

VisualGroup* VisualGroup::default_instance_ = NULL;

VisualGroup* VisualGroup::New() const {
  return new VisualGroup;
}

void VisualGroup::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
  }
  visual_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VisualGroup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_visual_list;
        break;
      }

      // repeated .azVisual.Visual visual_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_visual_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_visual_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_visual_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VisualGroup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  // repeated .azVisual.Visual visual_list = 2;
  for (int i = 0; i < this->visual_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->visual_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VisualGroup::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  // repeated .azVisual.Visual visual_list = 2;
  for (int i = 0; i < this->visual_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->visual_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VisualGroup::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

  }
  // repeated .azVisual.Visual visual_list = 2;
  total_size += 1 * this->visual_list_size();
  for (int i = 0; i < this->visual_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->visual_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VisualGroup::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VisualGroup* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VisualGroup*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VisualGroup::MergeFrom(const VisualGroup& from) {
  GOOGLE_CHECK_NE(&from, this);
  visual_list_.MergeFrom(from.visual_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VisualGroup::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VisualGroup::CopyFrom(const VisualGroup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisualGroup::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < visual_list_size(); i++) {
    if (!this->visual_list(i).IsInitialized()) return false;
  }
  return true;
}

void VisualGroup::Swap(VisualGroup* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    visual_list_.Swap(&other->visual_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VisualGroup::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VisualGroup_descriptor_;
  metadata.reflection = VisualGroup_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Socket::kBaseFieldNumber;
const int Socket::kReferenceRtidFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int Socket::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Socket >, 11, false >
  Socket::type(kTypeFieldNumber, ::azVisual::Socket::default_instance());
Socket::Socket()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Socket::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
}

Socket::Socket(const Socket& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Socket::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  reference_rtid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Socket::~Socket() {
  SharedDtor();
}

void Socket::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void Socket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Socket::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Socket_descriptor_;
}

const Socket& Socket::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

Socket* Socket::default_instance_ = NULL;

Socket* Socket::New() const {
  return new Socket;
}

void Socket::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
    reference_rtid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Socket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_reference_rtid;
        break;
      }

      // optional uint64 reference_rtid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reference_rtid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &reference_rtid_)));
          set_has_reference_rtid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Socket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  // optional uint64 reference_rtid = 2;
  if (has_reference_rtid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->reference_rtid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Socket::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  // optional uint64 reference_rtid = 2;
  if (has_reference_rtid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->reference_rtid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Socket::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

    // optional uint64 reference_rtid = 2;
    if (has_reference_rtid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->reference_rtid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Socket::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Socket* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Socket*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Socket::MergeFrom(const Socket& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
    if (from.has_reference_rtid()) {
      set_reference_rtid(from.reference_rtid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Socket::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Socket::CopyFrom(const Socket& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Socket::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Socket::Swap(Socket* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(reference_rtid_, other->reference_rtid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Socket::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Socket_descriptor_;
  metadata.reflection = Socket_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SocketGroup::kBaseFieldNumber;
const int SocketGroup::kSocketListFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int SocketGroup::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::SocketGroup >, 11, false >
  SocketGroup::type(kTypeFieldNumber, ::azVisual::SocketGroup::default_instance());
SocketGroup::SocketGroup()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SocketGroup::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
}

SocketGroup::SocketGroup(const SocketGroup& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SocketGroup::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SocketGroup::~SocketGroup() {
  SharedDtor();
}

void SocketGroup::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void SocketGroup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SocketGroup::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SocketGroup_descriptor_;
}

const SocketGroup& SocketGroup::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

SocketGroup* SocketGroup::default_instance_ = NULL;

SocketGroup* SocketGroup::New() const {
  return new SocketGroup;
}

void SocketGroup::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
  }
  socket_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SocketGroup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_socket_list;
        break;
      }

      // repeated .azVisual.Socket socket_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_socket_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_socket_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_socket_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SocketGroup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  // repeated .azVisual.Socket socket_list = 2;
  for (int i = 0; i < this->socket_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->socket_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SocketGroup::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  // repeated .azVisual.Socket socket_list = 2;
  for (int i = 0; i < this->socket_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->socket_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SocketGroup::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

  }
  // repeated .azVisual.Socket socket_list = 2;
  total_size += 1 * this->socket_list_size();
  for (int i = 0; i < this->socket_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->socket_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SocketGroup::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SocketGroup* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SocketGroup*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SocketGroup::MergeFrom(const SocketGroup& from) {
  GOOGLE_CHECK_NE(&from, this);
  socket_list_.MergeFrom(from.socket_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SocketGroup::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SocketGroup::CopyFrom(const SocketGroup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SocketGroup::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < socket_list_size(); i++) {
    if (!this->socket_list(i).IsInitialized()) return false;
  }
  return true;
}

void SocketGroup::Swap(SocketGroup* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    socket_list_.Swap(&other->socket_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SocketGroup::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SocketGroup_descriptor_;
  metadata.reflection = SocketGroup_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EventShape::kBaseFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int EventShape::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::EventShape >, 11, false >
  EventShape::type(kTypeFieldNumber, ::azVisual::EventShape::default_instance());
EventShape::EventShape()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EventShape::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
}

EventShape::EventShape(const EventShape& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EventShape::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EventShape::~EventShape() {
  SharedDtor();
}

void EventShape::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void EventShape::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EventShape::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EventShape_descriptor_;
}

const EventShape& EventShape::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

EventShape* EventShape::default_instance_ = NULL;

EventShape* EventShape::New() const {
  return new EventShape;
}

void EventShape::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EventShape::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EventShape::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EventShape::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EventShape::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EventShape::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EventShape* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EventShape*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EventShape::MergeFrom(const EventShape& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EventShape::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EventShape::CopyFrom(const EventShape& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventShape::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EventShape::Swap(EventShape* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EventShape::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EventShape_descriptor_;
  metadata.reflection = EventShape_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EventShapeGroup::kBaseFieldNumber;
const int EventShapeGroup::kEventShapeListFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int EventShapeGroup::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::EventShapeGroup >, 11, false >
  EventShapeGroup::type(kTypeFieldNumber, ::azVisual::EventShapeGroup::default_instance());
EventShapeGroup::EventShapeGroup()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EventShapeGroup::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
}

EventShapeGroup::EventShapeGroup(const EventShapeGroup& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EventShapeGroup::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EventShapeGroup::~EventShapeGroup() {
  SharedDtor();
}

void EventShapeGroup::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void EventShapeGroup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EventShapeGroup::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EventShapeGroup_descriptor_;
}

const EventShapeGroup& EventShapeGroup::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

EventShapeGroup* EventShapeGroup::default_instance_ = NULL;

EventShapeGroup* EventShapeGroup::New() const {
  return new EventShapeGroup;
}

void EventShapeGroup::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
  }
  event_shape_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EventShapeGroup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_event_shape_list;
        break;
      }

      // repeated .azVisual.EventShape event_shape_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_event_shape_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_event_shape_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_event_shape_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EventShapeGroup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  // repeated .azVisual.EventShape event_shape_list = 2;
  for (int i = 0; i < this->event_shape_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->event_shape_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EventShapeGroup::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  // repeated .azVisual.EventShape event_shape_list = 2;
  for (int i = 0; i < this->event_shape_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->event_shape_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EventShapeGroup::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

  }
  // repeated .azVisual.EventShape event_shape_list = 2;
  total_size += 1 * this->event_shape_list_size();
  for (int i = 0; i < this->event_shape_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->event_shape_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EventShapeGroup::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EventShapeGroup* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EventShapeGroup*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EventShapeGroup::MergeFrom(const EventShapeGroup& from) {
  GOOGLE_CHECK_NE(&from, this);
  event_shape_list_.MergeFrom(from.event_shape_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EventShapeGroup::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EventShapeGroup::CopyFrom(const EventShapeGroup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventShapeGroup::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < event_shape_list_size(); i++) {
    if (!this->event_shape_list(i).IsInitialized()) return false;
  }
  return true;
}

void EventShapeGroup::Swap(EventShapeGroup* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    event_shape_list_.Swap(&other->event_shape_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EventShapeGroup::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EventShapeGroup_descriptor_;
  metadata.reflection = EventShapeGroup_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Particle::kBaseFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int Particle::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Particle >, 11, false >
  Particle::type(kTypeFieldNumber, ::azVisual::Particle::default_instance());
Particle::Particle()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Particle::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
}

Particle::Particle(const Particle& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Particle::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Particle::~Particle() {
  SharedDtor();
}

void Particle::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void Particle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Particle::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Particle_descriptor_;
}

const Particle& Particle::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

Particle* Particle::default_instance_ = NULL;

Particle* Particle::New() const {
  return new Particle;
}

void Particle::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Particle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Particle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Particle::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Particle::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Particle::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Particle* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Particle*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Particle::MergeFrom(const Particle& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Particle::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Particle::CopyFrom(const Particle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Particle::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Particle::Swap(Particle* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Particle::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Particle_descriptor_;
  metadata.reflection = Particle_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ParticleGroup::kBaseFieldNumber;
const int ParticleGroup::kParticleListFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int ParticleGroup::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::ParticleGroup >, 11, false >
  ParticleGroup::type(kTypeFieldNumber, ::azVisual::ParticleGroup::default_instance());
ParticleGroup::ParticleGroup()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ParticleGroup::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
}

ParticleGroup::ParticleGroup(const ParticleGroup& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ParticleGroup::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ParticleGroup::~ParticleGroup() {
  SharedDtor();
}

void ParticleGroup::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void ParticleGroup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ParticleGroup::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ParticleGroup_descriptor_;
}

const ParticleGroup& ParticleGroup::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

ParticleGroup* ParticleGroup::default_instance_ = NULL;

ParticleGroup* ParticleGroup::New() const {
  return new ParticleGroup;
}

void ParticleGroup::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
  }
  particle_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ParticleGroup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_particle_list;
        break;
      }

      // repeated .azVisual.Particle particle_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_particle_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_particle_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_particle_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ParticleGroup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  // repeated .azVisual.Particle particle_list = 2;
  for (int i = 0; i < this->particle_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->particle_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ParticleGroup::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  // repeated .azVisual.Particle particle_list = 2;
  for (int i = 0; i < this->particle_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->particle_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ParticleGroup::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

  }
  // repeated .azVisual.Particle particle_list = 2;
  total_size += 1 * this->particle_list_size();
  for (int i = 0; i < this->particle_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->particle_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParticleGroup::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ParticleGroup* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ParticleGroup*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ParticleGroup::MergeFrom(const ParticleGroup& from) {
  GOOGLE_CHECK_NE(&from, this);
  particle_list_.MergeFrom(from.particle_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ParticleGroup::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParticleGroup::CopyFrom(const ParticleGroup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParticleGroup::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < particle_list_size(); i++) {
    if (!this->particle_list(i).IsInitialized()) return false;
  }
  return true;
}

void ParticleGroup::Swap(ParticleGroup* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    particle_list_.Swap(&other->particle_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ParticleGroup::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ParticleGroup_descriptor_;
  metadata.reflection = ParticleGroup_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Font::kBaseFieldNumber;
const int Font::kFaceFieldNumber;
const int Font::kSizeFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int Font::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::EventShape >, 11, false >
  Font::type(kTypeFieldNumber, ::azVisual::EventShape::default_instance());
Font::Font()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Font::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
}

Font::Font(const Font& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Font::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  face_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Font::~Font() {
  SharedDtor();
}

void Font::SharedDtor() {
  if (face_ != &::google::protobuf::internal::kEmptyString) {
    delete face_;
  }
  if (this != default_instance_) {
    delete base_;
  }
}

void Font::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Font::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Font_descriptor_;
}

const Font& Font::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

Font* Font::default_instance_ = NULL;

Font* Font::New() const {
  return new Font;
}

void Font::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
    if (has_face()) {
      if (face_ != &::google::protobuf::internal::kEmptyString) {
        face_->clear();
      }
    }
    size_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Font::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_face;
        break;
      }

      // optional string face = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_face:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_face()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->face().data(), this->face().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_size;
        break;
      }

      // optional int32 size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Font::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  // optional string face = 2;
  if (has_face()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->face().data(), this->face().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->face(), output);
  }

  // optional int32 size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Font::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  // optional string face = 2;
  if (has_face()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->face().data(), this->face().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->face(), target);
  }

  // optional int32 size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Font::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

    // optional string face = 2;
    if (has_face()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->face());
    }

    // optional int32 size = 3;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Font::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Font* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Font*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Font::MergeFrom(const Font& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
    if (from.has_face()) {
      set_face(from.face());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Font::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Font::CopyFrom(const Font& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Font::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Font::Swap(Font* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(face_, other->face_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Font::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Font_descriptor_;
  metadata.reflection = Font_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Project::kBaseFieldNumber;
const int Project::kVersionFieldNumber;
const int Project::kBitmapListFieldNumber;
const int Project::kSocketGroupListFieldNumber;
const int Project::kEventShapeGroupListFieldNumber;
const int Project::kParticleGroupListFieldNumber;
const int Project::kVisualGroupListFieldNumber;
const int Project::kFontListFieldNumber;
const int Project::kImportProjectListFieldNumber;
#endif  // !_MSC_VER

#ifndef _MSC_VER
const int Project::kTypeFieldNumber;
#endif
::google::protobuf::internal::ExtensionIdentifier< ::azModel::Type,
    ::google::protobuf::internal::MessageTypeTraits< ::azVisual::Project >, 11, false >
  Project::type(kTypeFieldNumber, ::azVisual::Project::default_instance());
Project::Project()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Project::InitAsDefaultInstance() {
  base_ = const_cast< ::azModel::Base*>(&::azModel::Base::default_instance());
}

Project::Project(const Project& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Project::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Project::~Project() {
  SharedDtor();
}

void Project::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
    delete base_;
  }
}

void Project::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Project::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Project_descriptor_;
}

const Project& Project::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_azvisual_2eproto();
  return *default_instance_;
}

Project* Project::default_instance_ = NULL;

Project* Project::New() const {
  return new Project;
}

void Project::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_base()) {
      if (base_ != NULL) base_->::azModel::Base::Clear();
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
  }
  bitmap_list_.Clear();
  socket_group_list_.Clear();
  event_shape_group_list_.Clear();
  particle_group_list_.Clear();
  visual_group_list_.Clear();
  font_list_.Clear();
  import_project_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Project::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .azModel.Base base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_version;
        break;
      }

      // optional string version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_bitmap_list;
        break;
      }

      // repeated .azModel.Bitmap bitmap_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bitmap_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bitmap_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_bitmap_list;
        if (input->ExpectTag(34)) goto parse_socket_group_list;
        break;
      }

      // repeated .azVisual.SocketGroup socket_group_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_socket_group_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_socket_group_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_socket_group_list;
        if (input->ExpectTag(42)) goto parse_event_shape_group_list;
        break;
      }

      // repeated .azVisual.EventShapeGroup event_shape_group_list = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_event_shape_group_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_event_shape_group_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_event_shape_group_list;
        if (input->ExpectTag(50)) goto parse_particle_group_list;
        break;
      }

      // repeated .azVisual.ParticleGroup particle_group_list = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_particle_group_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_particle_group_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_particle_group_list;
        if (input->ExpectTag(58)) goto parse_visual_group_list;
        break;
      }

      // repeated .azVisual.VisualGroup visual_group_list = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_visual_group_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_visual_group_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_visual_group_list;
        if (input->ExpectTag(66)) goto parse_font_list;
        break;
      }

      // repeated .azVisual.Font font_list = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_font_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_font_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_font_list;
        if (input->ExpectTag(74)) goto parse_import_project_list;
        break;
      }

      // repeated string import_project_list = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_import_project_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_import_project_list()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->import_project_list(this->import_project_list_size() - 1).data(),
            this->import_project_list(this->import_project_list_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_import_project_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Project::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }

  // optional string version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->version(), output);
  }

  // repeated .azModel.Bitmap bitmap_list = 3;
  for (int i = 0; i < this->bitmap_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->bitmap_list(i), output);
  }

  // repeated .azVisual.SocketGroup socket_group_list = 4;
  for (int i = 0; i < this->socket_group_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->socket_group_list(i), output);
  }

  // repeated .azVisual.EventShapeGroup event_shape_group_list = 5;
  for (int i = 0; i < this->event_shape_group_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->event_shape_group_list(i), output);
  }

  // repeated .azVisual.ParticleGroup particle_group_list = 6;
  for (int i = 0; i < this->particle_group_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->particle_group_list(i), output);
  }

  // repeated .azVisual.VisualGroup visual_group_list = 7;
  for (int i = 0; i < this->visual_group_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->visual_group_list(i), output);
  }

  // repeated .azVisual.Font font_list = 8;
  for (int i = 0; i < this->font_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->font_list(i), output);
  }

  // repeated string import_project_list = 9;
  for (int i = 0; i < this->import_project_list_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->import_project_list(i).data(), this->import_project_list(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->import_project_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Project::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .azModel.Base base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }

  // optional string version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->version(), target);
  }

  // repeated .azModel.Bitmap bitmap_list = 3;
  for (int i = 0; i < this->bitmap_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->bitmap_list(i), target);
  }

  // repeated .azVisual.SocketGroup socket_group_list = 4;
  for (int i = 0; i < this->socket_group_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->socket_group_list(i), target);
  }

  // repeated .azVisual.EventShapeGroup event_shape_group_list = 5;
  for (int i = 0; i < this->event_shape_group_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->event_shape_group_list(i), target);
  }

  // repeated .azVisual.ParticleGroup particle_group_list = 6;
  for (int i = 0; i < this->particle_group_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->particle_group_list(i), target);
  }

  // repeated .azVisual.VisualGroup visual_group_list = 7;
  for (int i = 0; i < this->visual_group_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->visual_group_list(i), target);
  }

  // repeated .azVisual.Font font_list = 8;
  for (int i = 0; i < this->font_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->font_list(i), target);
  }

  // repeated string import_project_list = 9;
  for (int i = 0; i < this->import_project_list_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->import_project_list(i).data(), this->import_project_list(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(9, this->import_project_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Project::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .azModel.Base base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

    // optional string version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  // repeated .azModel.Bitmap bitmap_list = 3;
  total_size += 1 * this->bitmap_list_size();
  for (int i = 0; i < this->bitmap_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bitmap_list(i));
  }

  // repeated .azVisual.SocketGroup socket_group_list = 4;
  total_size += 1 * this->socket_group_list_size();
  for (int i = 0; i < this->socket_group_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->socket_group_list(i));
  }

  // repeated .azVisual.EventShapeGroup event_shape_group_list = 5;
  total_size += 1 * this->event_shape_group_list_size();
  for (int i = 0; i < this->event_shape_group_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->event_shape_group_list(i));
  }

  // repeated .azVisual.ParticleGroup particle_group_list = 6;
  total_size += 1 * this->particle_group_list_size();
  for (int i = 0; i < this->particle_group_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->particle_group_list(i));
  }

  // repeated .azVisual.VisualGroup visual_group_list = 7;
  total_size += 1 * this->visual_group_list_size();
  for (int i = 0; i < this->visual_group_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->visual_group_list(i));
  }

  // repeated .azVisual.Font font_list = 8;
  total_size += 1 * this->font_list_size();
  for (int i = 0; i < this->font_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->font_list(i));
  }

  // repeated string import_project_list = 9;
  total_size += 1 * this->import_project_list_size();
  for (int i = 0; i < this->import_project_list_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->import_project_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Project::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Project* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Project*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Project::MergeFrom(const Project& from) {
  GOOGLE_CHECK_NE(&from, this);
  bitmap_list_.MergeFrom(from.bitmap_list_);
  socket_group_list_.MergeFrom(from.socket_group_list_);
  event_shape_group_list_.MergeFrom(from.event_shape_group_list_);
  particle_group_list_.MergeFrom(from.particle_group_list_);
  visual_group_list_.MergeFrom(from.visual_group_list_);
  font_list_.MergeFrom(from.font_list_);
  import_project_list_.MergeFrom(from.import_project_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::azModel::Base::MergeFrom(from.base());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Project::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Project::CopyFrom(const Project& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Project::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < bitmap_list_size(); i++) {
    if (!this->bitmap_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < socket_group_list_size(); i++) {
    if (!this->socket_group_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < event_shape_group_list_size(); i++) {
    if (!this->event_shape_group_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < particle_group_list_size(); i++) {
    if (!this->particle_group_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < visual_group_list_size(); i++) {
    if (!this->visual_group_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < font_list_size(); i++) {
    if (!this->font_list(i).IsInitialized()) return false;
  }
  return true;
}

void Project::Swap(Project* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(version_, other->version_);
    bitmap_list_.Swap(&other->bitmap_list_);
    socket_group_list_.Swap(&other->socket_group_list_);
    event_shape_group_list_.Swap(&other->event_shape_group_list_);
    particle_group_list_.Swap(&other->particle_group_list_);
    visual_group_list_.Swap(&other->visual_group_list_);
    font_list_.Swap(&other->font_list_);
    import_project_list_.Swap(&other->import_project_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Project::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Project_descriptor_;
  metadata.reflection = Project_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace azVisual

// @@protoc_insertion_point(global_scope)
